{"meta":{"title":"LeDao的博客","subtitle":"","description":null,"author":"LeDao","url":"https://blog.zoutl.cn","root":"/"},"pages":[{"title":"分类","date":"2021-07-29T07:10:41.000Z","updated":"2021-08-13T08:01:32.895Z","comments":false,"path":"categories/index.html","permalink":"https://blog.zoutl.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-08-12T20:44:05.000Z","updated":"2021-08-13T09:02:31.626Z","comments":true,"path":"links/index.html","permalink":"https://blog.zoutl.cn/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-29T07:11:00.000Z","updated":"2022-04-17T06:00:13.616Z","comments":false,"path":"about/index.html","permalink":"https://blog.zoutl.cn/about/index.html","excerpt":"","text":"个人技能前端技术栈 熟悉HTML的常用组件，可以熟练地进行网页界面开发 熟悉CSS的基本使用，进行网站的美化以及布局调整 熟悉JavaScript、jQuery、Vue.js脚本语言，进行一些网站的动态交互 熟悉Bootstrap、EasyUI、Element UI、Semantic UI、Layui等前端框架，快速进行网站开发 熟悉Ajax、JSON技术，进行前后端信息的交互 后端技术栈 熟悉Java SE的基础语法 了解和会使用Servlet进行项目开发 熟悉Tomcat的基本配置和应用，用以部署Java项目 熟悉JSP、Thymeleaf动态页面技术，实现数据的动态展示 熟悉Shiro、SpringSecurity安全框架的基本使用 熟悉Mybaits、Mybaits-Plus持久层框架，进行数据库的基本操作 熟练使用Spring、Spring MVC、Spring Boot进行项目开发 了解并可以使用Spring Cloud微服务开发 了解和可以使用Redis进行开发，实现项目的数据缓存以提高性能 熟悉Maven的基本使用，如：引入依赖、打包项目、进行模块化开发 熟悉RabbitMQ消息中间件的基本使用，缓解系统的压力并提高用户体验 数据库 熟悉MySQL的基本语法，可以编写较复杂的SQL语句 版本控制 熟悉Git基本命令，进行代码的版本控制 熟悉GitHub、Gitee代码托管平台 运维 熟悉Docker容器化技术的基本使用，进行项目环境的部署和统一管理 了解和可以使用Nginx，实现反向代理、安装SSL证书以及项目的负载均衡 熟悉Linux常用命令，可以在Linux操作系统安装Java项目运行环境以及部署Java项目 熟悉阿里云和腾讯云服务器的配置与使用 开发工具 熟练使用IntelliJ IDEA、WebStorm开发工具 熟悉VS Code的基本使用 熟悉JMeter的基本使用，对项目接口进行高并发测试 项目经历个人项目商品秒杀系统 说明 本项目为前后端分离项目，后端代码有两个版本：一个是单体架构，另一个是微服务架构（对单体架构进行了微服务拆分） 技术栈 单体架构版本 后端项目框架使用了Spring Boot；持久层框架使用了Mybatis-Plus；数据库使用了MySQL5.6；缓存中间件使用了Redis；消息队列使用了RabbitMQ；前端JavaScript框架为Vue.js；桌面端组件库使用了Element 微服务架构版本 在单体架构版本的基础上，多使用了一些技术：微服务框架使用了Spring Cloud Alibaba；微服务注册中心使用了Nacos；Web服务客户端使用了OpenFeign；微服务网关使用了Gateway 功能 用户注册与登录、查看正在秒杀的商品列表、查看正在秒杀的商品详情、秒杀商品、秒杀成功后下单、模拟支付 项目地址 项目介绍地址：https://blog.zoutl.cn/492.html GitHub代码地址： 前端代码：https://github.com/a6678696/miaosha-web 后端代码： 单体架构版本：https://github.com/a6678696/MiaoSha 微服务架构版本：https://github.com/a6678696/miaosha-admin 个人博客系统 技术栈 本项目核心技术采用Spring Boot+Mybaits；开发工具IntelliJ IDEA；数据库MySQL5.6；模版引擎采用的是Thymeleaf；安全框架采用SpringSecurity；在线编辑器CKEditor；Lucene 全文检索；Quartz定时任务；JavaMail实现QQ邮箱发送邮件；highlight.js实现代码高亮； Highcharts图表；Redis存储经常查看的数据 功能 前台 主页分页展示所有博客、按类别分类博客、按日期分类博客、查看博客内容详 情、Lucene全文检索博客标题和摘要、点赞博客、评论博客、网站数据展示 后台 写博客、博客类别管理、博客管理、安全退出、每天23点定时删除无效的博客 图片（删除的博客但未删除其引用的图片）、查看访问记录、一键切换前台UI、评论管理（删除、审核、回复）、查看点赞记录、友情链接管理、一键备份数据以及每天23点定时备份数据（包括 数据库、博客正文图片、Lucene索引）、有人留言给自动给站长发邮件、一键设置邮 件提醒与否、系统自动封禁ip、封禁ip管理、highlight.js代码高亮、后台修改代码风 格、每日访问ip个数统计、每日访问数统计 项目地址 项目演示地址：https://www.zoutl.cn 项目介绍地址：https://blog.zoutl.cn/12.html Github代码地址：https://github.com/a6678696/MyBlog 进销存管理系统 技术栈 本系统使用Spring Boot架构，数据访问层采用Spring Data Jpa，安全框架采用Shiro； 界面采用了jQuery EasyUI；开发工具IntelliJ IDEA；数据库MySQL5.6 功能 进货管理、销售管理、库存管理、统计报表、供应商管理、客户管理、商品管理、期初库存管理、权限管理模块、查看系统日志、修改密码、安全退出 项目地址 项目介绍地址：https://blog.zoutl.cn/13.html Github代码地址：https://github.com/a6678696/JXC 宠物医院管理系统 技术栈 本系统使用Spring Boot架构，数据访问层采用Mybatis，安全框架采用Shiro；前台界面使用Bootstrap，后台界面采用了EasyUI；开发工具IntelliJ IDEA；数据库MySQL5.6；Quartz定时任务 功能 前台 本系统前台面向的用户是客户，客户可以进行预约、浏览医院发布的文章、进入医院商城为宠物购物、如有疑问可以向官方留言、还可以查看关于自己的所有记录信息，如：看病记录、预约记录、疫苗注射记录等 后台 后台面向的用户是医院人员，系统管理员拥有最高权限，可以对所有数据进行管理，为所有的角色分配权限以及创建角色；业务管理员的权限主要是对一些常用数据的维护；医生可以接受客户发布的预约医生的预约单以及处理属于自己的预约单，回答客户的问诊；美容师可以接受客户发布的预约美容的预约单以及处理属于自己的预约单 项目地址 项目介绍地址：https://blog.zoutl.cn/23.html GitHub代码地址：https://github.com/a6678696/PetHospital 资源分享平台 技术栈 本项目核心技术采用Spring Boot+MyBatis；开发工具IntelliJ IDEA；数据库MySQL5.6；模版引擎采用的是Thymeleaf；安全框架采用SpringSecurity；在线编辑器CKEditor； Lucene全文检索；Quartz定时任务；JavaMail实现QQ邮箱发送邮件 功能 用户的功能 注册、登录、找回密码（通过邮箱获取验证码）、查看发布的资源、下载资源、Lucene全文搜索资源、发表评论、修改个人信息、管理个人资源、查看自己的资源下 的评论、查看自己的下载信息、查看属于自己的消息 管理员的功能 用户管理（添加， 修改，删除，查询，封禁或解禁用户，切换用户身份，给用户加积分和减积分）、资源类别管理、资源管理（查看，删除，审核通过和不通过，设置热门与否，设置有效与否）、友情链接管理、评论管理（删除，查询，审核通过和不通过）、下载信息管理、消息管理（删除，查询，给用户发消息）、安全退出 项目地址 项目介绍地址：https://blog.zoutl.cn/76.html GitHub代码地址：https://github.com/a6678696/InformationSharing 在线考试系统 技术栈 本项目核心技术采用Spring Boot+MyBatis+Vue.js；开发工具为IntelliJ IDEA和WebStorm；数据库MySQL5.6；前端框架使用Element UI 功能 考生功能 注册、登录、在线考试（交卷、强制交卷、自动交卷）、查看成绩以及试卷详情、修改密码、注销登录。 教师功能 登录、发布试题（单选题和填空题）、查看全部试题（包括其他教师发布的试题）、我的试题管理（增删改查）、查看全部学生成绩、修改密码、注销登录。 管理员功能 和教师的功能一样，但是多了用户管理（添加、修改、查看用户信息）、全部试题管理、科目管理 项目地址 项目介绍地址：https://blog.zoutl.cn/208.html GitHub代码地址： 前端代码地址：https://github.com/a6678696/ExamSystem2 后端代码地址：https://github.com/a6678696/ExamSystem 校园二手交易平台 技术栈 本项目核心技术采用Spring Boot+Mybatis-Plus；开发工具IntelliJ IDEA；数据库 MySQL5.6；模版引擎采用的是 Thymeleaf；在线编辑器CKEditor；基于JavaMail实现用QQ邮箱发送邮件；前台界面采用了Bootstrap4框架；后台界面采用了jQuery EasyUI框架；Redis存储用户购物车信息；Gson处理JSON数据；Quartz定时任务； 功能 用户的功能 添加商品到购物车、预订商品、前台登录、通过邮箱接受验证码注册和找回密码、查看和修改个人信息、发布商品和管理自己发布的商品（修改、删除、查询、上架、下架、完成交易、取消商品被预订）、管理自己的联系方式（添加、修改、删除、查询）、查看预订记录以及取消预订、查看自己的消息、给管理员留言以及管理自己的留言（查询、修改、删除） 管理员的功能 管理普通用户（添加、修改、删除、查询、封禁与取消封禁）、商品类别管理（添加、修改、删除、查询）、商品管理（查询、删除、审核商品、推荐商品）、管理用户联系方式（修改、删除、查询）、管理用户留言（答复用户的留言、删除、查询）、管理首页的轮播图（添加、修改、删除、查询）、管理公告（添加、修改、删除、查询）、管理预订记录（查询、删除）、管理用户消息（查询、删除）、安全退出后台 系统功能 每隔60分钟将推荐时间过期的商品的推荐状态设置为不推荐 项目地址 项目介绍地址：https://blog.zoutl.cn/420.html GitHub地址：https://github.com/a6678696/SecondHandTrade 图书管理系统 技术栈 本项目核心技术采用Spring Boot+Mybatis；开发工具idea；数据库MySQL5.6；界面采用了jQuery EasyUI框架；Quartz定时任务； 功能 普通用户 查找图书、借书、续借图书、归还图书、修改密码、安全退出系统 管理员 用户管理（增删改查、封禁和解封用户、设置用户是否可借书）、图书类别管理（增删改查）、图书管理（增删改查）、查看用户的借阅记录、修改密码、安全退出系统 系统 每分钟自动检测用户正在借阅的书是否逾期，如果逾期就修改借阅记录的状态为逾期 项目地址 项目介绍地址：https://blog.zoutl.cn/432.html GitHub地址：[https://github.com/a6678696/BookManageSystem]("},{"title":"友情链接","date":"2021-08-13T08:38:47.000Z","updated":"2022-04-17T01:50:03.837Z","comments":true,"path":"link/index.html","permalink":"https://blog.zoutl.cn/link/index.html","excerpt":"","text":"和我互相添加友链步骤 添加我的友链到你的博客友链中，我的友链信息如下： 1234网站名称：LeDao的博客网站地址：https://blog.zoutl.cn/头像：https://image.zoutl.cn/hexo-blog/images/logo.png网站描述或名言：最巨大的遗憾，是被命运安排！ 在下方留言，留下你的友链信息，格式如上所示 特别说明 互相添加友链成功后，请不要单向删除友链（如果你删除了我的友链，我也会删除掉你的） 如果你的博客地址发生了改变，请重新在下方留言留下正确的友链信息，格式如上所示 请不要相信友链中的广告，因为相信广告带来的后果与我无关 友链中如果包含违法信息，与本人无关，一经发现我会单向删除对应友链的信息"},{"title":"壁纸","date":"2022-03-10T19:56:59.000Z","updated":"2022-03-10T21:20:18.243Z","comments":false,"path":"gallery/index.html","permalink":"https://blog.zoutl.cn/gallery/index.html","excerpt":"","text":""},{"title":"我的项目","date":"2021-08-10T14:48:14.000Z","updated":"2021-08-10T16:42:48.174Z","comments":false,"path":"project/index.html","permalink":"https://blog.zoutl.cn/project/index.html","excerpt":"","text":"在线考试系统GitHub地址： ①前端代码地址：https://github.com/a6678696/ExamSystem2 ②后端代码地址：https://github.com/a6678696/ExamSystem 项目介绍地址： https://blog.zoutl.cn/208.html 个人博客系统GitHub地址： https://github.com/a6678696/MyBlog 项目介绍地址： https://blog.zoutl.cn/12.html 项目运行地址： https://www.zoutl.cn 资源分享平台GitHub地址： https://github.com/a6678696/InformationSharing 项目介绍地址： https://blog.zoutl.cn/76.html 宠物医院管理系统GitHub地址： https://github.com/a6678696/PetHospital 项目介绍地址： https://blog.zoutl.cn/23.html 进销存系统GitHub地址： https://github.com/a6678696/JXC 项目介绍地址： https://blog.zoutl.cn/13.html PS.GitHub地址是代码，项目介绍地址是对项目的详细介绍"},{"title":"标签","date":"2021-07-29T07:03:57.000Z","updated":"2021-08-13T08:02:02.866Z","comments":false,"path":"tags/index.html","permalink":"https://blog.zoutl.cn/tags/index.html","excerpt":"","text":""},{"title":"按日期分类","date":"2021-07-29T16:59:04.000Z","updated":"2021-08-03T04:40:02.632Z","comments":false,"path":"time/index.html","permalink":"https://blog.zoutl.cn/time/index.html","excerpt":"","text":"#2021年08月，#2021年07月，#2021年06月，#2021年05月，#2021年04月，#2021年03月，#2021年02月，#2021年01月，#2020年12月，#2020年11月，#2020年10月"}],"posts":[{"title":"Java浮点数的加减乘除运算","slug":"500","date":"2022-04-17T07:57:17.000Z","updated":"2022-04-17T08:27:47.431Z","comments":true,"path":"500.html","link":"","permalink":"https://blog.zoutl.cn/500.html","excerpt":"","text":"概述如果直接直接浮点数之间的运算，有可能会得不到正确结果 Java浮点数优先使用double，先把double转化为String，然后通过BigDecimal的构造方法转化为BigDecimal 最后进行加减乘除的运算使用BigDecimal这个类的方法： 加 public BigDecimal add(BigDecimal augend) 传入的参数为加数 减 public BigDecimal subtract(BigDecimal subtrahend) 传入的参数为减数 乘 public BigDecimal multiply(BigDecimal multiplicand) 传入的参数为乘数 除 public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode) 传入的参数一为除数，参数二为保留的小数位数，参数三为舍入的模式（各种模式看下图） 代码实现1234567891011121314151617181920212223242526import java.math.BigDecimal;import java.math.RoundingMode;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; double d1 = 2.2; double d2 = 1.81; //转化为BigDecimal BigDecimal b1 = new BigDecimal(String.valueOf(d1)); BigDecimal b2 = new BigDecimal(String.valueOf(d2)); //加 System.out.println(b1.add(b2)); //减 System.out.println(b1.subtract(b2)); //乘 System.out.println(b1.multiply(b2)); //除 System.out.println(b1.divide(b2, 2, RoundingMode.HALF_UP)); &#125;&#125; PS.进行除法运算时，一定要指定保留的小数位数和舍入的模式 如果使用public BigDecimal divide(BigDecimal divisor)这个方法，当除不尽时（即结果的小数无限），会报错，报错信息如下图：","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"屏蔽CSDN的会员资源","slug":"499","date":"2022-04-17T03:50:37.000Z","updated":"2022-04-17T04:09:55.616Z","comments":true,"path":"499.html","link":"","permalink":"https://blog.zoutl.cn/499.html","excerpt":"","text":"概述在CSDN查资料总会出现一些会员下载页面，花钱下载是不可能的，况且不一定可以保证资源对我们有用，如果下载了这些没用的资源简直血亏，所以眼不见为净最好 我们可以通过油猴插件的CSDN屏蔽会员资源脚本屏蔽掉这些下载链接（不是破解） 安装油猴插件油猴插件安装地址：Tampermonkey - Microsoft Edge Addons 安装脚本脚本安装地址：CSDN屏蔽会员资源 (greasyfork.org)，安装好后就可以进行屏蔽了","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"Postman汉化教程","slug":"498","date":"2022-04-14T05:34:28.000Z","updated":"2022-04-14T06:08:51.257Z","comments":true,"path":"498.html","link":"","permalink":"https://blog.zoutl.cn/498.html","excerpt":"","text":"查看Postman版本查看当前的版本号是为了下载对应的中文包，我当前的版本为9.12.2 下载中文包下载地址：Releases · hlmd/Postman-cn (github.com) 我当前的版本为9.12.2，所以就要下载9.12.2版本的中文包 安装Postman的默认安装路径如下图 将下载好的中文包复制到resources文件夹中，解压该中文包，然后重启Postman即可 禁止自动更新由于中文包要和Postman的版本对应，所以我们可以禁止Postman的自动更新，主要是为了防止中文包由于版本不对应而失效。不然如果更新了Postman，就根据本教程重新安装最新的中文包","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Postman","slug":"Postman","permalink":"https://blog.zoutl.cn/tags/Postman/"}]},{"title":"Gateway的基本使用","slug":"497","date":"2022-04-14T01:35:42.000Z","updated":"2022-04-17T07:23:48.028Z","comments":true,"path":"497.html","link":"","permalink":"https://blog.zoutl.cn/497.html","excerpt":"","text":"搭建基本框架项目结构 创建父项目作用创建一个父项目（Maven项目，可以把src文件夹删除掉），其作用是用于管理依赖的版本号以及子项目模块 创建过程 pom.xml的内容如下：（modules节点的内容不用管，这是由IntelliJ IDEA自动生成用于管理子项目模块的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;GatewayDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;order&lt;/module&gt; &lt;module&gt;stock&lt;/module&gt; &lt;module&gt;gateway&lt;/module&gt; &lt;module&gt;common&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;springboot.version&gt;2.3.2.RELEASE&lt;/springboot.version&gt; &lt;springcloudalibaba.version&gt;2.2.6.RELEASE&lt;/springcloudalibaba.version&gt; &lt;common.version&gt;1.0-SNAPSHOT&lt;/common.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springcloudalibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;$&#123;common.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 创建公共项目作用创建一个公共项目（Maven项目），用于管理公共依赖、工具类以及实体类等 创建过程 pom.xml的内容如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;GatewayDemo&lt;/artifactId&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建订单项目作用创建一个订单项目模块，模拟真实业务，用于测试 创建过程 pom.xml的内容如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;GatewayDemo&lt;/artifactId&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;order&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置 12345678910111213server: port: 8081 servlet: context-path: / tomcat: uri-encoding: utf-8spring: application: name: order jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss 新建启动类 1234567891011121314151617package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author LeDao * @company * @create 2022-04-11 23:19 */@SpringBootApplicationpublic class OrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(OrderApplication.class, args); &#125;&#125; 控制层，通过http://localhost:8081/order/test访问 1234567891011121314151617181920212223242526package com.ledao.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * @author LeDao * @company * @create 2022-04-11 23:17 */@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; @RequestMapping(&quot;/test&quot;) public Map&lt;String, Object&gt; test() &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(16); resultMap.put(&quot;模块名称&quot;, &quot;订单模块&quot;); resultMap.put(&quot;请求时间&quot;, new Date()); return resultMap; &#125;&#125; 创建库存项目作用创建一个库存项目模块，模拟真实业务，用于测试 创建过程 pom.xml的内容如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;GatewayDemo&lt;/artifactId&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;stock&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置 12345678910111213server: port: 8082 servlet: context-path: / tomcat: uri-encoding: utf-8spring: application: name: stock jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss 新建启动类 1234567891011121314151617package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author LeDao * @company * @create 2022-04-11 23:22 */@SpringBootApplicationpublic class StockApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(StockApplication.class, args); &#125;&#125; 控制层，通过http://localhost:8082/stock/test访问 1234567891011121314151617181920212223242526package com.ledao.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * @author LeDao * @company * @create 2022-04-11 23:23 */@RestController@RequestMapping(&quot;/stock&quot;)public class StockController &#123; @RequestMapping(&quot;/test&quot;) public Map&lt;String, Object&gt; test() &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(16); resultMap.put(&quot;模块名称&quot;, &quot;库存模块&quot;); resultMap.put(&quot;请求时间&quot;, new Date()); return resultMap; &#125;&#125; 测试启动订单项目和库存项目 通过http://localhost:8081/order/test访问，返回： 1&#123;&quot;模块名称&quot;:&quot;订单模块&quot;,&quot;请求时间&quot;:&quot;2022-04-14 11:25:51&quot;&#125; 通过http://localhost:8082/stock/test访问，返回： 1&#123;&quot;模块名称&quot;:&quot;库存模块&quot;,&quot;请求时间&quot;:&quot;2022-04-14 11:25:49&quot;&#125; 出现上面结果说明搭建成功 开始使用Gateway实现访问其它项目接口 首先创建Gateway项目模块，pom.xml内容如下： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;GatewayDemo&lt;/artifactId&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;gateway&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置文件如下，使用spring.cloud.gateway.routes配置 id：路由id，设置为被访问项目的名称 uri：路由地址，设置为被访问项目的端口 predicates：断言规则，设置为被访问项目的请求路径 12345678910111213141516171819202122232425server: port: 8080 servlet: context-path: / tomcat: uri-encoding: utf-8spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - id: stock uri: http://localhost:8082/ predicates: - Path=/stock/** 启动类 1234567891011121314151617package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author LeDao * @company * @create 2022-04-11 23:35 */@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 测试 启动Gateway网关项目 通过http://localhost:8080/order/test访问，返回： 1&#123;&quot;模块名称&quot;:&quot;订单模块&quot;,&quot;请求时间&quot;:&quot;2022-04-14 11:25:51&quot;&#125; 通过http://localhost:8080/stock/test访问，返回： 1&#123;&quot;模块名称&quot;:&quot;库存模块&quot;,&quot;请求时间&quot;:&quot;2022-04-14 11:25:49&quot;&#125; 出现上面结果说明已经成功，其中8080为Gateway网关项目的端口 路由匹配规则 匹配指定日期之后的请求After 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - After=2022-04-14T13:12:12+08:00[Asia/Shanghai] 匹配指定日期之前的请求Before 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - Before=2022-04-14T11:12:00+08:00[Asia/Shanghai] 匹配两个指定日期之间的请求Between 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - Between=2022-04-14T13:12:00+08:00[Asia/Shanghai],2022-04-14T14:12:00+08:00[Asia/Shanghai] Cookie路由匹配规则Cookie，下面配置中token是名称，\\d+为值的匹配规则（只包含数字，1个或多个） 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - Cookie=token, \\d+ Header路由匹配规则Header，下面配置中X-Request-Id是名称，\\d+的说明看上面 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - Header=X-Request-Id, \\d+ Host路由匹配规则，规定只有指定域名才能访问接口，下面配置了mytest.com和mytest2.com两个域名 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - Host=**.mytest.com,**.mytest2.com Method路由匹配规则，下面只匹配GET请求，如果是POST请求就不能访问 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - Method=GET path路由匹配规则，根据请求路径匹配 一些匹配示例说明如下： /order/**：以/order/开头的请求路径 /order/my/&#123;aa&#125;：/order/my/test可以通过，/order/test和/order/my/ss/test不可以通过 12345678910111213spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** Query路由匹配规则，请求时需要带指定参数（值可为空），下面配置中需要带name参数 1234567891011121314spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** - Query=name 内置过滤器AddRequestParameter 向请求接口传递参数，格式为AddRequestParameter=name,ledao，name为参数名，ledao为值 123456789101112131415spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** filters: - AddRequestParameter=name,ledao RewritePath 用于实现URL重写，下面的配置会把/gateway/order/test重写成/order/test 123456789101112131415spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/gateway/** filters: - RewritePath=/gateway(?&lt;segment&gt;/?.*), $\\&#123;segment&#125; SetStatus 设置返回的结果状态码，下面的配置返回404，HTTP常见状态码查看：http常见状态码有哪些 123456789101112131415spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** filters: - SetStatus=404 效果截图 AddResponseHeader 返回信息添加Header头信息 123456789101112131415spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** filters: - AddResponseHeader=X-Response-Author,LeDao 结果截图 更多查看：Spring Cloud Gateway 自定义GatewayFilter 要先把application.yml的Gateway配置删除，然后新建MyGatewayFilter类实现GatewayFilter、Ordered接口重写filter和getOrder方法 1234567891011121314151617181920212223242526272829package com.ledao.filter;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.core.Ordered;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;/** * @author LeDao * @company * @create 2022-04-17 13:01 */public class MyGatewayFilter implements GatewayFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;我的自定义网关过滤器&quot;); //获取请求的参数name的值 System.out.println(exchange.getRequest().getQueryParams().get(&quot;name&quot;)); return chain.filter(exchange); &#125; @Override public int getOrder() &#123; //越小优先级越高 return -1; &#125;&#125; 新建MyGatewayFilterConfig配置类注册Bean 1234567891011121314151617181920212223242526package com.ledao.config;import com.ledao.filter.MyGatewayFilter;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author LeDao * @company * @create 2022-04-17 13:05 */@Configurationpublic class MyGatewayFilterConfig &#123; @Bean public RouteLocator routeLocator(RouteLocatorBuilder builder) &#123; return builder.routes().route(r -&gt; r .path(&quot;/order/**&quot;) .uri(&quot;http://localhost:8081/&quot;) .filter(new MyGatewayFilter()) .id(&quot;myGatewayFilter&quot;) ).build(); &#125;&#125; 自定义GlobalFilter 新建MyGlobalFilter类实现GlobalFilter、Ordered接口重写filter和getOrder方法 12345678910111213141516171819202122232425262728package com.ledao.filter;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;/** * @author LeDao * @company * @create 2022-04-17 13:50 */@Componentpublic class MyGlobalFilter implements GlobalFilter, Ordered &#123; @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123; System.out.println(&quot;我的自定义全局过滤器&quot;); return chain.filter(exchange); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; 限流限流算法Gateway默认给我们实现了限流实现，也就是网关拦截器RequestRateLimiter，RequestRateLimiter的底层实现是令牌桶限流算法，需要引入Redis URL限流 引入Redis依赖 12345678910&lt;!-- spring boot redis 缓存引入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- lettuce pool 缓存连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 限流配置类 123456789101112131415161718192021222324252627package com.ledao.config;import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import reactor.core.publisher.Mono;/** * @author LeDao * @company * @create 2022-04-17 14:36 */@Configurationpublic class KeyResolverConfig &#123; @Bean public KeyResolver pathKeyResolver() &#123; /*return new KeyResolver() &#123; @Override public Mono&lt;String&gt; resolve(ServerWebExchange exchange) &#123; return Mono.just(exchange.getRequest().getURI().getPath()); &#125; &#125;;*/ //URL限流,上面注释代码的lambda写法 return exchange -&gt; Mono.just(exchange.getRequest().getURI().getPath()); &#125;&#125; application.yml配置，把之前的MyGatewayFilterConfig这个类的@Configuration注解删除 1234567891011121314151617181920spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** filters: - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 1 #令牌桶每秒填充速率 redis-rate-limiter.burstCapacity: 2 #令牌桶总容量 redis-rate-limiter.requestedTokens: 1 # 每次请求消耗1个 key-resolver: &quot;#&#123;@pathKeyResolver&#125;&quot; 参数限流 限流配置类，只能存在一个限流Bean，多个会报错，请求时要带token参数（没有就无法请求） 123456789101112131415161718192021222324252627package com.ledao.config;import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import reactor.core.publisher.Mono;import java.util.Objects;/** * @author LeDao * @company * @create 2022-04-17 14:36 */@Configurationpublic class KeyResolverConfig &#123; /** * 参数限流 * * @return */ @Bean public KeyResolver parameterKeyResolver() &#123; return exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getQueryParams().getFirst(&quot;token&quot;))); &#125;&#125; application.yml配置，在之前的基础上直接修改key-resolver 1234567891011121314151617181920spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** filters: - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 1 #令牌桶每秒填充速率 redis-rate-limiter.burstCapacity: 2 #令牌桶总容量 redis-rate-limiter.requestedTokens: 1 # 每次请求消耗1个 key-resolver: &quot;#&#123;@parameterKeyResolver&#125;&quot; IP限流 限流配置类 123456789101112131415161718192021222324252627package com.ledao.config;import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import reactor.core.publisher.Mono;import java.util.Objects;/** * @author LeDao * @company * @create 2022-04-17 14:36 */@Configurationpublic class KeyResolverConfig &#123; /** * IP限流 * * @return */ @Bean public KeyResolver ipKeyResolver() &#123; return exchange -&gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getHostName()); &#125;&#125; application.yml配置 1234567891011121314151617181920spring: application: name: gateway jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ss cloud: gateway: routes: - id: order uri: http://localhost:8081/ predicates: - Path=/order/** filters: - name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 1 #令牌桶每秒填充速率 redis-rate-limiter.burstCapacity: 2 #令牌桶总容量 redis-rate-limiter.requestedTokens: 1 # 每次请求消耗1个 key-resolver: &quot;#&#123;@ipKeyResolver&#125;&quot; PS.官方文档地址：Spring Cloud Gateway","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Gateway","slug":"Gateway","permalink":"https://blog.zoutl.cn/tags/Gateway/"}]},{"title":"Hexo的Butterfly主题更换网站字体","slug":"496","date":"2022-04-12T15:14:30.000Z","updated":"2022-04-15T16:35:16.913Z","comments":true,"path":"496.html","link":"","permalink":"https://blog.zoutl.cn/496.html","excerpt":"","text":"概述hexo的Butterfly主题是可以更换字体的，更换字体的情况分为两种： 使用系统自带的字体 使用从网上下载的字体 实现过程使用系统自带的字体查看系统字体去查看系统有哪些字体，打开设置后根据下图查看（我的电脑系统是Windows11） 设置字体去修改主题文件夹下的_config.yml的配置文件，找到下面代码 12345678910111213# Global font settings# Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)font: global-font-size: code-font-size: font-family: code-font-family: consolas# Font settings for the site title and site subtitle# 左上角網站名字 主頁居中網站名字blog_title_font: font_link: font-family: 一些配置说明如下： 配置 说明 font.font-family 全局字体样式 font.code-font-family 代码字体样式 blog_title_font.font-family 主页的左上角名字以及居中网站名字的字体样式，如果不设置就以全局字体为准 使用从网上下载的字体下载字体网址：字体下载|字体下载大全免费 (ztxz.net.cn) 下载好的字体文件后缀名都是.ttf 使用字体 新建存放下载字体的文件夹 在主题的source文件夹下新建一个font文件夹，用于存放下载的字体 新建CSS文件用于定义和设置网站的字体（设置字体也可以到主题的配置中设置，看上面） 在主题文件夹的/source/css文件夹下新建一个CSS文件，命名为font.css，内容如下： 12345678910111213@font-face&#123; font-family: &#x27;HarmonyOS_Sans&#x27;; font-display: swap; src: url(&#x27;../font/HarmonyOS_Sans.ttf&#x27;) format(&quot;truetype&quot;);&#125;@font-face&#123; font-family: &#x27;MiaoKenTang&#x27;; font-display: swap; src: url(&#x27;../font/MiaoKenTang.ttf&#x27;) format(&quot;truetype&quot;);&#125;body &#123; font-family: &#x27;MiaoKenTang&#x27;;&#125; 在主题配置中引入CSS 去修改主题文件夹下的_config.yml的配置文件，找到下面代码，引入font.css 12345678# Inject# Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)# 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/font.css&quot;&gt; bottom: # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt; 效果截图","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Maven多模块项目的依赖管理与引用","slug":"495","date":"2022-04-12T00:03:04.000Z","updated":"2022-04-14T02:23:21.043Z","comments":true,"path":"495.html","link":"","permalink":"https://blog.zoutl.cn/495.html","excerpt":"","text":"项目结构 父项目创建一个父项目（Maven项目），只用来管理依赖的版本 首先将packaging节点的内容设置为pom，表明只是一个pom项目，只用来聚合工程或传递依赖 1&lt;packaging&gt;pom&lt;/packaging&gt; 在properties节点内管理依赖的版本 123456789&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;springboot.version&gt;2.3.2.RELEASE&lt;/springboot.version&gt; &lt;springcloudalibaba.version&gt;2.2.6.RELEASE&lt;/springcloudalibaba.version&gt; &lt;gson.version&gt;2.9.0&lt;/gson.version&gt;&lt;/properties&gt; 在dependencyManagement节点内定义依赖，然后这些依赖可以在子项目中引用了 12345678910111213141516171819202122232425262728293031&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springcloudalibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.google.code.gson/gson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;$&#123;gson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在子项目中引用的格式如下：（以上面定义的Gson依赖为例，在下面的代码中可以看到省略了版本号） 1234&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 公共项目创建一个公共项目（Maven项目，是父项目的子项目），管理公共依赖、工具类以及实体类等 创建好这个公共项目后，idea在父项目的pom.xml文件的modules节点就引入了这个公共模块（每创建一个子项目就会自动在父项目中引入） 123&lt;modules&gt; &lt;module&gt;common&lt;/module&gt;&lt;/modules&gt; 在dependencies节点中引入公共依赖，就是大多数子项目（两个及以上）都可能会用到的依赖，如果只有某一个子项目单独使用的依赖，就直接在那个子项目pom.xml文件的dependencies节点引入（已经被父项目管理的依赖可以省略版本号，建议省略掉，直接用父项目管理版本号即可） 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 子项目创建子项目（Maven项目，真实的项目），引入公共项目的依赖，格式如下： 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 一些属性来源如下图：（在公共项目的pom.xml中） 不看公共项目的pom.xml快速引入看下面动图：（直接输入公共项目的名称就会出提示） 如果是在公共项目中没有引入的依赖，直接在子项目中引入即可（像上面公共项目那样引入即可） PS.公共项目的版本号也可以丢给父项目管理，首先在父项目的properties节点定义版本号 1&lt;common.version&gt;1.0-SNAPSHOT&lt;/common.version&gt; 在dependencyManagement.dependencies节点中引入 12345&lt;dependency&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;$&#123;common.version&#125;&lt;/version&gt;&lt;/dependency&gt; 在子项目中引入，和上面对比少了版本号 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"}]},{"title":"Hexo安装和卸载插件命令","slug":"494","date":"2022-04-11T03:35:09.000Z","updated":"2022-04-15T16:35:33.396Z","comments":true,"path":"494.html","link":"","permalink":"https://blog.zoutl.cn/494.html","excerpt":"","text":"查看已安装插件hexo的插件配置在根目录的package.json中，在dependencies节点中 12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;hexo generate&quot;, &quot;clean&quot;: &quot;hexo clean&quot;, &quot;deploy&quot;: &quot;hexo deploy&quot;, &quot;server&quot;: &quot;hexo server&quot; &#125;, &quot;hexo&quot;: &#123; &quot;version&quot;: &quot;5.4.0&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^5.0.0&quot;, &quot;hexo-abbrlink&quot;: &quot;^2.2.1&quot;, &quot;hexo-algoliasearch&quot;: &quot;^1.0.0&quot;, &quot;hexo-blog-encrypt&quot;: &quot;^3.1.6&quot;, &quot;hexo-browsersync&quot;: &quot;^0.3.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^3.0.0&quot;, &#125;&#125; 安装命令1npm install 插件名称 --save 卸载命令1npm uninstall 插件名称","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Java在文件内容后面追加内容","slug":"493","date":"2022-04-11T00:37:11.000Z","updated":"2022-04-14T02:23:16.394Z","comments":true,"path":"493.html","link":"","permalink":"https://blog.zoutl.cn/493.html","excerpt":"","text":"FileOutputStream1234567891011121314151617181920212223242526package com.ledao;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;/** * @author LeDao * @company * @create 2022-04-02 7:29 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;C:\\\\Users\\\\LeDao\\\\Desktop\\\\1.txt&quot;); FileOutputStream fileOutputStream = new FileOutputStream(file, true); for (int i = 1; i &lt;= 10; i++) &#123; //追加内容后换行 String content = &quot;内容&quot; + i + &quot;\\r\\n&quot;; //追加内容后不换行 //String content = &quot;内容&quot; + i; fileOutputStream.write(content.getBytes()); &#125; fileOutputStream.close(); &#125;&#125; FileWriter1234567891011121314151617181920212223242526package com.ledao;import java.io.File;import java.io.FileWriter;import java.io.IOException;/** * @author LeDao * @company * @create 2022-04-02 7:29 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;C:\\\\Users\\\\LeDao\\\\Desktop\\\\1.txt&quot;); FileWriter fileWriter = new FileWriter(file, true); for (int i = 1; i &lt;= 10; i++) &#123; //追加内容后换行 String content = &quot;内容&quot; + i + &quot;\\r\\n&quot;; //追加内容后不换行 //String content = &quot;内容&quot; + i; fileWriter.write(content); &#125; fileWriter.close(); &#125;&#125; RandomAccessFile12345678910111213141516171819202122232425262728package com.ledao;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;/** * @author LeDao * @company * @create 2022-04-02 7:29 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;C:\\\\Users\\\\LeDao\\\\Desktop\\\\1.txt&quot;); RandomAccessFile randomAccessFile = new RandomAccessFile(file, &quot;rw&quot;); long length = randomAccessFile.length(); randomAccessFile.seek(length); for (int i = 1; i &lt;= 10; i++) &#123; //追加内容后换行 //String content = &quot;内容&quot; + i + &quot;\\r\\n&quot;; //追加内容后不换行 String content = &quot;内容&quot; + i; randomAccessFile.write(content.getBytes()); &#125; randomAccessFile.close(); &#125;&#125; 使用Hutool引入依赖12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.0.M2&lt;/version&gt;&lt;/dependency&gt; Java代码下面这段代码追加的内容是换行的 1234567891011121314151617181920212223package com.ledao;import cn.hutool.core.io.file.FileAppender;import java.io.File;/** * @author LeDao * @company * @create 2022-04-02 7:29 */public class Test &#123; public static void main(String[] args) &#123; File file = new File(&quot;C:\\\\Users\\\\LeDao\\\\Desktop\\\\1.txt&quot;); FileAppender fileAppender = new FileAppender(file, 16, true); for (int i = 1; i &lt;= 10; i++) &#123; String content = &quot;内容&quot; + i; fileAppender.append(content); &#125; fileAppender.flush(); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"高并发商品秒杀系统","slug":"492","date":"2022-04-09T14:32:33.000Z","updated":"2022-04-09T18:21:35.936Z","comments":true,"path":"492.html","link":"","permalink":"https://blog.zoutl.cn/492.html","excerpt":"","text":"说明本项目为前后端分离项目，后端代码有两个版本：一个是单体架构，另一个是微服务架构（对单体架构进行了微服务拆分） 项目地址前端代码后端代码a6678696/miaosha-web: 高并发商品秒杀系统前端代码（前后端分离项目） (github.com)单体架构版本 a6678696/MiaoSha: 高并发商品秒杀系统后端代码（前后端分离项目，单体架构版本） (github.com) 微服务架构版本 a6678696/miaosha-admin: 高并发商品秒杀系统后端代码（前后端分离项目，微服务架构版本） (github.com) 使用的技术单体架构 技术 说明 Spring Boot 后端项目框架 Mybatis-Plus 持久层框架 MySQL5.6 数据库 Redis 缓存中间件 RabbitMQ 消息队列 Vue.js 前端JavaScript框架 Element 基于 Vue 2.0 的桌面端组件库 微服务架构在单体架构的基础上，多使用了以下技术： 技术 说明 Spring Cloud 微服务框架 Spring Cloud Alibaba 阿里微服务框架 Nacos 微服务注册中心 OpenFeign Web服务客户端 Gateway 微服务网关 功能介绍 用户注册与登录 查看正在秒杀的商品列表 查看正在秒杀的商品详情 秒杀商品，成功后下单 模拟支付 图片展示注册界面 登录界面 查看正在秒杀的商品 秒杀页面 我的订单 模拟支付 注销登录 模拟海量用户秒杀用户批量注册下面方法批量注册1000个用户到数据库中，如果是导入我的数据库文件可忽略此步 用户批量登录执行这步前要先注册用户，如果是微服务架构就请求http://localhost:8080/user/loginAuto 这个接口即可实现批量登录，并把对应的userId和Token保存到TXT文件中 测试并发测试使用JMeter这个软件，安装与使用教程查看这几篇博客：标签: JMeter | LeDao 的博客 (zoutl.cn) 测试前先删除Redis中对应的秒杀商品的key，确认可秒杀商品的数量不为0 测试的接口为：http://localhost:8080/order/save，参数如下图所示","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"JMeter使用CSV数据文件设置","slug":"491","date":"2022-04-05T04:42:36.000Z","updated":"2022-04-05T17:48:16.049Z","comments":true,"path":"491.html","link":"","permalink":"https://blog.zoutl.cn/491.html","excerpt":"","text":"概述使用CSV数据文件设置可以给HTTP请求设置多组参数 使用过程新建参数文件新建一个TXT文件，用于设置多组HTTP请求的参数，每一行为一组参数，多个参数之间用英文逗号,隔开 新建CSV数据文件设置 在对应线程下添加CSV Data Set Config 一些设置 配置参数的获取","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"JMeter","slug":"JMeter","permalink":"https://blog.zoutl.cn/tags/JMeter/"}]},{"title":"JMeter的基本使用","slug":"490","date":"2022-04-04T13:38:42.000Z","updated":"2022-04-14T11:20:30.247Z","comments":true,"path":"490.html","link":"","permalink":"https://blog.zoutl.cn/490.html","excerpt":"","text":"添加线程组 右键点击Test Plan，新建一个线程组 填写线程数 添加HTTP请求默认值 添加了HTTP请求默认值后，可以统一管理HTTP请求的IP地址和端口号 添加HTTP请求 添加HTTP请求用于测试接口 如果配置了HTTP请求默认值，那么就不需要配置HTTP请求的Web服务器了 给请求添加参数 如果有一些数据是通过信息头传递的，那么需要配置一下HTTP信息头管理器，然后添加参数即可 添加监听器 添加一些监听器，用于查看测试的效果 测试 点击菜单栏的启动按钮 查看结果聚合报告 汇总报告 察看结果树 用表格察看结果 PS.解决中文乱码 添加一个BeanShell PostProcessor后置处理器 添加以下代码 1prev.setDataEncoding(&quot;utf-8&quot;); 禁用HTTP请求如果有多个HTTP请求，那么JMeter启动时，这些HTTP请求都会被执行，如果不需要执行某个HTTP请求，那么我们需要禁用掉不需要执行的HTTP请求","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"JMeter","slug":"JMeter","permalink":"https://blog.zoutl.cn/tags/JMeter/"}]},{"title":"Vue.js获取对象的值","slug":"489","date":"2022-04-01T22:13:49.000Z","updated":"2022-04-14T01:57:33.567Z","comments":true,"path":"489.html","link":"","permalink":"https://blog.zoutl.cn/489.html","excerpt":"","text":"概述Vue.js要获取对象的值，不能像普通值那样设置，对象的每个字段都需要在data()&#123;return&#123;&#125;&#125;中进行设置，然后我们才可以获取到对象的值，对象的对象的值也可以获取到 实现过程实体类秒杀商品实体类内有一个组合：商品实体类，也就是说，查询秒杀商品时也同时查询到对应的商品 商品实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;import java.io.Serializable;/** * 商品实体类 * * @author LeDao * @company * @create 2022-04-01 17:59 */@Data@TableName(&quot;t_goods&quot;)public class Goods implements Serializable &#123; /** * 编号 */ @TableId private Integer id; /** * 名称 */ private String name; /** * 价格 */ private Double price; /** * 图片 */ private String image; /** * 库存 */ private Integer stock; /** * 详情 */ private String detail; private static final long serialVersionUID = 1L;&#125; 秒杀商品实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.ledao.entity;import java.io.Serializable;import java.util.Date;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * 秒杀商品实体类 * * @author LeDao * @company * @create 2022-04-01 18:31 */@Data@TableName(&quot;t_miaosha_goods&quot;)public class MiaoShaGoods implements Serializable &#123; /** * 编号 */ @TableId private Integer id; /** * 真实商品id */ @TableField(value = &quot;goodsId&quot;) private Integer goodsId; /** * 商品实体,获取对应商品的信息 */ @TableField(exist = false) private Goods goods; /** * 秒杀的价格 */ private Double price; /** * 秒杀的数量 */ private Integer stock; /** * 开始时间 */ @TableField(value = &quot;startTime&quot;) private Date startTime; /** * 结束时间 */ @TableField(value = &quot;endTime&quot;) private Date endTime; private static final long serialVersionUID = 1L;&#125; Vue代码 数据绑定模板如下： 1234567891011121314151617181920data() &#123; return &#123; miaoShaGoods: &#123; id: 0, goodsId: 0, price: 0, stock: 0, startTime: &#x27;&#x27;, endTime: &#x27;&#x27;, goods: &#123; id: 0, name: &#x27;&#x27;, price: 0, image: &#x27;&#x27;, stock: 0, detail: &#x27;&#x27; &#125; &#125; &#125;&#125; 下面的代码请求了后端，并把请求到的数据绑定到Vue，然后可以通过&#123;&#123;miaoShaGoods.goods.id&#125;&#125;查到秒杀商品对应的商品id了 123456789101112openMiaoShaDialog: function (id) &#123; let _this = this; let url = getServerUrl(&quot;miaoShaGoods/findById?id=&quot; + id); axios .get(url) .then(function (response) &#123; _this.miaoShaGoods = response.data; &#125;) .catch(function (error) &#123; console.log(error); &#125;);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"安装JMeter","slug":"488","date":"2022-04-01T21:39:16.000Z","updated":"2022-04-11T03:31:26.305Z","comments":true,"path":"488.html","link":"","permalink":"https://blog.zoutl.cn/488.html","excerpt":"","text":"下载下载地址：Apache JMeter - Download Apache JMeter 下载zip压缩包的那个，解压后即可使用 打开解压后，进入bin文件夹，双击jmeter.bat即可 改进放大字体直接打开的话，可以看到界面的字体很小，我们需要将它放大一下 打开jmeter.properties，修改jsyntaxtextarea.font.size的值，并把它前面的注释删除 使用记事本工具打开jmeter.bat，在第一行下面加入以下代码： 1234set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.controlFont=Dialog-25set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.systemFont=Dialog-25set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.userFont=SansSerif-25set JVM_ARGS=%JVM_ARGS% -Dswing.plaf.metal.smallFont=SansSerif-25 修改语言根据下图将语言修改为中文简体即可 PS.直接进入官网下载的是最新版，历史版本的链接为：Index of /dist/jmeter/binaries (apache.org)","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"JMeter","slug":"JMeter","permalink":"https://blog.zoutl.cn/tags/JMeter/"}]},{"title":"Spring Boot项目在新版IntelliJ IDEA配置热部署","slug":"487","date":"2022-03-29T09:13:44.000Z","updated":"2022-04-14T02:46:04.158Z","comments":true,"path":"487.html","link":"","permalink":"https://blog.zoutl.cn/487.html","excerpt":"","text":"概述我当前使用的idea版本为2021.3.3，热部署的配置和以前不一样了，比以前更麻烦 配置过程引入依赖123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 修改设置使用CTRL+ALT+S快捷键打开设置，根据下面的图片设置","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"CentOS7实现Nacos注册中心集群","slug":"486","date":"2022-03-28T14:14:23.000Z","updated":"2022-04-14T02:23:00.830Z","comments":true,"path":"486.html","link":"","permalink":"https://blog.zoutl.cn/486.html","excerpt":"","text":"概述在https://blog.zoutl.cn/472.html的基础上修改，之前是单机模式运行，在确保能单机运行后再看本教程 最好有一台云服务器，三个Nacos注册中心都连云服务器的MySQL数据库 实现过程下面是一台虚拟机的Nacos注册中心配置以及启动，其它两台虚拟机都是一样的操作 修改启动脚本如果之前把启动模式修改成了单机，就要修改成cluster 配置集群的IP以及端口进入conf目录，会有一个cluster.conf.example文件，把它重命名为cluster.conf，或者使用下面命令将它复制到现在的位置并命名为cluster.conf，cluster.conf是集群的各个IP地址以及端口的配置文件 1cp cluster.conf.example cluster.conf 打开cluster.conf，添加以下内容：（IP以及端口根据实际情况填写） 123192.168.0.104:8848192.168.0.105:8848192.168.0.141:8848 设置连接的数据库进入conf目录，会有一个application.properties文件，打开它找到下图的数据库配置并修改成云服务器的 运行进入bin目录，执行下面命令运行Nacos注册中心 1sh startup.sh 结果进入Nacos界面查看注册中心的集群，看到节点状态都是UP，说明已经成功了 application.yml配置调用服务的以及被调用的服务都要设置 在server-addr后接IP地址以及端口，用英文逗号隔开，这样服务就可以注册到集群的每个Nacos注册中心上了 123456789101112server: port: 8081 servlet: context-path: /spring: application: name: nacos-order cloud: nacos: discovery: server-addr: 121.41.111.222:8848,175.111.222.21:8848 PS.我有两台云服务器，一台的运行内存为2G，另一台为4G。弄集群时，2G的服务器的Nacos会崩掉，4G的可以正常运行，所以推荐云服务器的运行内存要4G起步","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"}]},{"title":"实现被调用的微服务集群以及调用时负载均衡","slug":"485","date":"2022-03-28T13:30:10.000Z","updated":"2022-04-14T02:22:58.346Z","comments":true,"path":"485.html","link":"","permalink":"https://blog.zoutl.cn/485.html","excerpt":"","text":"概述在https://blog.zoutl.cn/483.html的基础上操作，前面的博客实现了调用库存微服务，现在再添加一个库存微服务实现库存微服务集群，在调用库存微服务时就自动实现了负载均衡，所以只需要实现库存微服务集群即可实现负载均衡 实现过程添加的库存微服务的代码和之前的基本相同，要修改的地方如下： 修改微服务的端口，之前的是8082 123456789101112server: port: 8083 servlet: context-path: /spring: application: name: nacos-stock cloud: nacos: discovery: server-addr: 121.41.111.222:8848 修改启动类的名称，主要是方便辨认，不改也行，之前的名称是NacosStockApplication 12345678910111213141516171819package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @author LeDao * @company * @create 2022-03-28 19:45 */@EnableDiscoveryClient@SpringBootApplicationpublic class NacosStockApplication2 &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosStockApplication2.class, args); &#125;&#125; 修改被调用的方法，为了易于辨认调用的是哪个微服务，之前的没有2 12345678910111213141516171819package com.ledao.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author LeDao * @company * @create 2022-03-28 20:20 */@RestController@RequestMapping(&quot;/stock&quot;)public class StockController &#123; @RequestMapping(&quot;/test&quot;) public String test(String info) &#123; return &quot;库存模块2收到的消息: &quot; + info; &#125;&#125; 结果 启动先添加的库存微服务模块，去Nacos注册中心界面查看服务列表 通过localhost:8081/order/test调用，会发现交替调用两个库存微服务，此时已经实现了被调用的微服务集群以及调用时负载均衡 PS.Nacos一些操作 点击服务列表的详情查看某个微服务的集群 修改微服务被调用的权重，点击上图的编辑，权重越大被调用的机会越大 下线微服务，点击下图的下线或在上图中关闭上线 指定命名空间以及名称我们可以将服务注册到指定命名空间以及自定义集群的名称，在集群的微服务的配置文件中设置即可（集群下的所有微服务的配置文件都需要设置，调用的订单微服务也要设置命名空间，不在同一个命名空间就无法调用），看下面有注释的两个配置 1234567891011121314server: port: 8082 servlet: context-path: /spring: application: name: nacos-stock cloud: nacos: discovery: server-addr: 121.41.111.222:8848 namespace: e4f40c45-6d6d-44dc-8bea-64511127824 #命名空间的id cluster-name: LeDao #被调用微服务集群的名称,一定要相同,不然就不是一个集群了","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"}]},{"title":"OpenFeign实现服务之间的调用（使用Nacos注册中心）","slug":"484","date":"2022-03-28T12:10:13.000Z","updated":"2022-04-14T02:22:55.832Z","comments":true,"path":"484.html","link":"","permalink":"https://blog.zoutl.cn/484.html","excerpt":"","text":"概述被调用的服务已经注册到Nacos，注册步骤查看博客：https://blog.zoutl.cn/483.html 注册两个服务到Nacos，一个名为nacos-order（订单微服务），另一个名为nacos-stock（库存微服务），订单微服务调用库存微服务 实现过程库存微服务 在库存微服务中添加一个被调用的方法（Controller类） 123456789101112131415161718192021package com.ledao.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;/** * @author LeDao * @company * @create 2022-03-28 20:20 */@RestController@RequestMapping(&quot;/stock&quot;)public class StockController &#123; @RequestMapping(&quot;/test&quot;) public String test(String info) &#123; return new Date() + &quot; : &quot; + info; &#125;&#125; 订单微服务 引入依赖，OpenFeign依赖是用来调用服务的 12345&lt;!-- OpenFeign --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 新建一个Service类调用服务，@FeignClient注解用来确定调用的是哪个微服务 12345678910111213141516171819202122package com.ledao.feign;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;/** * @author LeDao * @company * @create 2022-03-28 20:42 */@FeignClient(&quot;nacos-stock&quot;)public interface StockFeignService &#123; /** * 调用服务 * * @param info * @return */ @RequestMapping(&quot;/stock/test&quot;) String test(@RequestParam(&quot;info&quot;) String info);&#125; 启动类添加@EnableFeignClients注解，参数为调用服务的Service类所在的包（也就是使用了@FeignClient注解的类所在的包），这样才能调用服务 123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;/** * @author LeDao * @company * @create 2022-03-28 19:40 */@EnableDiscoveryClient@SpringBootApplication@EnableFeignClients(basePackages = &quot;com.ledao.feign&quot;)public class NacosOrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosOrderApplication.class, args); &#125;&#125; 测试调用（使用Controller类） 12345678910111213141516171819202122232425262728package com.ledao.controller;import com.ledao.feign.StockFeignService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author LeDao * @company * @create 2022-03-28 20:52 */@RestController@RequestMapping(&quot;/order&quot;)public class OrderController &#123; private StockFeignService stockFeignService; @Autowired public void setStockFeignService(StockFeignService stockFeignService) &#123; this.stockFeignService = stockFeignService; &#125; @RequestMapping(&quot;/test&quot;) public String test() &#123; return stockFeignService.test(&quot;调用库存微服务&quot;); &#125;&#125; 测试先启动库存微服务，再启动订单微服务，然后通过localhost:8081/order/test调用（具体端口看订单微服务的application.yml配置文件）","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"},{"name":"OpenFeign","slug":"OpenFeign","permalink":"https://blog.zoutl.cn/tags/OpenFeign/"}]},{"title":"注册服务到Nacos","slug":"483","date":"2022-03-28T11:51:23.000Z","updated":"2022-04-14T02:22:53.731Z","comments":true,"path":"483.html","link":"","permalink":"https://blog.zoutl.cn/483.html","excerpt":"","text":"前提已经配置好Nacos注册中心，配置步骤查看博客：https://blog.zoutl.cn/472.html 实现过程创建项目创建一个Maven项目，这个项目就是一个服务，注册到Nacos 引入依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 服务注册/发现--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置123456789101112server: port: 8081 servlet: context-path: /spring: application: name: nacos-order cloud: nacos: discovery: server-addr: 121.41.111.222:8848 创建启动类@EnableDiscoveryClient这个注解能够让Nacos注册中心发现这个服务 12345678910111213141516171819package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;/** * @author LeDao * @company * @create 2022-03-28 19:40 */@EnableDiscoveryClient@SpringBootApplicationpublic class NacosOrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosOrderApplication.class, args); &#125;&#125; 结果运行启动类后，到Nacos注册中心界面查看结果，可以发现服务已经注册成功了","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"}]},{"title":"CentOS7忘记MySQL密码后重置","slug":"482","date":"2022-03-27T19:47:52.000Z","updated":"2022-04-14T02:37:18.916Z","comments":true,"path":"482.html","link":"","permalink":"https://blog.zoutl.cn/482.html","excerpt":"","text":"概述MySQL是不能查看密码的，如果忘记了就只能重置了 重置过程 先停止MySQL 1systemctl stop mysqld 修改my.cnf，路径为/ect/my.cnf，在[mysqld]下面添加skip-grant-tables 启动MySQL 1systemctl start mysqld 使用下面命令进入MySQL命令行，提示要输入密码直接按回车键即可 1mysql -uroot -p 切换到mysql数据库 1use mysql 修改密码 1update user set authentication_string=PASSWORD(&quot;这里填密码&quot;) where user=&#x27;root&#x27;; 刷新授权列表 1flush privileges; 退出 1exit 修改my.cnf，路径为/ect/my.cnf，删除[mysqld]下面之前添加的skip-grant-tables，或者在它前面加#符号注释掉 重启MySQL，新密码就生效了 1systemctl restart mysqld PS.CentOS7操作MySQL命令的一些命令如下： 查看MySQL运行状态 1systemctl status mysqld 停止MySQL 1systemctl stop mysqld 启动MySQL 1systemctl start mysqld 重启MySQL 1systemctl restart mysqld","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"使用AdBlock屏蔽掉GitHub上一些让人恶心的仓库","slug":"481","date":"2022-03-25T16:11:10.000Z","updated":"2022-04-14T01:53:02.018Z","comments":true,"path":"481.html","link":"","permalink":"https://blog.zoutl.cn/481.html","excerpt":"","text":"概述GitHub虽然好用，但是上面有不少境外黑恶势力恶意造谣抹黑中国的仓库，看到了就让人恶心 GitHub的屏蔽功能并没什么卵用，举报也没用，纯属浪费时间，但是我们可以通过AdBlock或AdBlock Plus插件进行屏蔽这些仓库的所有者 下面的方法只实现了屏蔽掉搜索结果中的仓库，但还是可以直接通过链接访问这些仓库，不过这已经可以实现这些仓库不会出现在我们眼前，污了我们的眼睛 实现过程安装插件下面有两个下载地址，根据自己的情况选择： 谷歌插件商店地址：AdBlock — 最佳广告拦截工具 - Chrome 网上应用店 (google.com) 扩展迷下载地址：https://www.extfans.com/productivity/gighmmpiobklfepjocnamgkkbiglidom/ 添加拦截规则点击工具栏的AdBlock的图标，打开选项 添加自定义规则（下面列举几个常见的，每一条规则的第二个括号内就是仓库所有者的用户名，根据实际情况填写，发现其它的继续添加即可），最后保存即可，这样就可以在搜索结果中屏蔽掉这些仓库的所有者了，舒服！！ 12345github.com#?#li.repo-list-item.public.source:-abp-has(a:-abp-contains(cirosantilli))github.com#?#li.repo-list-item.public.source:-abp-has(a:-abp-contains(cheezcharmer))github.com#?#li.repo-list-item.public.source:-abp-has(a:-abp-contains(zaohmeing))github.com#?#li.repo-list-item.public.source:-abp-has(a:-abp-contains(zhaohmng-outlook-com))github.com#?#li.repo-list-item.public.source:-abp-has(a:-abp-contains(coding-stuffs)) PS.来源：如果举报github上的这种情况？ - 知乎 (zhihu.com)","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"AdBlock","slug":"AdBlock","permalink":"https://blog.zoutl.cn/tags/AdBlock/"}]},{"title":"使用批处理脚本实现一键部署hexo博客以及一键上传代码到GitHub","slug":"480","date":"2022-03-25T06:19:53.000Z","updated":"2022-04-14T02:01:06.212Z","comments":true,"path":"480.html","link":"","permalink":"https://blog.zoutl.cn/480.html","excerpt":"","text":"概述如果需要执行多条命令才可以达到目的，都可以使用批处理脚本来提高工作效率，本博客主要实现：一键部署hexo博客以及一键上传代码到GitHub 实现一键部署hexo博客新建一个.bat文件，命名为：一键部署.bat，内容如下：（我的博客使用了algolia搜索，如果没有使用就删除下面的hexo algolia） 123@echo offcd E:\\hexo-bloghexo clean&amp;&amp;hexo g&amp;&amp;hexo algolia&amp;&amp;hexo d 一键上传代码到GitHub先配置GitHub的SSH Key，配置步骤查看博客：GitHub 配置 SSH Key | LeDao 的博客 (zoutl.cn) 新建一个.bat文件，命名为一键上传到GitHub.bat：，内容如下：（chcp 65001是为了解决输出中文乱码） 12345678910111213141516chcp 65001@echo offecho &quot;1.进入要上传的文件hexo-blog&quot;cd E:\\hexo-blogecho &quot;2.添加到本地仓库&quot;git add .echo &quot;3.设置提交信息&quot;set now=%date% %time%git commit -m &quot;%now%&quot;echo &quot;4.开始push&quot;git push -u origin master","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.zoutl.cn/tags/hexo/"}]},{"title":"Hexo的Butterfly主题使用Algolia搜索","slug":"479","date":"2022-03-23T12:02:27.000Z","updated":"2022-04-15T16:35:29.822Z","comments":true,"path":"479.html","link":"","permalink":"https://blog.zoutl.cn/479.html","excerpt":"","text":"安装插件在hexo博客的根目录打开Git Bash安装hexo-algoliasearch插件 1npm install hexo-algoliasearch --save 然后查看根目录的package.json文件，查看是否安装成功，出现插件名称就说明安装插件成功 注册Algolia账号网址：Site Search &amp; Discovery powered by AI | Algolia 创建应用打开创建页面 填写应用信息 选择相关节点 勾选同意 获取API Keys在控制台主页，选择刚刚创建的应用，查看它的API Keys 获取下图的三个 开始配置在hexo根目录下的_config.yml配置文件添加以下代码，appId、apiKey、adminApiKey、indexName根据自己的情况填写 12345678910111213141516plugins: - hexo-algoliasearchalgolia: appId: &quot;0Z2Q111FG111&quot; apiKey: &quot;079e96e1d3e11111116bf59011&quot; adminApiKey: &quot;9e2f194f9f28111111199ce53111&quot; chunkSize: 5000 indexName: &quot;hexo_blog&quot; fields: - content:strip:truncate,0,200 - tags - permalink - excerpt:strip - title - categories 修改Butterfly主题的_config.yml配置文件 12345# Algolia searchalgolia_search: enable: true hits: per_page: 6 接下来需要将搜索方式设置为按回车键后才搜索，要不然每输入一个字符就实时搜索一次太浪费Algolia的搜索次数了，Algolia的免费次数每个月只有10000次，实时搜索很容易把次数用光，首先打开algolia.js文件，这个文件在\\themes\\butterfly\\source\\js\\search目录下，在下图位置加入代码： 1searchOnEnterKeyPressOnly: true, 接下来修改搜索框的提示信息，上图横线下的placeholder:后接提示信息，建议直接注释掉该行（使用//注释），直接重写，不建议去修改语言配置文件（在\\themes\\butterfly\\languages目录下） 1placeholder: &quot;输入关键词后，按下回车键即可搜索文章...&quot; 依次执行以下命令12345678#清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo clean#生成Algolia索引hexo algolia#生成静态文件hexo g#部署网站，同时将网站的改动提交到GitHub仓库hexo d 查看结果执行启动服务器命令hexo s查看结果，访问网址为： http://localhost:4000/ PS.执行命令的顺序如下：（不然可能会出现一些错误） 1234567891011#清除缓存以及一些静态文件hexo clean#生成静态文件hexo g#生成algolia的搜索索引hexo algolia#提交到GitHubhexo d","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"PotPlayer播放视频选择音频","slug":"478","date":"2022-03-22T07:18:52.000Z","updated":"2022-03-26T10:18:29.858Z","comments":true,"path":"478.html","link":"","permalink":"https://blog.zoutl.cn/478.html","excerpt":"","text":"概述IDM下载B站的视频时，下载的视频是没有声音的，必须要下载对应的音频文件，例如：下图中，2是音频，3是视频，下面我将演示PotPlayer播放视频导入音频 实现过程 将音频文件的后缀名改为m4a 使用PotPlayer播放视频，并选择刚刚修改后缀名的音频，然后就可以愉快地玩耍了","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"Hexo的Butterfly主题使用iconfont图标","slug":"477","date":"2022-03-21T15:53:43.000Z","updated":"2022-04-15T16:35:26.350Z","comments":true,"path":"477.html","link":"","permalink":"https://blog.zoutl.cn/477.html","excerpt":"","text":"登录网址：iconfont-阿里巴巴矢量图标库 搜索图标在搜索框输入图标名称 添加入库将鼠标移到要使用的图标上 添加到项目打开项目选项，准备添加到项目 添加到指定项目 生成Font class生成Font class用于引入图标 复制链接和图标复制引入图标的链接以及图标名称 修改配置文件修改Butterfly主题的配置文件_config.yml，不是主配置文件，主题配置文件在\\themes\\butterfly下 引入找到Inject配置，在head处引入 使用使用格式为：iconfont 上面复制的图标名称","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"实现加载Nacos多个配置文件","slug":"476","date":"2022-03-20T12:43:51.000Z","updated":"2022-04-14T11:29:04.420Z","comments":true,"path":"476.html","link":"","permalink":"https://blog.zoutl.cn/476.html","excerpt":"","text":"概述多个微服务的配置之间有可能存在重复，重复的部分称为公共配置，我们可以把这些公共配置存储在Nacos中，各个微服务根据自己的需求加载对应的配置 这样做的好处是：方便管理，只需要修改公共配置即可实现修改多个服务的配置 实现过程前提加载的配置文件必须在同一个命名空间内 添加配置我在命名为dev的命名空间内创建了三个配置文件：mysql_dev.properties、 server_dev.properties和 nacos_config.properties，内容如下： mysql_dev.properties 12345spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/db_secondhandtrade?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123456 server_dev.properties 123server.port=8888server.servlet.context-path=/server.tomcat.uri-encoding=UTF-8 nacos_config.properties 12ledao.name=maryledao.age=22 bootstrap.properties加载bootstrap比application配置文件的优先级高，如果存在一样的配置，以bootstrap的为准，加载多配置使用数组的形式，项目的配置文件只需要配置Nacos的IP地址和端口号、命名空间id，其它的配置从Nacos中加载 12345678910111213141516171819202122232425#应用名称,可省略spring.application.name=nacos_config_test#Nacos的IP地址和端口号spring.cloud.nacos.config.server-addr=121.41.211.106:8848#Nacos配置文件所在命名空间idspring.cloud.nacos.config.namespace=e4f40c45-6d6d-44dc-8bea-645f5d727824#Nacos配置文件所在组名#spring.cloud.nacos.config.group=DEFAULT_GROUP#要读取的配置文件名称#spring.cloud.nacos.config.name=nacos_config.properties#加载mysql_dev.properties的配置spring.cloud.nacos.config.extension-configs[0].dataId=mysql_dev.propertiesspring.cloud.nacos.config.extension-configs[0].group=DEFAULT_GROUPspring.cloud.nacos.config.extension-configs[0].refresh=true#加载server_dev.properties的配置spring.cloud.nacos.config.extension-configs[1].dataId=server_dev.propertiesspring.cloud.nacos.config.extension-configs[1].group=DEFAULT_GROUPspring.cloud.nacos.config.extension-configs[1].refresh=true#加载nacos_config.properties的配置spring.cloud.nacos.config.extension-configs[2].dataId=nacos_config.propertiesspring.cloud.nacos.config.extension-configs[2].group=DEFAULT_GROUPspring.cloud.nacos.config.extension-configs[2].refresh=true 控制层1234567891011121314151617181920212223242526272829303132333435package com.ledao.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.sql.DataSource;/** * @author LeDao * @company * @create 2022-03-19 10:45 */@RefreshScope@RestController@RequestMapping(&quot;/nacos&quot;)public class NacosConfigController &#123; @Value(&quot;$&#123;ledao.name&#125;&quot;) private String name; @Value(&quot;$&#123;ledao.age&#125;&quot;) private String age; @Resource private DataSource dataSource; @GetMapping(&quot;/getUserInfo&quot;) public String getUserInfo() throws Exception &#123; return name + &quot; : &quot; + age + &quot; , &quot; + dataSource.getConnection(); &#125;&#125; 测试浏览器地址栏输入：http://localhost:8888/nacos/getUserInfo ，看到下图说明已经成功加载三个配置文件","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"}]},{"title":"Nacos新建命名空间和读取命名空间内的配置文件","slug":"475","date":"2022-03-19T03:49:46.000Z","updated":"2022-04-14T02:22:37.766Z","comments":true,"path":"475.html","link":"","permalink":"https://blog.zoutl.cn/475.html","excerpt":"","text":"新建命名空间创建成功后自动生成命名空间id，下面要用到 新建配置文件在刚刚创建好的命名空间创建配置文件，创建步骤查看博客：Spring Boot 读取 Nacos 的配置文件 ，配置文件位置为：命名空间&gt;&gt;分组&gt;&gt;配置文件，前面的包含后面的，不在同一个组的配置文件可以重名 读取实现读取步骤查看博客：Spring Boot 读取 Nacos 的配置文件 ，然后在bootstrap.properties中加上配置： 1spring.cloud.nacos.config.namespace=cd6541df-8530-404f-8832-413a3cefa6 完整配置如下： 12345678910#应用名称spring.application.name=nacos_config_test#Nacos的IP地址和端口号spring.cloud.nacos.config.server-addr=121.41.211.106:8848#Nacos配置文件所在命名空间idspring.cloud.nacos.config.namespace=cd6541df-8530-404f-8832-413a3c118efa6#Nacos配置文件所在组名spring.cloud.nacos.config.group=DEFAULT_GROUP#要读取的配置文件名称spring.cloud.nacos.config.name=nacos_config.properties","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"}]},{"title":"Spring Boot读取Nacos的配置文件","slug":"474","date":"2022-03-19T03:01:39.000Z","updated":"2022-04-14T02:22:35.845Z","comments":true,"path":"474.html","link":"","permalink":"https://blog.zoutl.cn/474.html","excerpt":"","text":"毕业版本依赖关系链接：版本说明 · alibaba/spring-cloud-alibaba Wiki (github.com) 下表为按时间顺序发布的 Spring Cloud Alibaba 以及对应的适配 Spring Cloud 和 Spring Boot 版本关系（由于 Spring Cloud 版本命名有调整，所以对应的 Spring Cloud Alibaba 版本号也做了对应变化） Spring Cloud Alibaba Version Spring Cloud Version Spring Boot Version 2021.0.1.0 Spring Cloud 2021.0.1 2.6.3 2.2.7.RELEASE Spring Cloud Hoxton.SR12 2.3.12.RELEASE 2021.1 Spring Cloud 2020.0.1 2.4.2 2.2.6.RELEASE Spring Cloud Hoxton.SR9 2.3.2.RELEASE 2.1.4.RELEASE Spring Cloud Greenwich.SR6 2.1.13.RELEASE 2.2.1.RELEASE Spring Cloud Hoxton.SR3 2.2.5.RELEASE 2.2.0.RELEASE Spring Cloud Hoxton.RELEASE 2.2.X.RELEASE 2.1.2.RELEASE Spring Cloud Greenwich 2.1.X.RELEASE 2.0.4.RELEASE(停止维护，建议升级) Spring Cloud Finchley 2.0.X.RELEASE 1.5.1.RELEASE(停止维护，建议升级) Spring Cloud Edgware 1.5.X.RELEASE 实现过程创建父项目创建一个Maven项目，用于管理依赖，pom.xml文件内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;NacosDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;nacos_config_test&lt;/module&gt; &lt;/modules&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring-cloud.version&gt;Hoxton.SR9&lt;/spring-cloud.version&gt; &lt;springboot.version&gt;2.3.2.RELEASE&lt;/springboot.version&gt; &lt;springcloudalibaba.version&gt;2.2.6.RELEASE&lt;/springcloudalibaba.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springcloudalibaba.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建子项目在父项目下创建子项目，用于测试读取Nacos的配置文件 pom.xml1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;NacosDemo&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;nacos_config_test&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 配置中心 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 创建配置文件在resources下创建，bootstrap比application的优先级高 application.yml 1234server: port: 8080 servlet: context-path: / bootstrap.properties 12345678#应用名称spring.application.name=nacos_config_test#Nacos的IP地址和端口号spring.cloud.nacos.config.server-addr=121.41.111.106:8848#Nacos配置文件所在组名spring.cloud.nacos.config.group=DEFAULT_GROUP#要读取的配置文件名称spring.cloud.nacos.config.name=nacos_config.properties 新建Controller类新建一个controller包，并在里面新建一个Controller类，@RefreshScope注解的作用为：当Nacos的配置文件内容改变后，也能读取修改后的配置，如果不使用这个注解则只能读取修改前的配置 1234567891011121314151617181920212223242526272829package com.ledao.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author LeDao * @company * @create 2022-03-19 10:45 */@RefreshScope@RestController@RequestMapping(&quot;/nacos&quot;)public class NacosConfigController &#123; @Value(&quot;$&#123;ledao.name&#125;&quot;) private String name; @Value(&quot;$&#123;ledao.age&#125;&quot;) private String age; @GetMapping(&quot;/getUserInfo&quot;) public String getUserInfo()&#123; return name + &quot; : &quot; + age; &#125;&#125; 新建启动类在上面新建的controller包外新建一个启动类，内容如下： 1234567891011121314151617package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author LeDao * @company * @create 2022-03-19 10:38 */@SpringBootApplicationpublic class NacosConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(NacosConfigApplication.class, args); &#125;&#125; Nacos新建配置文件 先选择配置管理下的配置列表，再点击添加按钮 填写配置文件的配置内容，最后点击发布即可 我新建的配置文件如下图 测试运行启动类，在浏览器地址栏输入：localhost:8080/nacos/getUserInfo，结果截图如下：","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"}]},{"title":"谷歌搜索屏蔽某个网站","slug":"473","date":"2022-03-18T08:31:27.000Z","updated":"2022-03-26T10:27:06.597Z","comments":true,"path":"473.html","link":"","permalink":"https://blog.zoutl.cn/473.html","excerpt":"","text":"前提无法使用谷歌搜索的就不要查看本博客了 下载插件谷歌插件商店地址：uBlacklist - Chrome 网上应用店 (google.com) 使用在谷歌搜索某个关键词后，对应的搜索结果上面会有加入黑名单这个选项，点击该选项即可屏蔽对应网站","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"Windows系统和CentOS7安装Nacos","slug":"472","date":"2022-03-17T13:00:17.000Z","updated":"2022-04-14T02:22:31.763Z","comments":true,"path":"472.html","link":"","permalink":"https://blog.zoutl.cn/472.html","excerpt":"","text":"下载下载地址：Release 1.4.3 (Jan 27, 2022) · alibaba/nacos (github.com)，下载后解压即可 Windows系统安装运行cmd命令进入解压后的文件夹内的bin文件夹，输入以下命令运行Nacos，standalone代表单机模式运行 1startup.cmd -m standalone 在浏览器输入http://localhost:8848/nacos，然后进行登录，用户名和密码都是`nacos`，登录成功进入下面界面 连接MySQL数据库先关闭正在运行的Nacos程序，直接关闭cmd窗口即可 Nacos默认使用的数据是本地的，也可以配置成使用MySQL的数据 导入数据库文件Nacos的数据库文件在conf文件夹中，新建一个数据库然后导入Nacos的数据库文件 修改配置文件配置文件是上图的application.properties，把下图的黑色的代码的注释删除，然后把一些参数改为自己的 测试修改密码以测试是否成功连接数据库，如果直接在Nacos程序的界面修改密码会报错：caused: user nacos,nacos not exist!;，错误详情查看：caused: user nacos,nacos not exist!; · Issue #7750 · alibaba/nacos (github.com) 最后登录时使用新密码验证，登录成功说明连接数据库成功 在CentOS7中安装将上面解压的文件夹上传到CentOS7系统中，步骤和上面基本相同，只是运行的命令不同，运行的命令如下： 1sh startup.sh -m standalone 停止运行的命令如下： 1sh shutdown.sh","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"}]},{"title":"微信开发者工具创建小程序","slug":"471","date":"2022-03-16T14:54:17.000Z","updated":"2022-04-14T02:48:43.321Z","comments":true,"path":"471.html","link":"","permalink":"https://blog.zoutl.cn/471.html","excerpt":"","text":"注册注册地址为：https://mp.weixin.qq.com/wxopen/waregister?action=step1 登录登录地址为：https://mp.weixin.qq.com/ 获取AppID登录成功后会进入小程序后台，然后点击左侧菜单的开发管理，根据下图步骤即可获取到AppID 下载和安装开发工具下载地址为：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 创建小程序打开微信开发者工具后，新建项目，小程序项目选择小程序，其他选项参照下图，最后点击确定即可 项目结构创建好的项目结构如下图 各文件夹以及文件的作用pages存放小程序的页面文件，书写各个页面代码以及组件，pages下的每个文件夹都是一个页面，例如index文件夹就是一个名为index的页面，index文件夹下的文件都要命名为index，和页面文件夹一致，页面文件夹下的各文件的作用如下： 文件名 作用 index.js 页面逻辑文件，相当于JavaScript index.json 页面配置文件，优先级比app.json高 index.wxml 页面布局文件，相当于HTML index.wxss 页面样式文件，相当于CSS utils存放全局的一些.js文件，公共用到的一些事件处理代码文件可以放到该文件夹下，用于全局调用 .eslintrc.js这是ESlint代码风格规范的配置文件，使得不同的开发者写出风格统一的代码 app.js小程序入口文件，用于定义全局数据和函数的使用，可以指定微信小程序的生命周期函数 app.json对小程序进行配置，小程序的全局配置，小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等; 我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口及背景色，配置导航条样式，配置默认标题 app.wxss全局的样式文件 project.config.json保存开发工具配置项 sitemap.json 网站地图，可以对小程序进行seo优化，让搜索排名靠前 PS.参考文章：微信小程序项目和目录结构以及各个文件夹和文件的作用_cjy_lean的博客-CSDN博客","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.zoutl.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"MyBatis插入数据时获取自增的id","slug":"470","date":"2022-03-16T04:05:20.000Z","updated":"2022-04-14T01:43:14.502Z","comments":true,"path":"470.html","link":"","permalink":"https://blog.zoutl.cn/470.html","excerpt":"","text":"概述当表的id被设计为自增时，插入数据后想获得新插入数据的id 我曾经试过直接获取最新一条数据的id，虽然可以获取到id，但是这种方式不但麻烦而且也不推荐，因为插入数据成功到获取到id的这段时间内如果又新增了一条数据，那么获取到的就不是我们希望得到的id了 Mybatis支持在插入数据后，返回这条数据的id，这种方式简单又不存在上面出现的问题，推荐使用 实现XML代码 添加数据的XML代码 1234&lt;insert id=&quot;add&quot; parameterType=&quot;User&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot; keyColumn=&quot;id&quot;&gt; insert into t_user (isBorrow, password, state, type, userName, nickName) values (1, #&#123;password&#125;, 1, 2, #&#123;userName&#125;, #&#123;userName&#125;);&lt;/insert&gt; 属性说明 parameterType 传入的参数类型 useGeneratedKeys 是否返回插入数据的id keyProperty 实体类对应的字段 keyColumn 数据库中表对应的字段 Java代码123456789@Testpublic void addUser()&#123; User user = new User(); user.setUserName(&quot;tom&quot;); user.setNickName(&quot;LeDao&quot;); user.setPassword(&quot;123456&quot;); userService.add(user); System.out.println(&quot;自增的id为: &quot;+user.getId());&#125; 结果","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"项目启动时报错：ERROR org.springframework.boot.SpringApplication - Application run failed","slug":"469","date":"2022-03-16T01:33:58.412Z","updated":"2022-04-14T02:45:23.886Z","comments":true,"path":"469.html","link":"","permalink":"https://blog.zoutl.cn/469.html","excerpt":"","text":"问题分析我的报错截图如下，报错下方可以看到：org.yaml.snakeyaml.error.YAMLException，这说明是yml配置文件错误。出现该错误的原因是：yml配置文件使用了中文，且项目使用了GBK编码 解决办法修改项目的编码为UTF-8","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IDM无法捕获以及下载APK文件","slug":"468","date":"2022-03-14T05:02:47.000Z","updated":"2022-04-10T17:30:36.456Z","comments":true,"path":"468.html","link":"","permalink":"https://blog.zoutl.cn/468.html","excerpt":"","text":"概述当我们点击网页上某个APK文件下载链接时，无法通过IDM下载，而是直接通过浏览器下载了，这是因为IDM默认不捕获APK下载链接 解决办法配置捕获APK文件 设置保存路径上面已经实现了通过IDM下载APK文件，接下来设置将下载好的APK文件保存到指定路径","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"IDM","slug":"IDM","permalink":"https://blog.zoutl.cn/tags/IDM/"}]},{"title":"HashMap键排序和值排序","slug":"467","date":"2022-03-12T02:07:29.000Z","updated":"2022-04-14T02:22:16.258Z","comments":true,"path":"467.html","link":"","permalink":"https://blog.zoutl.cn/467.html","excerpt":"","text":"概述关于HashMap键排序，如果是升序排序可以直接使用TreeMap，降序排序则需要自己实现 关于HashMap值排序，无论是升序还是降序，都需要自己实现，和键降序排序实现方式大同小异 下面只实现键降序排序和值排序，不实现键升序排序，因为键的升序排序直接用TreeMap就可以了 代码实现键降序排序 实现原理 将HashMap中的EntrySet取出放入一个ArrayList中，来对ArrayList中的EntrySet进行排序，从而实现对HashMap的值进行排序的效果 代码实现 1234567891011121314151617181920212223242526272829import java.util.*;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; Map&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(&#x27;e&#x27;, 2); hashMap.put(&#x27;d&#x27;, 1); hashMap.put(&#x27;v&#x27;, 6); hashMap.put(&#x27;b&#x27;, 3); hashMap.put(&#x27;a&#x27;, 3); List&lt;Map.Entry&lt;Character, Integer&gt;&gt; list = new ArrayList&lt;&gt;(hashMap.entrySet()); Collections.sort(list, new Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;() &#123; @Override public int compare(Map.Entry&lt;Character, Integer&gt; o1, Map.Entry&lt;Character, Integer&gt; o2) &#123; //o1在后面降序,反之升序 return o2.getKey() - o1.getKey(); &#125; &#125;); for (Map.Entry&lt;Character, Integer&gt; entry : list) &#123; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()); &#125; &#125;&#125; 值排序 实现原理 同上，区别如下图： 代码实现 1234567891011121314151617181920212223242526272829import java.util.*;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; Map&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;(16); hashMap.put(&#x27;e&#x27;, 2); hashMap.put(&#x27;d&#x27;, 1); hashMap.put(&#x27;v&#x27;, 6); hashMap.put(&#x27;b&#x27;, 3); hashMap.put(&#x27;a&#x27;, 9); List&lt;Map.Entry&lt;Character, Integer&gt;&gt; list = new ArrayList&lt;&gt;(hashMap.entrySet()); Collections.sort(list, new Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;() &#123; @Override public int compare(Map.Entry&lt;Character, Integer&gt; o1, Map.Entry&lt;Character, Integer&gt; o2) &#123; //o1在后面降序,反之升序 return o2.getValue() - o1.getValue(); &#125; &#125;); for (Map.Entry&lt;Character, Integer&gt; entry : list) &#123; System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()); &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java根据字符获取ASCII码值","slug":"466","date":"2022-03-10T01:16:41.000Z","updated":"2022-04-14T02:22:11.317Z","comments":true,"path":"466.html","link":"","permalink":"https://blog.zoutl.cn/466.html","excerpt":"","text":"概述根据一个字符获取它在ASCII表中对应的值，办法有两种： 将字符强转为int类型 使用Integer.valueOf()方法 实现将字符强转为int类型123456789101112/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; char c = &#x27;a&#x27;; System.out.println((int) c); &#125;&#125; 使用Integer.valueOf()方法123456789101112/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; char c = &#x27;a&#x27;; System.out.println(Integer.valueOf(c)); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Spring Boot自定义启动Banner","slug":"465","date":"2022-03-09T13:39:08.000Z","updated":"2022-04-14T02:22:09.281Z","comments":true,"path":"465.html","link":"","permalink":"https://blog.zoutl.cn/465.html","excerpt":"","text":"概述Spring Boot的启动Banner就是项目启动时控制台打印的图案，这个图案是支持自定义修改的 实现过程生成Banner生成Banner的网站链接为：https://www.bootschool.net/ascii，该网站支持根据输入的文本生成Banner以及生成二维码Banner，还有一些别人设计好的Banner 自定义Spring Boot的Banner将banner.txt放在resources文件夹中 结果截图如果不生效就使用Maven工具栏Lifecycle的clean命令清除一下缓存 PS.要禁用Banner，就在配置文件添加以下代码： 123spring: main: banner-mode: off","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"}]},{"title":"Git修改commit注释","slug":"464","date":"2022-03-07T15:23:25.000Z","updated":"2022-04-14T02:22:06.260Z","comments":true,"path":"464.html","link":"","permalink":"https://blog.zoutl.cn/464.html","excerpt":"","text":"概述有时候git commit的注释填写错误，需要进行修改，修改的情况有两种： 最近一次 最近某次 实现过程最近一次 查看最近一次的注释 1git log spring: main: banner-mode: offyaml 1git commit --amend pull和push到GitHub，pull代码时输入:wq退出即可 1234#pullgit pull origin master#pushgit push -u origin master 最近某次查看博客：Git修改已提交的commit注释 - SegmentFault 思否 和 Git 修改已提交的commit注释 - 简书 (jianshu.com)","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"Element UI实现表单验证","slug":"463","date":"2022-03-07T03:02:16.000Z","updated":"2022-04-14T01:57:44.468Z","comments":true,"path":"463.html","link":"","permalink":"https://blog.zoutl.cn/463.html","excerpt":"","text":"概述所谓表单验证，就是检验用户的输入是否正确： 是否未输入 格式是否正确 还可以请求后端，和数据库的信息进行校验，例如：注册时，检验用户名是否已经存在于数据库中 Element UI表单默认使用async-validator做验证，Element UI已经内置了async-validator，直接使用即可，表单验证分为两种情况： Element UI的规则，直接使用，进行一些配置即可 自定义规则，需要自己编写验证规则，更加灵活，可以通过Ajax请求后端 表单校验属性type验证用户输入的数据类型 类型 说明 string 校验类型为Sting，type的默认值为string number 校验类型为number boolean 类型必须为boolean interger 类型必须为number且为整数 float 类型必须为number且为浮点数 array 类型必须为数组 enum 值的类型必须存在于enum中 url 类型格式必须为url格式 email 格式类型必须为email格式 method 格式类型必须为function regexp 必须是RegExp创建新时不会长生异常的实例或字符串RegExp object 格式类型必须为object data 格式类型必须为data hex 格式类型必须为hex any 格式类型可以为任何类型 required值为true或false，该字段是否为必填 pattern该属性只是一个正则表达式的值必须匹配，才可以通过验证 min规定最小长度 max规定最大长度 len指定确切长度，如果该len属性与min和max范围属性结合使用，则len优先 whitespace值为true或false，验证是否只有空格 message校验不通过提示 asyncValidator可以为指定的字段自定义异步校验功能 validator可以为只能字段自定义校验功能 trigger值为blur或change 值 说明 blur 失去焦点时触发，常用于输入框 change 手动改变时触发，常用于下拉框 实现过程Element UI的规则首先在el-form标签添加ref属性（和:model绑定的form的名称一样），添加:rules=&quot;rules&quot; 123&lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt; &lt;/el-form&gt; 在el-form-item标签添加prop属性（值为要验证的字段） 123&lt;el-form-item label=&quot;用户名&quot; prop=&quot;userName&quot;&gt; &lt;el-input v-model=&quot;form.userName&quot;&gt;&lt;/el-input&gt;&lt;/el-form-item&gt; 在JavaScript代码区的return &#123;&#125;内添加验证规则 12345rules: &#123; userName: [ &#123;required: true, message: &quot;请输入用户名&quot;, trigger: &quot;blur&quot;&#125; ]&#125; 在form提交的JavaScript代码内使用表单验证，$refs[&quot;form&quot;]的form为:model对应的值 12345678this.$refs[&quot;form&quot;].validate((valid, msg) =&gt; &#123; if (valid) &#123;//全部验证都通过时 ElementUI.Message.success(&quot;填写的信息全部正确！！&quot;); &#125; else &#123; ElementUI.Message.error(&quot;你填写的信息不正确！！&quot;); return false; &#125;&#125;); 完整代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div style=&quot;width: 40%;margin-left: 30%;margin-top: 6%&quot;&gt; &lt;p style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;../assets/images/logo.png&quot; height=&quot;55&quot;/&gt;&lt;/p&gt; &lt;h3 style=&quot;text-align: center&quot;&gt;学生注册&lt;/h3&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;userName&quot;&gt; &lt;el-input v-model=&quot;form.userName&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;password2&quot;&gt; &lt;el-input v-model=&quot;form.password2&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item style=&quot;text-align: center&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit()&quot;&gt;注册&lt;/el-button&gt; &lt;router-link type=&quot;primary&quot; to=&quot;/login&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;登录&lt;/el-button&gt; &lt;/router-link&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElementUI from &#x27;element-ui&#x27;;import axios from &quot;axios&quot;;export default &#123; name: &quot;register&quot;, data() &#123; return &#123; form: &#123; userName: &#x27;&#x27;, password: &#x27;&#x27;, password2: &#x27;&#x27; &#125;, rules: &#123; userName: [ &#123;required: true, message: &quot;请输入用户名&quot;, trigger: &quot;blur&quot;&#125; ] &#125; &#125; &#125;, methods: &#123; onSubmit() &#123; this.$refs[&quot;form&quot;].validate((valid, msg) =&gt; &#123; if (valid) &#123; ElementUI.Message.success(&quot;填写的信息全部正确！！&quot;); &#125; else &#123; ElementUI.Message.error(&quot;你填写的信息不正确！！&quot;); return false; &#125; &#125;); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 自定义规则在JavaScript代码区内data() &#123;&#125;编写自己的验证规则 12345678//检验密码和确认密码是否一样let checkPassword2 = (rule, value, callback) =&gt; &#123; if (value !== this.form.password) &#123; callback(new Error(&#x27;密码和确认密码不一致!&#x27;)); &#125; else &#123; callback(); &#125;&#125;; 在rules: &#123;&#125;内的要验证的字段中引用 1234password2: [ &#123;required: true, message: &quot;请输入确认密码&quot;, trigger: &quot;blur&quot;&#125;, &#123;validator: checkPassword2, trigger: &#x27;blur&#x27;&#125;] 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div style=&quot;width: 40%;margin-left: 30%;margin-top: 6%&quot;&gt; &lt;p style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;../assets/images/logo.png&quot; height=&quot;55&quot;/&gt;&lt;/p&gt; &lt;h3 style=&quot;text-align: center&quot;&gt;学生注册&lt;/h3&gt; &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot; label-width=&quot;80px&quot;&gt; &lt;el-form-item label=&quot;用户名&quot; prop=&quot;userName&quot;&gt; &lt;el-input v-model=&quot;form.userName&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;密码&quot; prop=&quot;password&quot;&gt; &lt;el-input v-model=&quot;form.password&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;确认密码&quot; prop=&quot;password2&quot;&gt; &lt;el-input v-model=&quot;form.password2&quot; type=&quot;password&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item style=&quot;text-align: center&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit()&quot;&gt;注册&lt;/el-button&gt; &lt;router-link type=&quot;primary&quot; to=&quot;/login&quot;&gt; &lt;el-button type=&quot;primary&quot;&gt;登录&lt;/el-button&gt; &lt;/router-link&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElementUI from &#x27;element-ui&#x27;;import axios from &quot;axios&quot;;export default &#123; name: &quot;register&quot;, data() &#123; //检验用户名是否已经存在于数据库中 let checkUserName = (rule, value, callback) =&gt; &#123; let param = new URLSearchParams(); param.append(&quot;userName&quot;, value); axios .post(&#x27;http://localhost/user/findByUserName&#x27;, param) .then(function (response) &#123; if (response.data.success) &#123; callback(); &#125; else &#123; callback(new Error(&#x27;用户名已经存在,请重新输入!&#x27;)); &#125; &#125;) .catch(function (error) &#123; alert(error); console.log(error); &#125;); &#125;; //检验密码和确认密码是否一样 let checkPassword2 = (rule, value, callback) =&gt; &#123; if (value !== this.form.password) &#123; callback(new Error(&#x27;密码和确认密码不一致!&#x27;)); &#125; else &#123; callback(); &#125; &#125;; return &#123; form: &#123; userName: &#x27;&#x27;, password: &#x27;&#x27;, password2: &#x27;&#x27; &#125;, rules: &#123; userName: [ &#123;required: true, message: &quot;请输入用户名&quot;, trigger: &quot;blur&quot;&#125;, &#123;validator: checkUserName, trigger: &#x27;blur&#x27;&#125; ], password: [ &#123;required: true, message: &quot;请输入密码&quot;, trigger: &quot;blur&quot;&#125; ], password2: [ &#123;required: true, message: &quot;请输入确认密码&quot;, trigger: &quot;blur&quot;&#125;, &#123;validator: checkPassword2, trigger: &#x27;blur&#x27;&#125; ] &#125; &#125; &#125;, methods: &#123; onSubmit() &#123; this.$refs[&quot;form&quot;].validate((valid, msg) =&gt; &#123; if (valid) &#123; ElementUI.Message.success(&quot;填写的信息全部正确！！&quot;); &#125; else &#123; ElementUI.Message.error(&quot;你填写的信息不正确！！&quot;); return false; &#125; &#125;); &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://blog.zoutl.cn/tags/Element-UI/"}]},{"title":"解决：Spring MVC接收前端数据出现中文乱码","slug":"462","date":"2022-03-04T03:53:01.000Z","updated":"2022-04-14T02:22:02.501Z","comments":true,"path":"462.html","link":"","permalink":"https://blog.zoutl.cn/462.html","excerpt":"","text":"概述从前端传过来的数据如果包含中文，中文会变成乱码 解决办法在web.xml中添加以下代码： 12345678910111213&lt;!--配置Spring MVC的乱码过滤--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Maven资源过滤设置","slug":"461","date":"2022-03-04T02:32:43.000Z","updated":"2022-04-14T02:21:59.983Z","comments":true,"path":"461.html","link":"","permalink":"https://blog.zoutl.cn/461.html","excerpt":"","text":"在pom.xml文件的project标签中加入下面代码： 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"}]},{"title":"Spring Boot普通类使用@Resource或@Autowired注解","slug":"460","date":"2022-03-02T21:28:14.000Z","updated":"2022-04-14T02:21:57.170Z","comments":true,"path":"460.html","link":"","permalink":"https://blog.zoutl.cn/460.html","excerpt":"","text":"概述有时候我们需要编写工具类，而这个工具类是普通类，需要使用到@Resource或@Autowired注解，但是普通类是无法使用这两个注解的，使用这两个注解需要进行一些处理 解决办法给普通类加上@Component注解，然后使用@PostConstruct注解标记工具类初始化bean 示例代码在下面这个RedisUtil类中，通过redisUtil.configProperties.进行调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.ledao.util;import com.ledao.entity.ConfigProperties;import org.springframework.stereotype.Component;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import javax.annotation.PostConstruct;import javax.annotation.Resource;/** * Redis工具类 * * @author LeDao * @company * @create 2022-01-17 1:21 */@Componentpublic class RedisUtil &#123; /** * 维护一个本类的静态变量 */ private static RedisUtil redisUtil; @Resource private ConfigProperties configProperties; /** * 使用@PostConstruct注解标记工具类,初始化Bean */ @PostConstruct public void init() &#123; redisUtil = this; redisUtil.configProperties = this.configProperties; &#125; /** * 获取Redis连接 * * @return */ private static JedisPool getRedisLink() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(100); jedisPoolConfig.setMaxIdle(10); return new JedisPool(jedisPoolConfig, redisUtil.configProperties.getHost(), redisUtil.configProperties.getPort()); &#125; /** * 关闭Redis连接 * * @param jedisPool * @param jedis */ private static void closeRedis(JedisPool jedisPool, Jedis jedis) &#123; jedis.close(); jedisPool.close(); &#125; /** * 获取Jedis * * @param jedisPool * @return */ private static Jedis getJedis(JedisPool jedisPool) &#123; Jedis jedis = jedisPool.getResource(); jedis.auth(redisUtil.configProperties.getPassword()); return jedis; &#125; /** * 设置key * * @param key * @param value * @return */ public static boolean setKey(String key, String value) &#123; JedisPool jedisPool = getRedisLink(); Jedis jedis = getJedis(jedisPool); String result = jedis.set(key, value); closeRedis(jedisPool, jedis); return &quot;OK&quot;.equals(result); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"}]},{"title":"Spring Boot监听Redis过期的key","slug":"459","date":"2022-03-01T18:41:51.000Z","updated":"2022-04-14T02:21:54.119Z","comments":true,"path":"459.html","link":"","permalink":"https://blog.zoutl.cn/459.html","excerpt":"","text":"引入依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; application.yml配置Redis123456spring: redis: database: 0 host: 121.41.222.106 password: 667866 port: 6379 Redis监听配置类1234567891011121314151617181920212223242526272829303132333435package com.ledao.config;import com.ledao.listener.KeyExpiredListener;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.listener.RedisMessageListenerContainer;import javax.annotation.Resource;/** * Redis监听过期的key * * @author LeDao * @company * @create 2022-03-02 2:04 */@Configurationpublic class RedisConfig &#123; @Resource private RedisConnectionFactory redisConnectionFactory; @Bean public RedisMessageListenerContainer redisMessageListenerContainer() &#123; RedisMessageListenerContainer redisMessageListenerContainer = new RedisMessageListenerContainer(); redisMessageListenerContainer.setConnectionFactory(redisConnectionFactory); return redisMessageListenerContainer; &#125; @Bean public KeyExpiredListener keyExpiredListener() &#123; return new KeyExpiredListener(this.redisMessageListenerContainer()); &#125;&#125; 过期key监听类1234567891011121314151617181920212223242526package com.ledao.listener;import org.springframework.data.redis.connection.Message;import org.springframework.data.redis.listener.KeyExpirationEventMessageListener;import org.springframework.data.redis.listener.RedisMessageListenerContainer;import java.util.Date;/** * 过期key监听类 * * @author LeDao * @company * @create 2022-03-02 2:09 */public class KeyExpiredListener extends KeyExpirationEventMessageListener &#123; public KeyExpiredListener(RedisMessageListenerContainer listenerContainer) &#123; super(listenerContainer); &#125; @Override public void onMessage(Message message, byte[] pattern) &#123; System.out.println(new Date() + &quot;: 过期的key为&quot; + message.toString()); &#125;&#125; Jedis工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.ledao.util;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import java.util.List;/** * Redis工具类 * * @author LeDao * @company * @create 2022-01-17 1:21 */public class RedisUtil &#123; private static final String HOST = &quot;121.41.222.106&quot;; private static final Integer PORT = 6379; private static final String AUTH_PASSWORD = &quot;667866&quot;; /** * 获取Redis连接 * * @return */ private static JedisPool getRedisLink() &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(100); jedisPoolConfig.setMaxIdle(10); return new JedisPool(jedisPoolConfig, HOST, PORT); &#125; /** * 关闭Redis连接 * * @param jedisPool * @param jedis */ private static void closeRedis(JedisPool jedisPool, Jedis jedis) &#123; jedis.close(); jedisPool.close(); &#125; /** * 获取Jedis * * @param jedisPool * @return */ private static Jedis getJedis(JedisPool jedisPool) &#123; Jedis jedis = jedisPool.getResource(); jedis.auth(AUTH_PASSWORD); return jedis; &#125; /** * 设置key * * @param key * @param value * @return */ public static boolean setKey(String key, String value) &#123; JedisPool jedisPool = getRedisLink(); Jedis jedis = getJedis(jedisPool); String result = jedis.set(key, value); closeRedis(jedisPool, jedis); return &quot;OK&quot;.equals(result); &#125; /** * 给指定key设置过期时间(秒) * * @param key * @param seconds */ public static void setKeyTime(String key, int seconds) &#123; JedisPool jedisPool = getRedisLink(); Jedis jedis = getJedis(jedisPool); jedis.expire(key, seconds); closeRedis(jedisPool,jedis); &#125;&#125; 请求的方法12345678@ResponseBody@RequestMapping(&quot;/setRedisKey&quot;)public String setRedisKey()&#123; RedisUtil.setKey(&quot;a&quot;, &quot;1&quot;); RedisUtil.setKeyTime(&quot;a&quot;, 10); System.out.println(new Date()+&quot;: &quot;+&quot;设置了key,过期时间为&quot;+10+&quot;秒&quot;); return &quot;设置成功&quot;;&#125; 测试浏览器通过请求http://localhost/setRedisKey链接创建一个名为a的key，并给它设置10秒的过期时间","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis给key设置过期时间","slug":"458","date":"2022-03-01T18:22:08.000Z","updated":"2022-04-14T02:21:50.611Z","comments":true,"path":"458.html","link":"","permalink":"https://blog.zoutl.cn/458.html","excerpt":"","text":"expire 说明 给key设置过期时间，时间单位：秒 语法 expire key time 示例 expire a 10，给名为a的key设置10秒的过期时间 pexpire 说明 给key设置过期时间，时间单位：毫秒 语法 pexpire key time 示例 pexpire a 2000，给名为a的key设置2000毫秒的过期时间（2秒钟） ttl 说明 获取key的剩余过期时间：（单位为秒） 如果key存在过期时间，返回剩余生存时间 如果key是永久的，返回-1 如果key不存在或者已过期，返回-2 语法 ttl key 示例 ttl a，获取名为a的key的剩余过期时间 pttl 说明 获取key的剩余过期时间：（单位为毫秒） 如果key存在过期时间，返回剩余生存时间 如果key是永久的，返回-1 如果key不存在或者已过期，返回-2 语法 pttl key 示例 pttl a，获取名为a的key的剩余过期时间 persist 说明 移除key的过期时间，将其转换为永久状态。如果返回1，代表转换成功。如果返回0，代表key不存在或者之前就已经是永久状态。 语法 persist key 示例 persist a，移除名为a的key的剩余过期时间，将其转换为永久状态","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Spring使用@Transactional注解实现事务","slug":"457","date":"2022-02-28T12:26:02.000Z","updated":"2022-04-14T02:21:47.185Z","comments":true,"path":"457.html","link":"","permalink":"https://blog.zoutl.cn/457.html","excerpt":"","text":"注解概述是声明式事务管理编程中使用的注解 属性 属性 类型 描述 value String 可选的限定描述符，指定使用的事务管理器 propagation enum: Propagation 可选的事务传播行为设置 isolation enum: Isolation 可选的事务隔离级别设置 readOnly boolean 读写或只读事务，默认读写 timeout int (in seconds granularity) 事务超时时间设置 rollbackFor Class对象数组，必须继承自Throwable 导致事务回滚的异常类数组 rollbackForClassName 类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组 noRollbackFor Class对象数组，必须继承自Throwable 不会导致事务回滚的异常类数组 noRollbackForClassName 类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组 用法一般在要配置事务的public方法上使用，不要在接口或者接口方法上使用该注解（这是Spring的建议） 实现过程引入依赖123456789101112&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt;&lt;/dependency&gt; 配置Spring的事务处理在Spring的配置文件声明事务管理器和配置基于注解的声明式事务 12345678&lt;!--声明事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--配置基于注解的声明式事务 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 配置事务的方法下面方法的作用：添加学生信息，然后查找一个id为1000的学生，如果这个学生存在，添加学生就成功 出现事务回滚的情况：如果出现NullPointerException就会发生事务回滚，如果出现RuntimeException也会回滚 1234567891011121314@ResponseBody@Transactional(rollbackFor = &#123;NullPointerException.class&#125;)@RequestMapping(value = &quot;/test&quot;, produces = &#123;&quot;text/plain;charset=utf-8&quot;, &quot;text/html;charset=utf-8&quot;&#125;)public String test() &#123; Student student = new Student(); student.setName(&quot;小明&quot;); student.setAge(10); //添加学生信息到数据库 studentService.add(student); //在数据库中查找id为1000的学生,如果这个学生存在,上面的添加操作就成功 Student student1 = studentService.findById(1000); System.out.println(student1.getId()); return &quot;测试&quot;;&#125; 测试 序号 测试条件 结果 1 数据库中不存在id为1000的学生 报错，且添加学生不成功 2 数据库中存在id为1000的学生 添加学生成功","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring MVC使用@ResponseBody注解时返回中文出现乱码的解决办法","slug":"456","date":"2022-02-28T01:15:10.000Z","updated":"2022-04-14T02:21:45.258Z","comments":true,"path":"456.html","link":"","permalink":"https://blog.zoutl.cn/456.html","excerpt":"","text":"指定响应的字符集为utf-8，将@RequestMapping注解的produces属性的值设置为&#123;&quot;text/plain;charset=utf-8&quot;, &quot;text/html;charset=utf-8&quot;&#125; 123456789@ResponseBody@RequestMapping(value = &quot;/test&quot;, produces = &#123;&quot;text/plain;charset=utf-8&quot;, &quot;text/html;charset=utf-8&quot;&#125;)public String test() &#123; Student student = new Student(); student.setName(&quot;11&quot;); student.setAge(10); studentService.add(student); return &quot;添加成功&quot;;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"npm报错：A complete log of this run can be fund in的解决办法","slug":"455","date":"2022-02-26T13:06:33.000Z","updated":"2022-04-10T17:50:39.264Z","comments":true,"path":"455.html","link":"","permalink":"https://blog.zoutl.cn/455.html","excerpt":"","text":"WebStorm使用快捷键ALT+F12打开Terminal窗口，然后分别执行下面两条命令： 1234 #清理缓存 npm cache clean --force #安装依赖 npm install 也可以使用CMD命令或Git命令进入项目根目录后执行上面命令","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://blog.zoutl.cn/tags/Node-js/"}]},{"title":"IntelliJ IDEA报错：Failed to load property source from location classpath:/application.yml的解决办法","slug":"454","date":"2022-02-26T13:04:54.000Z","updated":"2022-04-14T02:44:46.536Z","comments":true,"path":"454.html","link":"","permalink":"https://blog.zoutl.cn/454.html","excerpt":"","text":"打开设置，找到下图的设置并将画红线的3处都改为UTF-8 打开Maven工具栏clean一下","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"前后端分离项目在本地IDE部署步骤","slug":"453","date":"2022-02-26T12:41:08.000Z","updated":"2022-04-14T02:21:41.122Z","comments":true,"path":"453.html","link":"","permalink":"https://blog.zoutl.cn/453.html","excerpt":"","text":"使用到的项目和IDE项目使用到的两个项目的GitHub链接为： 前端代码地址：https://github.com/a6678696/ExamSystem2 后端代码地址：https://github.com/a6678696/ExamSystem IDE我使用的是IntelliJ IDEA和WebStorm，本博客也是以这两个IDE为例部署项目 给GitHub配置SSH Key具体步骤查看博客：https://blog.zoutl.cn/236.html clone项目到本地进入指定的文件夹，使用下面命令将项目clone到本地 clone前端项目1git clone git@github.com:a6678696/ExamSystem2.git clone后端项目1git clone git@github.com:a6678696/ExamSystem.git 部署前端项目安装Node.js具体步骤查看博客：https://blog.zoutl.cn/200.html 打开Terminal窗口执行命令使用WebStorm打开项目ExamSystem2后，使用快捷键ALT+F12打开Terminal窗口，然后分别执行下面两条命令： 12npm cache clean --forcenpm install 启动项目一定要等到上面两个命令执行完再启动哦，打开package.json文件，点击第9行左边的启动按钮，选择第一个选项启动即可 启动成功界面启动成功后会自动打开浏览器并可以看到下面界面，到此前端部署成功了，如果没有自动打开浏览器就再浏览器地址栏手动输入：http://localhost:8888/ 如果需要再次启动，可以通过点击下图的按钮来启动了 部署后端项目配置JDK使用IntelliJ IDEA打开项目ExamSystem后，打开项目配置，也可以使用下图显示的快捷键 选择本地安装的JDK，我本地的是JKD1.8，项目开发时使用的也是JKD1.8 启动项目打开ExamSystemApplication.java这个类，运行main方法 然后会报错：Failed to load property source from location &#39;classpath:/application.yml&#39; 报错的解决办法打开设置，找到下图的设置并将画红线的3处都改为UTF-8 打开Maven工具栏clean一下 再次启动直接点击顶部工具栏的启动按钮即可 测试两个项目都要启动起来，然后在登录界面选择学生身份，用户名和密码都是111，更多用户自己去查看数据库，如果登录成功进入学生界面，说明前后端分离项目的部署已经成功了！","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.zoutl.cn/tags/Node-js/"}]},{"title":"IntelliJ IDEA使用GsonFormatPlus插件根据JSON数据生成实体类","slug":"452","date":"2022-02-21T11:53:03.000Z","updated":"2022-04-14T02:44:40.187Z","comments":true,"path":"452.html","link":"","permalink":"https://blog.zoutl.cn/452.html","excerpt":"","text":"安装插件在设置中Plugins–&gt;Marketplace–&gt;搜索插件–&gt;安装 使用插件JSON数据12345&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;苹果&quot;, &quot;num&quot;: 3&#125; 打开插件页面首先打开一个实体类，使用ALT+INSERT快捷键出现下面选项，选择GsonFormatPlus，也可以直接使用ALT+S快捷键（这两个快捷键只在类中生效，不在接口中生效） 打开的插件页面如下图，在第一的输入框中输入包名以及生成的实体类名称，格式为：com.ledao.entity.Fruit，前面三个为包名，最后一个英文为实体类的名称；JSON处填JSON类型的数据 然后点击OK出现下面界面，可以对字段的数据类型、名称和注释进行修改以及添加，然后点击OK即可生成实体类 生成的实体类123456789101112131415161718192021package com.ledao.entity;import com.fasterxml.jackson.annotation.JsonProperty;import lombok.Data;import lombok.NoArgsConstructor;/** * @author LeDao * @company * @create 2022-02-21 20:17 */@NoArgsConstructor@Datapublic class Fruit &#123; @JsonProperty(&quot;id&quot;) private Integer id; @JsonProperty(&quot;name&quot;) private String name; @JsonProperty(&quot;num&quot;) private Integer num;&#125;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IntelliJ IDEA报错：There is not enough memory to perform the requested operation的解决办法","slug":"451","date":"2022-02-18T18:55:49.000Z","updated":"2022-04-14T02:44:28.146Z","comments":true,"path":"451.html","link":"","permalink":"https://blog.zoutl.cn/451.html","excerpt":"","text":"原因当前idea占用的运行内存大于默认的最大运行内存 解决办法修改允许占用最大运行内存修改idea允许占用的最大运行内存，根据下图打开idea的内存配置文件，修改Xmx（根据自己的情况设置，一般2048M就可以了） 我的idea内存配置文件内容如下：（主要修改Xmx，数值为内存的大小，单位为兆） 1234567891011121314-Xms512m-Xmx2048m-XX:ReservedCodeCacheSize=512m-XX:+UseG1GC-XX:SoftRefLRUPolicyMSPerMB=50-XX:CICompilerCount=2-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow-ea-Dsun.io.useCanonCaches=false-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;-Djdk.attach.allowAttachSelf=true-Djdk.module.illegalAccess.silent=true-Dkotlinx.coroutines.debug=off 实时查看占用的运行内存连续按两下SHIFT键，搜索Show Memory Indicator，出现下图划红线的选项后用鼠标点击一下就打开占用内存监控了 然后在idea的右下角可以看到当前占用的运行内存以及idea允许占用的最大运行内存 继续报错经过上面的改动后，只正常了一段时间，然后又报错了，那就根据下图修改 又报错改了之后，一段时间后还是报错，后来我在网上看到有可能是插件占用内存过高（特别是检查代码以及bug的插件），我卸载了下图两个插件中的QAPlug - PMD（有可能是由于两个插件重复了）以及一些不常用的插件后，idea又可以正常使用了","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IntelliJ IDEA使用Tomcat启动项目时控制台信息出现中文乱码的解决办法","slug":"450","date":"2022-02-18T15:42:26.000Z","updated":"2022-04-14T02:43:04.089Z","comments":true,"path":"450.html","link":"","permalink":"https://blog.zoutl.cn/450.html","excerpt":"","text":"Tomcat信息出现中文乱码打开设置 找到下图设置 修改设置将上图中的Default Encoding修改为UTF-8 输出语句乱码也就是System.out.println()打印的信息出现乱码，下图的第三个UTF-8后打上勾","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IntelliJ IDEA启动Tomcat时报错：Address localhost:1099 is already in use的解决办法","slug":"449","date":"2022-02-18T15:34:44.000Z","updated":"2022-04-14T02:43:09.493Z","comments":true,"path":"449.html","link":"","permalink":"https://blog.zoutl.cn/449.html","excerpt":"","text":"原因1099端口已经被其它程序占用 解决办法干掉占用该端口的程序，释放1099端口，具体步骤查看博客：Windows10 释放被占用端口 | LeDao 的博客 (zoutl.cn)","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"Spring使用注解实现AOP","slug":"448","date":"2022-02-17T14:47:49.000Z","updated":"2022-04-14T02:21:22.824Z","comments":true,"path":"448.html","link":"","permalink":"https://blog.zoutl.cn/448.html","excerpt":"","text":"使用到的注解@Aspect用于标注使用这个注解的类是一个切面 @Before执行业务代码前先执行这个方法 @After执行业务代码后再执行这个方法 @Around环绕增强方法使用 实现过程Service接口1234567891011121314151617181920212223242526272829package com.ledao.service;/** * @author LeDao * @company * @create 2022-02-17 20:29 */public interface StudentService &#123; /** * 添加学生 */ void add(); /** * 删除学生 */ void delete(); /** * 修改学生 */ void update(); /** * 根据id查找学生 */ void findById();&#125; Service接口实现类12345678910111213141516171819202122232425262728293031package com.ledao.service.impl;import com.ledao.service.StudentService;/** * @author LeDao * @company * @create 2022-02-17 20:30 */public class StudentServiceImpl implements StudentService &#123; @Override public void add() &#123; System.out.println(&quot;添加学生&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除学生&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改学生&quot;); &#125; @Override public void findById() &#123; System.out.println(&quot;根据id查找学生&quot;); &#125;&#125; AnnotationPointCut增强类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ledao.diy;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;/** * @author LeDao * @company * @create 2022-02-17 22:49 */@Aspectpublic class AnnotationPointCut &#123; /** * 执行方法前先执行 */ @Before(&quot;execution(* com.ledao.service.impl.StudentServiceImpl.*(..))&quot;) public void before() &#123; System.out.println(&quot;---------执行方法前---------&quot;); &#125; /** * 执行方法后再执行 */ @After(&quot;execution(* com.ledao.service.impl.StudentServiceImpl.*(..))&quot;) public void after() &#123; System.out.println(&quot;---------执行方法后---------&quot;); &#125; /** * 环绕通知 * * @param proceedingJoinPoint 通过它调用目标方法 * @throws Throwable */ @Around(&quot;execution(* com.ledao.service.impl.StudentServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); //获取执行的业务代码 Signature signature = proceedingJoinPoint.getSignature(); System.out.println(&quot;执行的业务方法为:&quot; + signature); //执行业务代码 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕后&quot;); &#125;&#125; 配置文件ApplicationContext.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.ledao.service.impl.StudentServiceImpl&quot;/&gt; &lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.ledao.diy.AnnotationPointCut&quot;/&gt; &lt;!--开启注解支持--&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; 测试1234567891011121314151617import com.ledao.service.StudentService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;); StudentService studentService = context.getBean(&quot;studentService&quot;, StudentService.class); studentService.add(); &#125;&#125; 结果截图 PS.如果不想使用配置文件，则需要在配置类上使用@EnableAspectJAutoProxy注解，这个注解的作用是：启动AspectJ自动代理，配置类代码如下： 1234567891011121314151617181920212223242526272829303132package com.ledao.config;import com.ledao.dao.UserDao;import com.ledao.dao.UserDaoImpl;import com.ledao.diy.AnnotationPointCut;import com.ledao.service.StudentService;import com.ledao.service.UserService;import com.ledao.service.impl.StudentServiceImpl;import com.ledao.service.impl.UserServiceImpl;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Configuration@EnableAspectJAutoProxypublic class MyConfig &#123; @Bean public StudentService studentService()&#123; return new StudentServiceImpl(); &#125; @Bean public AnnotationPointCut annotationPointCut()&#123; return new AnnotationPointCut(); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"自定义类实现AOP","slug":"447","date":"2022-02-17T14:10:45.000Z","updated":"2022-04-14T02:21:20.419Z","comments":true,"path":"447.html","link":"","permalink":"https://blog.zoutl.cn/447.html","excerpt":"","text":"Service接口1234567891011121314151617181920212223242526272829package com.ledao.service;/** * @author LeDao * @company * @create 2022-02-17 20:29 */public interface StudentService &#123; /** * 添加学生 */ void add(); /** * 删除学生 */ void delete(); /** * 修改学生 */ void update(); /** * 根据id查找学生 */ void findById();&#125; Service接口实现类12345678910111213141516171819202122232425262728293031package com.ledao.service.impl;import com.ledao.service.StudentService;/** * @author LeDao * @company * @create 2022-02-17 20:30 */public class StudentServiceImpl implements StudentService &#123; @Override public void add() &#123; System.out.println(&quot;添加学生&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除学生&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改学生&quot;); &#125; @Override public void findById() &#123; System.out.println(&quot;根据id查找学生&quot;); &#125;&#125; 自定义切入类1234567891011121314151617package com.ledao.diy;/** * @author LeDao * @company * @create 2022-02-17 22:12 */public class DiyPointCut &#123; public void before()&#123; System.out.println(&quot;---------执行方法前---------&quot;); &#125; public void after()&#123; System.out.println(&quot;---------执行方法后---------&quot;); &#125;&#125; 配置文件ApplicationContext.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.ledao.service.impl.StudentServiceImpl&quot;/&gt; &lt;bean id=&quot;diyPointCut&quot; class=&quot;com.ledao.diy.DiyPointCut&quot;/&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;diyPointCut&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.ledao.service.impl.StudentServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试1234567891011121314151617import com.ledao.service.StudentService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;); StudentService studentService = context.getBean(&quot;studentService&quot;, StudentService.class); studentService.add(); &#125;&#125; 结果截图","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"使用Spring的API接口实现AOP","slug":"446","date":"2022-02-17T13:38:55.000Z","updated":"2022-04-14T02:21:18.961Z","comments":true,"path":"446.html","link":"","permalink":"https://blog.zoutl.cn/446.html","excerpt":"","text":"引入AOP的依赖123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; Service接口1234567891011121314151617181920212223242526272829package com.ledao.service;/** * @author LeDao * @company * @create 2022-02-17 20:29 */public interface StudentService &#123; /** * 添加学生 */ void add(); /** * 删除学生 */ void delete(); /** * 修改学生 */ void update(); /** * 根据id查找学生 */ void findById();&#125; Service接口实现类12345678910111213141516171819202122232425262728293031package com.ledao.service.impl;import com.ledao.service.StudentService;/** * @author LeDao * @company * @create 2022-02-17 20:30 */public class StudentServiceImpl implements StudentService &#123; @Override public void add() &#123; System.out.println(&quot;添加学生&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除学生&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改学生&quot;); &#125; @Override public void findById() &#123; System.out.println(&quot;根据id查找学生&quot;); &#125;&#125; 定义增强类Log前置增强类执行业务代码前先执行 12345678910111213141516171819202122232425262728package com.ledao.log;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;/** * @author LeDao * @company * @create 2022-02-17 21:10 */public class BeforeLog implements MethodBeforeAdvice &#123; /** * 执行业务代码前先执行 * * @param method 要执行的目标对象的方法 * @param args 参数 * @param target 目标对象 * @throws Throwable */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; if (target != null) &#123; System.out.println(&quot;[BeforeLog]&quot; + target.getClass().getName() + &quot;下的&quot; + method.getName() + &quot;方法被执行了&quot;); &#125; &#125;&#125; Log后置增强类执行业务代码后再执行 123456789101112131415161718192021222324252627package com.ledao.log;import org.springframework.aop.AfterReturningAdvice;import java.lang.reflect.Method;/** * @author LeDao * @company * @create 2022-02-17 21:14 */public class AfterLog implements AfterReturningAdvice &#123; /** * 执行业务代码后再执行 * * @param returnValue 返回值 * @param method 要执行的目标对象的方法 * @param args 参数 * @param target 目标对象 * @throws Throwable */ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;[AfterLog]执行了&quot; + method.getName() + &quot;方法,返回结果为:&quot; + returnValue); &#125;&#125; 配置文件ApplicationContext.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!--注册bean--&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.ledao.service.impl.StudentServiceImpl&quot;/&gt; &lt;bean id=&quot;beforeLog&quot; class=&quot;com.ledao.log.BeforeLog&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.ledao.log.AfterLog&quot;/&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--切入点：expression：表达式，execution(要执行的位置！* * * * *)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.ledao.service.impl.StudentServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕增加！--&gt; &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试1234567891011121314151617import com.ledao.service.StudentService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;); StudentService studentService = context.getBean(&quot;studentService&quot;, StudentService.class); studentService.add(); &#125;&#125; 结果截图添加学生的业务前后分别执行了BeforeLog和AfterLog","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"在字段上使用@Autowired注解时提示：Field injection is not recommended","slug":"445","date":"2022-02-16T18:16:40.494Z","updated":"2022-04-14T02:21:17.034Z","comments":true,"path":"445.html","link":"","permalink":"https://blog.zoutl.cn/445.html","excerpt":"","text":"概述之所以会出现这个提示，是因为Spring 4.0开始就不推荐使用属性注入，改为推荐Setter注入和构造器注入 解决办法想不出现这个提示，解决办法有4个： Setter注入 构造器注入 直接使用JDK的注解@Resource 如果还是想继续在字段上使用@Autowired注解，又不想出现这个提示，那就修改idea的配置让它不提示 Setter注入（推荐）123456private UserDao userDao;@Autowiredpublic void setUserDao(UserDao userDao) &#123; this.userDao = userDao;&#125; 构造器注入在UserServiceImpl.java注入UserDao 123456789private UserDao userDao;public UserServiceImpl() &#123;&#125;public UserServiceImpl(UserDao userDao) &#123; this.userDao = userDao;&#125; 配置类注册UserService的bean，使用构造器方式注入 123456789101112131415161718192021222324252627package com.ledao.config;import com.ledao.dao.UserDao;import com.ledao.dao.UserDaoImpl;import com.ledao.entity.Student;import com.ledao.service.UserService;import com.ledao.service.impl.UserServiceImpl;import org.springframework.context.annotation.*;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Configurationpublic class MyConfig &#123; @Bean public UserDao userDao() &#123; return new UserDaoImpl(); &#125; @Bean public UserService userService(UserDao userDao) &#123; return new UserServiceImpl(userDao); &#125;&#125; 使用@Resource（最简单）12@Resourceprivate UserDao userDao; 修改idea配置（不推荐）让鼠标停留在@Autowired注解上，使用快捷键ALT+回车键，选择下图的第二个选项，改了之后想改回来就有点麻烦了，所以不推荐使用","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring一些注解的说明以及用法","slug":"444","date":"2022-02-15T12:34:56.000Z","updated":"2022-04-14T02:21:14.767Z","comments":true,"path":"444.html","link":"","permalink":"https://blog.zoutl.cn/444.html","excerpt":"","text":"@Configuration说明相当于把该类作为Spring的XML配置文件中的beans标签，说明这是一个配置类 用法将该注解放在类的上面 123456789101112package com.ledao.config;import org.springframework.context.annotation.Configuration;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Configurationpublic class MyConfig &#123;&#125; @Bean说明等价于Spring的XML配置文件中的bean标签，用于注册bean对象 用法标注在方法上(返回某个实例的方法)，如果没有定义name属性那么bean的id为方法名，定义了name属性那么bean的id为name的属性值（这时候就不可以用方法名了）；这个方法的名字相当于bean标签中id属性，这个方法的返回值相当于bean标签中的class属性 123456789101112131415161718192021package com.ledao.config;import com.ledao.entity.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Configurationpublic class MyConfig &#123; @Bean public Student student()&#123; Student student = new Student(); student.setName(&quot;tom&quot;); return student; &#125;&#125; @Component说明用于注册bean对象，相当于XML配置文件的bean标签 用法将该注解放在类的上面 12345678910111213141516171819202122232425262728293031package com.ledao.entity;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Componentpublic class Student &#123; @Value(value = &quot;tom&quot;) private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; @Repository说明用于注册bean对象，相当于XML配置文件的bean标签，和@Component一样的效果，对应持久层（即dao接口的实现类），主要用于数据库相关操作 用法在dao接口的实现类上使用这个注解 1234567891011121314151617181920212223242526272829303132package com.ledao.dao;import org.springframework.stereotype.Repository;/** * @author LeDao * @company * @create 2022-02-16 21:31 */@Repository(value = &quot;userDao&quot;)public class UserDaoImpl implements UserDao&#123; @Override public void add() &#123; System.out.println(&quot;添加用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改用户&quot;); &#125; @Override public void findById() &#123; System.out.println(&quot;根据id查找用户&quot;); &#125;&#125; @Service说明用于注册bean对象，相当于XML配置文件的bean标签，和@Component一样的效果，对应服务层（即Service接口的实现类），主要用于设计一些复杂的逻辑，需要用到dao层 用法1234567891011121314151617181920212223242526272829303132333435363738package com.ledao.service.impl;import com.ledao.dao.UserDao;import com.ledao.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;/** * @author LeDao * @company * @create 2022-02-16 21:04 */@Service(value = &quot;userService&quot;)public class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public void add() &#123; userDao.add(); &#125; @Override public void delete() &#123; userDao.delete(); &#125; @Override public void update() &#123; userDao.update(); &#125; @Override public void findById() &#123; userDao.findById(); &#125;&#125; @Controller说明用于注册bean对象，相当于XML配置文件的bean标签，和@Component一样的效果，对应Spring MVC控制层，主要用于接收用户请求并调用Service层返回数据给前端页面 用法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ledao.controller.admin;import com.ledao.entity.BookType;import com.ledao.entity.PageBean;import com.ledao.service.BookService;import com.ledao.service.BookTypeService;import com.ledao.util.StringUtil;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 后台图书类别Controller层 * * @author LeDao * @company * @create 2022-01-21 23:57 */@RestController@RequestMapping(&quot;/admin/bookType&quot;)public class BookTypeAdminController &#123; @Resource private BookTypeService bookTypeService; /** * 检查图书类别id是否存在 * * @param bookTypeId * @return */ @RequestMapping(&quot;/checkBookTypeId&quot;) public Map&lt;String, Object&gt; checkBookTypeId(@RequestParam(value = &quot;bookTypeId&quot;, required = false) Integer bookTypeId) &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(16); BookType bookType = bookTypeService.findById(bookTypeId); if (bookType == null) &#123; resultMap.put(&quot;success&quot;, false); resultMap.put(&quot;errorInfo&quot;, &quot;你选择的图书类别不存在,请重新选择!!&quot;); &#125; else &#123; resultMap.put(&quot;success&quot;, true); &#125; return resultMap; &#125;&#125; @Value说明用于注入属性的值 用法将该注解放在实体类定义的属性上面，或者放在Setter方法上面，如果两个地方都使用该注解以Setter方法的为准 12@Value(value = &quot;tom&quot;)private String name; @Autowired和@Resource这两个注解都是用于实现Spring的自动装配，详细说明和用法查看博客：使用注解实现Spring自动装配 | LeDao的博客 (zoutl.cn) @Scope定义配置类下的某个使用了@bean注解的方法的作用域 用法Spring bean的默认作用域为singleton 在某个使用了@bean注解的方法的上面使用这个注解时定义该方法的作用域，只对该方法有效 123456789101112131415161718192021package com.ledao.config;import com.ledao.entity.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Scope;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Configurationpublic class MyConfig &#123; @Bean @Scope(value = &quot;prototype&quot;) public Student student()&#123; return new Student(); &#125;&#125; @ComponentScan说明用于定义扫描的路径并从中找出标识了需要装配的类自动装配到spring的bean容器中（使用@Component注解的类） 用法一般在配置类上使用，扫描指定包下的类，将所有需要装配的类都装配到spring的bean容器中；如果不使用这个注解的话，只会装配该配置类下使用了@bean的方法对应的类 123456789101112131415161718192021package com.ledao.config;import com.ledao.entity.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Configuration@ComponentScan(&quot;com.ledao.entity&quot;)public class MyConfig &#123; @Bean public Student student()&#123; return new Student(); &#125;&#125; 如果要扫描多个包，用法如下：（也可以使用@ComponentScans注解） 1@ComponentScan(value = &#123;&quot;com.ledao.entity&quot;,&quot;com.ledao.service.impl&quot;&#125;) @ComponentScans说明和@ComponentScan一样的效果，用于扫描多个包 用法1@ComponentScans(value = &#123;@ComponentScan(value = &quot;com.ledao.entity&quot;), @ComponentScan(value = &quot;com.ledao.service.impl&quot;)&#125;) @Import说明用于导入其他配置类的配置 用法在要导入其他配置类的配置类上使用，@Import()括号内填要导入的配置类名称.class 12345678910111213141516171819package com.ledao.config;import com.ledao.entity.Student;import org.springframework.context.annotation.*;/** * @author LeDao * @company * @create 2022-02-15 20:39 */@Configuration@Import(MyConfig2.class)public class MyConfig &#123; @Bean public Student student()&#123; return new Student(); &#125;&#125; @Aspect说明用于标注使用这个注解的类是一个切面 用法查看博客：Spring 使用注解实现 AOP | LeDao 的博客 (zoutl.cn) @Before说明执行业务代码前先执行这个方法 用法查看博客：Spring 使用注解实现 AOP | LeDao 的博客 (zoutl.cn) @After说明执行业务代码后再执行这个方法 用法查看博客：Spring 使用注解实现 AOP | LeDao 的博客 (zoutl.cn) @Around说明环绕增强方法使用 用法查看博客：Spring 使用注解实现 AOP | LeDao 的博客 (zoutl.cn) @EnableAspectJAutoProxy说明启动AspectJ自动代理 用法查看博客：Spring 使用注解实现 AOP | LeDao 的博客 (zoutl.cn) @Transactional说明用于实现事务 用法查看博客：Spring 使用 @Transactional 注解实现事务 | LeDao 的博客 (zoutl.cn)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"使用注解实现Spring自动装配","slug":"443","date":"2022-02-15T10:10:42.000Z","updated":"2022-04-14T02:21:12.788Z","comments":true,"path":"443.html","link":"","permalink":"https://blog.zoutl.cn/443.html","excerpt":"","text":"概述实现Spring自动装配的注解有两个：@Autowired和@Resource，两个注解的区别如下： @Autowired 出处：这是Spring的注解 用法：可以放在属性上面（这时候可以省略setter方法），也可以放在setter方法上面，一般放在属性上面即可 实现方式：通过byType的方式实现，需要保证所有bean的class唯一，即不可以存在相同类型的bean 指定要装配的bean的id的方式：可以使用@Qualifier注解指定bean的id，这个注解使用value属性指定bean的id @Resource 出处：这是JDK的注解 用法：放在属性上面 实现方式：默认通过byName的方式实现，如果找不到名字，则通过byType实现，需要保证所有bean的class唯一，即不可以存在相同类型的bean；如果两个都找不到的情况下，就报错 指定要装配的bean的id的方式：指定bean的id的方式有3种：①根据Setter方法名指定自动装配的bean的id，例如：Setter的方法名为setDog1，所以bean的id就必须为dog1②通过@Resource注解的name属性指定bean的id③可以使用@Qualifier注解指定bean的id，这个注解使用value属性指定bean的id。特别地，②和③一起用，②的方式有效 代码实现@AutowiredApplicationContext.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--开启注解的支持--&gt; &lt;context:annotation-config/&gt; &lt;bean id=&quot;dog1&quot; class=&quot;com.ledao.entity.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小哈1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;dog2&quot; class=&quot;com.ledao.entity.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小哈2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat1&quot; class=&quot;com.ledao.entity.Cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小花1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;people&quot; class=&quot;com.ledao.entity.People&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; Dog实体类123456789101112131415161718192021222324252627282930package com.ledao.entity;/** * @author LeDao * @company * @create 2022-02-15 18:14 */public class Dog &#123; private String name; public Dog() &#123; System.out.println(&quot;狗吃骨头&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Cat实体类123456789101112131415161718192021222324252627282930package com.ledao.entity;/** * @author LeDao * @company * @create 2022-02-15 18:14 */public class Cat &#123; private String name; public Cat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; People实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ledao.entity;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;/** * @author LeDao * @company * @create 2022-02-15 18:13 */public class People &#123; private String name; @Autowired @Qualifier(value = &quot;dog2&quot;) private Dog dog; @Autowired private Cat cat; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, dog=&quot; + dog + &quot;, cat=&quot; + cat + &#x27;&#125;&#x27;; &#125;&#125; 测试1234567891011121314151617import com.ledao.entity.People;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;); People people = context.getBean(&quot;people&quot;, People.class); System.out.println(people); &#125;&#125; 结果 @Resource对比和@Autowired的代码对比，只改动了People实体类 People实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ledao.entity;import javax.annotation.Resource;/** * @author LeDao * @company * @create 2022-02-15 18:13 */public class People &#123; private String name; @Resource(name = &quot;dog2&quot;) private Dog dog; @Resource private Cat cat; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, dog=&quot; + dog + &quot;, cat=&quot; + cat + &#x27;&#125;&#x27;; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring自动装配","slug":"442","date":"2022-02-14T13:14:03.000Z","updated":"2022-04-14T02:21:09.807Z","comments":true,"path":"442.html","link":"","permalink":"https://blog.zoutl.cn/442.html","excerpt":"","text":"概述自动装配是Spring满足bean依赖一种方式，Spring会在上下文中自动寻找，并自动给bean装配属性 自动装配有两种方式： ByName 根据Setter方法名指定自动装配的bean的id，例如：Setter的方法名为setDog1，所以bean的id就必须为dog1 ByType 需要保证所有bean的class唯一，即不可以存在相同类型的bean 代码实现测试环境一个People有Dog和Cat 手动装配People实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ledao.entity;/** * @author LeDao * @company * @create 2022-02-15 18:13 */public class People &#123; private String name; private Dog dog; private Cat cat; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; @Override public String toString() &#123; return &quot;People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, dog=&quot; + dog + &quot;, cat=&quot; + cat + &#x27;&#125;&#x27;; &#125;&#125; Dog实体类123456789101112131415161718192021222324252627282930package com.ledao.entity;/** * @author LeDao * @company * @create 2022-02-15 18:14 */public class Dog &#123; private String name; public Dog() &#123; System.out.println(&quot;狗吃骨头&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Cat实体类123456789101112131415161718192021222324252627282930package com.ledao.entity;/** * @author LeDao * @company * @create 2022-02-15 18:14 */public class Cat &#123; private String name; public Cat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ApplicationContext.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.ledao.entity.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小花&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.ledao.entity.Cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小哈&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;people&quot; class=&quot;com.ledao.entity.People&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt; &lt;property name=&quot;dog&quot; ref=&quot;dog&quot;/&gt; &lt;property name=&quot;cat&quot; ref=&quot;cat&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码1234567891011121314151617import com.ledao.entity.People;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ApplicationContext.xml&quot;); People people = context.getBean(&quot;people&quot;, People.class); System.out.println(people); &#125;&#125; 结果 自动装配ByName方式12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.ledao.entity.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小哈1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;dog2&quot; class=&quot;com.ledao.entity.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小哈2&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.ledao.entity.Cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小花1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;people&quot; class=&quot;com.ledao.entity.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; ByType方式12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dog1&quot; class=&quot;com.ledao.entity.Dog&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小哈1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.ledao.entity.Cat&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小花1&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;people&quot; class=&quot;com.ledao.entity.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring bean作用域","slug":"441","date":"2022-02-14T12:44:50.000Z","updated":"2022-04-14T02:21:07.323Z","comments":true,"path":"441.html","link":"","permalink":"https://blog.zoutl.cn/441.html","excerpt":"","text":"类型XML配置文件定义Scope时，bean标签使用scope属性即可 Scope 描述 singleton spring IoC容器只存在一个bean对象实例。 prototype 与单例相反，每次请求bean时，它都会创建一个新实例。 request 在HTTP请求(Request) 的完整生命周期中，将创建并使用单个实例。 只适用于web环境中Spring ApplicationContext中有效。 session 在HTTP会话(Session) 的完整生命周期中，将创建并使用单个实例。 只适用于web环境中Spring ApplicationContext中有效。 application 将在ServletContext的完整生命周期中创建并使用单个实例。只适用于web环境中Spring ApplicationContext中有效。 websocket 在WebSocket的完整生命周期中，将创建并使用单个实例。 只适用于web环境中Spring ApplicationContext中有效。 singleton和prototype的区别singleton多次获取同一个bean时，获取到的是同一个对象，这是Spring默认的，可以不用说明（即bean标签可以省略scope属性） beans.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;entity.User&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码12345678910111213141516171819202122import config.MyConfig;import entity.Student;import entity.StudentClass;import entity.User;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user1 = context.getBean(&quot;user&quot;, User.class); User user2 = context.getBean(&quot;user&quot;, User.class); System.out.println(user1==user2); &#125;&#125; 结果控制台打印出true prototype多次获取同一个bean时，获取到的是不同的对象，因为每一次获取都会生成一个新的对象 beans.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;user&quot; class=&quot;entity.User&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试代码12345678910111213141516171819202122import config.MyConfig;import entity.Student;import entity.StudentClass;import entity.User;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); User user1 = context.getBean(&quot;user&quot;, User.class); User user2 = context.getBean(&quot;user&quot;, User.class); System.out.println(user1==user2); &#125;&#125; 结果控制台打印出false","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring的c和p命名空间","slug":"440","date":"2022-02-14T07:09:39.000Z","updated":"2022-04-14T02:21:05.476Z","comments":true,"path":"440.html","link":"","permalink":"https://blog.zoutl.cn/440.html","excerpt":"","text":"概述Spring的c和p命名空间可以注入依赖，也就是拓展方式注入 代码实现StudentClass实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344package entity;/** * @author LeDao * @company * @create 2022-02-14 14:11 */public class StudentClass &#123; private int id; private String name; public StudentClass() &#123; &#125; public StudentClass(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Class&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; c命名空间在beans标签加上约束1xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 定义bean 通过构造器参数注入 1&lt;bean id=&quot;studentClass1&quot; class=&quot;entity.StudentClass&quot; c:id=&quot;1&quot; c:name=&quot;www&quot;/&gt; 通过构造器下标注入 1&lt;bean id=&quot;studentClass2&quot; class=&quot;entity.StudentClass&quot; c:_0=&quot;2&quot; c:_1=&quot;www2&quot;/&gt; 注意事项实体类中一定要定义一个有参构造器，不然使用c命名空间会报错 p命名空间在beans标签加上约束1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 定义bean1&lt;bean id=&quot;studentClass3&quot; class=&quot;entity.StudentClass&quot; p:id=&quot;3&quot; p:name=&quot;www3&quot;/&gt; 注意事项实体类中如果定义了一个有参构造器，就需要自己手动定义一个无参构造器，不然使用p命名空间会报错 完整beans.xml代码12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;studentClass1&quot; class=&quot;entity.StudentClass&quot; c:id=&quot;1&quot; c:name=&quot;www&quot;/&gt; &lt;bean id=&quot;studentClass2&quot; class=&quot;entity.StudentClass&quot; c:_0=&quot;2&quot; c:_1=&quot;www2&quot;/&gt; &lt;bean id=&quot;studentClass3&quot; class=&quot;entity.StudentClass&quot; p:id=&quot;3&quot; p:name=&quot;www3&quot;/&gt;&lt;/beans&gt; 测试1234567891011121314151617181920import config.MyConfig;import entity.Student;import entity.StudentClass;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); StudentClass studentClass = context.getBean(&quot;studentClass3&quot;, StudentClass.class); System.out.println(studentClass); &#125;&#125; 结果控制打印出id为studentClass3的对象，该对象的id为3，name为www3","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring依赖注入多种类型数据","slug":"439","date":"2022-02-14T06:08:45.000Z","updated":"2022-04-14T02:21:02.775Z","comments":true,"path":"439.html","link":"","permalink":"https://blog.zoutl.cn/439.html","excerpt":"","text":"Student实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package entity;import java.util.*;/** * @author LeDao * @company * @create 2022-02-13 21:26 */public class Student &#123; private int id; private String name; private StudentClass studentClass; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; cards; private Set&lt;String&gt; games; private String wife; private Properties info; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public StudentClass getStudentClass() &#123; return studentClass; &#125; public void setStudentClass(StudentClass studentClass) &#123; this.studentClass = studentClass; &#125; public String[] getBooks() &#123; return books; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public List&lt;String&gt; getHobbies() &#123; return hobbies; &#125; public void setHobbies(List&lt;String&gt; hobbies) &#123; this.hobbies = hobbies; &#125; public Map&lt;String, String&gt; getCards() &#123; return cards; &#125; public void setCards(Map&lt;String, String&gt; cards) &#123; this.cards = cards; &#125; public Set&lt;String&gt; getGames() &#123; return games; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public Properties getInfo() &#123; return info; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, studentClass=&quot; + studentClass + &quot;, books=&quot; + Arrays.toString(books) + &quot;, hobbies=&quot; + hobbies + &quot;, cards=&quot; + cards + &quot;, games=&quot; + games + &quot;, wife=&#x27;&quot; + wife + &#x27;\\&#x27;&#x27; + &quot;, info=&quot; + info + &#x27;&#125;&#x27;; &#125;&#125; StudentsClass实体类123456789101112131415161718192021222324252627282930313233343536package entity;/** * @author LeDao * @company * @create 2022-02-14 14:11 */public class StudentClass &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Class&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; beans.xml下面展示的数据类型有：一般类型、对象、数组、List、Map、Set、空值、Properties 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;studentClass1&quot; class=&quot;entity.StudentClass&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;软件工程3班&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;user1&quot; class=&quot;entity.Student&quot;&gt; &lt;!--一般类型--&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;!--对象--&gt; &lt;property name=&quot;studentClass&quot; ref=&quot;studentClass1&quot;/&gt; &lt;!--数组--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;Java编程思想&lt;/value&gt; &lt;value&gt;MySQL必知必会&lt;/value&gt; &lt;value&gt;平凡的世界&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;rap&lt;/value&gt; &lt;value&gt;打篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map--&gt; &lt;property name=&quot;cards&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;123&quot;/&gt; &lt;entry key=&quot;校园卡&quot; value=&quot;321&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;DNF&lt;/value&gt; &lt;value&gt;COC&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--空值--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--Properties--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;userName&quot;&gt;root&lt;/prop&gt; &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试12345678910111213141516171819import config.MyConfig;import entity.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student) context.getBean(&quot;user1&quot;); System.out.println(student); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring通过注解创建对象","slug":"438","date":"2022-02-13T17:21:22.000Z","updated":"2022-04-14T02:21:00.699Z","comments":true,"path":"438.html","link":"","permalink":"https://blog.zoutl.cn/438.html","excerpt":"","text":"使用到的注解使用到的注解有@Configuration和@Bean @Configuration标注在类上，相当于把该类作为Spring的XML配置文件中的beans标签 @Bean标注在方法上(返回某个实例的方法)，等价于Spring的XML配置文件中的bean标签，用于注册bean对象，如果没有定义name属性那么bean的id为方法名，定义了name属性那么bean的id为name的属性值（这时候就不可以用方法名了） 实现过程Student实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package entity;/** * @author LeDao * @company * @create 2022-02-13 21:26 */public class Student &#123; private int id; private String name; /** * 无参构造方法,如果不存在有参构造方法时可以省略,存在就需要自己写出来 */ public Student() &#123; &#125; /** * 有参构造方法 * * @param id * @param name */ public Student(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Spring配置类12345678910111213141516171819202122package config;import entity.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author LeDao * @company * @create 2022-02-14 1:12 */@Configurationpublic class MyConfig &#123; @Bean(name = &quot;s1&quot;) public Student tom111() &#123; Student student = new Student(); student.setId(111); student.setName(&quot;tom111&quot;); return student; &#125;&#125; 测试12345678910111213141516171819import config.MyConfig;import entity.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); Student student = (Student) context.getBean(&quot;s1&quot;); System.out.println(student); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring配置","slug":"437","date":"2022-02-13T16:08:01.000Z","updated":"2022-04-14T02:20:58.210Z","comments":true,"path":"437.html","link":"","permalink":"https://blog.zoutl.cn/437.html","excerpt":"","text":"概述Spring的配置有beans、bean、import、alias、description 说明beansSpring配置文件的根元素，里面可以包含很多个bean标签 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;/beans&gt; beanbean标签放在beans标签内部 每一个bean标签为一个对象，常用属性有：id为对象名，class为所属对象，name为别名（多个别名可以用英文逗号,隔开） property标签为对象的属性名称以及值，name为属性名称，value为值 12345&lt;!--通过无参构造方法创建对象--&gt;&lt;bean id=&quot;tom&quot; class=&quot;entity.Student&quot; name=&quot;s1,s2&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt;&lt;/bean&gt; import在当前配置文件导入其他的Spring配置文件的配置，resource属性为导入的XML文件名称 下面我在beans.xml导入bean1.xml的配置，相当于将bean1.xml的beans标签内部的所有配置都复制到beans.xml内 beans.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--通过无参构造方法创建对象--&gt; &lt;bean id=&quot;tom&quot; class=&quot;entity.Student&quot; name=&quot;s1,s2&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt; &lt;!--导入bean1.xml的配置--&gt; &lt;import resource=&quot;bean1.xml&quot;/&gt;&lt;/beans&gt; bean1.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--通过有参构造方法创建对象(通过下标赋值)--&gt; &lt;bean id=&quot;tom1&quot; class=&quot;entity.Student&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;2&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;tom1&quot;/&gt; &lt;/bean&gt; &lt;!--通过有参构造方法创建对象(通过参数类型赋值)--&gt; &lt;bean id=&quot;tom2&quot; class=&quot;entity.Student&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;3&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;tom2&quot;/&gt; &lt;/bean&gt; &lt;!--通过有参构造方法创建对象(通过参数名称赋值)--&gt; &lt;bean id=&quot;tom3&quot; class=&quot;entity.Student&quot;&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;4&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;tom3&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; alias别名，放在beans标签内部，name属性为对应bean的id，alias属性为别名的名称 和bean的name属性是一样的效果，一般不使用这种方式，使用bean的name属性就可以了（可以直接在对应的bean上看到，方便管理） 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--通过无参构造方法创建对象--&gt; &lt;bean id=&quot;tom&quot; class=&quot;entity.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt; &lt;!--id为tom的bean的别名--&gt; &lt;alias name=&quot;tom&quot; alias=&quot;s3&quot;/&gt;&lt;/beans&gt; descriptionXML文件描述，一定放在beans标签内部的第一行（即放在所有bean、import、alias标签前面），不然会提示错误 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;description&gt;我是描述&lt;/description&gt; &lt;!--通过无参构造方法创建对象--&gt; &lt;bean id=&quot;tom&quot; class=&quot;entity.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt; &lt;!--id为tom的bean的别名--&gt; &lt;alias name=&quot;tom&quot; alias=&quot;s3&quot;/&gt; &lt;!--导入bean1.xml的配置--&gt; &lt;import resource=&quot;bean1.xml&quot;/&gt;&lt;/beans&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Spring IOC创建对象","slug":"436","date":"2022-02-13T14:11:50.000Z","updated":"2022-04-14T02:20:56.694Z","comments":true,"path":"436.html","link":"","permalink":"https://blog.zoutl.cn/436.html","excerpt":"","text":"创建的方式Spring IOC可以通过无参构造方法和有参构造方法来创建对象，默认是通过无参构造方法创建 无参构造方法如果实体类不存在有参构造方法时可以省略，存在就需要自己写出来（不然就无法通过无参构造方法创建），也就是Set注入 Student实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package entity;/** * @author LeDao * @company * @create 2022-02-13 21:26 */public class Student &#123; private int id; private String name; /** * 无参构造方法,如果不存在有参构造方法时可以省略,存在就需要自己写出来 */ public Student() &#123; &#125; /** * 有参构造方法 * * @param id * @param name */ public Student(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; XML文件定义对象每一个bean标签为一个对象，id为对象名，class为所属对象 property标签为对象的属性名称以及值，name为属性名称，value为值 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--通过无参构造方法创建对象--&gt; &lt;bean id=&quot;tom&quot; class=&quot;entity.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;tom&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试1234567891011121314151617import entity.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2022-02-12 15:56 */public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student) context.getBean(&quot;tom&quot;); System.out.println(student); &#125;&#125; 有参构造方法也称为构造器注入，通过有参构造方法来创建对象的方式有三种：（具体的有参构造方法看上面的Student实体类） 通过参数下标赋值 通过参数类型赋值 通过参数名称赋值 通过参数下标赋值在上面的构造方法中，id的下标为0，name的下标为1 12345&lt;!--通过有参构造方法创建对象(通过参数下标赋值)--&gt;&lt;bean id=&quot;tom1&quot; class=&quot;entity.Student&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;2&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;tom1&quot;/&gt;&lt;/bean&gt; 通过参数类型赋值不要使用这种方式，因为可能会存在参数类型相同的情况 12345&lt;!--通过有参构造方法创建对象(通过参数类型赋值)--&gt;&lt;bean id=&quot;tom2&quot; class=&quot;entity.Student&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;3&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;tom2&quot;/&gt;&lt;/bean&gt; 通过参数名称赋值使用这种方式最好 12345&lt;!--通过有参构造方法创建对象(通过参数名称赋值)--&gt;&lt;bean id=&quot;tom3&quot; class=&quot;entity.Student&quot;&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;4&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;tom3&quot;/&gt;&lt;/bean&gt; PS.Set注入和构造器注入的区别：构造器注入就是在有参构造的情况下，采用有参构造进行注入属性值，要注入全部参数；set注入就是只有无参构造的情况之下，采用set方法进行属性的注入，可以注入部分参数。","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Windows11设置环境变量","slug":"435","date":"2022-02-03T06:02:57.000Z","updated":"2022-04-14T02:01:18.469Z","comments":true,"path":"435.html","link":"","permalink":"https://blog.zoutl.cn/435.html","excerpt":"","text":"打开设置按下Windows键，点击设置的按钮 打开高级系统设置打开设置界面后，左侧菜单选择系统，右侧选择关于 然后点击高级系统设置 选择环境变量 添加环境变量点击第二个新建，第一个是当前用户的用户变量（只对当前用户有效），而环境变量对所有用户有效","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"Spring Boot使用jasypt加密数据库密码","slug":"434","date":"2022-02-03T05:45:23.000Z","updated":"2022-04-14T02:20:52.392Z","comments":true,"path":"434.html","link":"","permalink":"https://blog.zoutl.cn/434.html","excerpt":"","text":"引入jasypt依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 设置jasypt加密的盐值在application.yml配置文件中设置jasypt加密的盐值 123jasypt: encryptor: password: ledao 获取加密后的数据库密码在测试模块中使用下面代码获取加密后的数据库密码，我的数据库密码为123456，下面代码在控制台打印加密后的数据库密码 1234567891011121314151617181920package com.ledao;import org.jasypt.encryption.StringEncryptor;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;@SpringBootTestclass BookManageSystemApplicationTests &#123; @Resource private StringEncryptor encryptor; @Test void contextLoads() &#123; System.out.println(encryptor.encrypt(&quot;123456&quot;)); &#125;&#125; 修改application.yml的数据库密码将上面得到的加密后的密码用ENC()包起来，完整代码如下：（把url和username也加密起来也是可以的） 12345678910# 数据源配置spring: application: name: microservice-student datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db_bookmanagesystem?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8 username: root password: ENC(69cbirQ6l+cOIL8x6nblXw==) PS.虽然jasypt每次加密的结果都不同，但是解密后的原密码是同一个","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"jasypt","slug":"jasypt","permalink":"https://blog.zoutl.cn/tags/jasypt/"}]},{"title":"Spring Boot引用application.yml配置文件的属性","slug":"433","date":"2022-01-28T05:36:34.000Z","updated":"2022-04-14T02:20:48.694Z","comments":true,"path":"433.html","link":"","permalink":"https://blog.zoutl.cn/433.html","excerpt":"","text":"添加一个属性首先在application.yml配置文件中添加一个属性，并给它赋值 直接在代码中引用通过@Value注解即可在当前类定义变量并获得属性的值 12@Value(&quot;$&#123;maxBorrowBookSize&#125;&quot;)private Integer maxBorrowBookSize; 使用这个属性值就直接像一般变量那样使用即可，这个变量是当前类可用 12345if (borrowRecordList2.size() == maxBorrowBookSize) &#123; resultMap.put(&quot;success&quot;, false); resultMap.put(&quot;errorInfo&quot;, &quot;借书失败，你同时借阅的图书过多，每次最多同时借阅&quot; + maxBorrowBookSize + &quot;本图书！！&quot;); return resultMap;&#125; 使用配置文件属性实体类说明上面是直接在要使用属性的类中使用，这样不方便管理，如果多个类都需要使用到同一个属性，那么管理起来就很麻烦了，我们可以专门创建一个实体类用于调用这些属性，要修改某个属性就只需要在这个实体类修改即可 实体类1234567891011121314151617181920package com.ledao.config;import lombok.Data;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;/** * 配置文件属性实体类 * * @author LeDao * @company * @create 2022-02-01 11:22 */@Data@Componentpublic class ConfigProperties &#123; @Value(&quot;$&#123;maxBorrowBookSize&#125;&quot;) private Integer maxBorrowBookSize;&#125; 使用使用@Resource注解在当前类注入 12@Resourceprivate ConfigProperties configProperties; 在对应的方法中使用 12345if (borrowRecordList2.size() == configProperties.getMaxBorrowBookSize()) &#123; resultMap.put(&quot;success&quot;, false); resultMap.put(&quot;errorInfo&quot;, &quot;借书失败，你同时借阅的图书过多，每次最多同时借阅&quot; + configProperties.getMaxBorrowBookSize() + &quot;本图书！！&quot;); return resultMap;&#125; PS.如果要在普通类的普通方法使用配置文件属性实体类，去查看博客：Spring Boot 普通类使用 @Resource 或 @Autowired 注解 | LeDao 的博客 (zoutl.cn)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"}]},{"title":"图书管理系统","slug":"432","date":"2022-01-27T13:38:36.000Z","updated":"2022-03-26T12:17:04.465Z","comments":true,"path":"432.html","link":"","permalink":"https://blog.zoutl.cn/432.html","excerpt":"","text":"项目地址GitHub地址：https://github.com/a6678696/BookManageSystem 使用的技术本项目核心技术采用Spring Boot+Mybatis；开发工具idea；数据库MySQL5.6；界面采用了jQuery EasyUI框架；Quartz定时任务； 功能介绍普通用户查找图书、借书、续借图书、归还图书、修改密码、安全退出系统 管理员用户管理（增删改查、封禁和解封用户、设置用户是否可借书）、图书类别管理（增删改查）、图书管理（增删改查）、查看用户的借阅记录、修改密码、安全退出系统 系统每分钟自动检测用户正在借阅的书是否逾期，如果逾期就修改借阅记录的状态为逾期 图片展示登录界面 用户首页 借书 查看借阅记录、续借和还书 修改密码 安全退出系统 管理员首页 用户管理 图书类别管理 图书管理 查看用户的借阅记录 修改密码 安全退出系统","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"在GitHub的Overview页面添加统计模块","slug":"431","date":"2022-01-27T11:03:09.000Z","updated":"2022-04-14T11:19:53.383Z","comments":true,"path":"431.html","link":"","permalink":"https://blog.zoutl.cn/431.html","excerpt":"","text":"新建仓库 新建一个仓库，命名为自己的用户名（我的GitHub用户名为a6678696，所以我就要命名为a6678696），然后会看到下图的绿色部分 将仓库设置为public，并且添加一个README.md文件（选中下图的Public和Add a README file），最后点击创建按钮即可 编辑README.md在--&gt;下方加入以下代码：（username的值改为自己的用户名） 1![a6678696&#x27;s github stats](https://github-readme-stats.vercel.app/api?username=a6678696&amp;theme=github) 如果要隐藏指定统计信息，就需要在后面加上&amp;hide=prs,contribs，多个信息用英文的逗号隔开 1![a6678696&#x27;s github stats](https://github-readme-stats.vercel.app/api?username=a6678696&amp;theme=github&amp;hide=prs,contribs) 结果截图进入Overview页面，看到下图的统计信息说明配置成功","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"MyBatis实现in查询","slug":"430","date":"2022-01-24T15:58:07.000Z","updated":"2022-04-14T01:43:34.542Z","comments":true,"path":"430.html","link":"","permalink":"https://blog.zoutl.cn/430.html","excerpt":"","text":"业务说明表结构t_book为图书表，t_borrow_record为借阅记录表，t_book的主键id是t_borrow_record的外键bookId 说明通过图书名称查询借阅记录，因为t_borrow_record是没有图书名称字段的，所以先通过模糊查询查询t_book的图书名称获取id集合，然后通过t_borrow_record的bookId字段使用in查询即可查询到数据 XML代码关键代码当idList不为空时，才使用in查询 123456&lt;if test=&quot;idList != null&quot;&gt; and bookId in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;idList&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/if&gt; 完整代码idList通过map传入 123456789101112131415161718192021&lt;select id=&quot;list&quot; parameterType=&quot;map&quot; resultMap=&quot;BorrowRecordResult&quot;&gt; select * from t_borrow_record &lt;where&gt; &lt;if test=&quot;userName != null and userName != &#x27;&#x27;&quot;&gt; and userName like #&#123;userName&#125; &lt;/if&gt; &lt;if test=&quot;userId != null&quot;&gt; and userId = #&#123;userId&#125; &lt;/if&gt; &lt;if test=&quot;idList != null&quot;&gt; and bookId in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;idList&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;if test=&quot;start != null and size != null&quot;&gt; limit #&#123;start&#125;,#&#123;size&#125; &lt;/if&gt;&lt;/select&gt; Java代码下面代码主要是获取idList以及将idList传入map 123456Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);List&lt;Integer&gt; idList;if (StringUtil.isNotEmpty(borrowRecord.getBookName())) &#123; idList = bookService.selectIdByNameLike(StringUtil.formatLike(borrowRecord.getBookName())); map.put(&quot;idList&quot;, idList);&#125;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"Java给日期加一天","slug":"429","date":"2022-01-24T15:47:16.000Z","updated":"2022-04-14T02:20:43.135Z","comments":true,"path":"429.html","link":"","permalink":"https://blog.zoutl.cn/429.html","excerpt":"","text":"Java代码测试代码12345678910111213141516171819202122package com.ledao;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;/** * @author LeDao * @company * @create 2022-01-24 23:48 */public class MyTest &#123; public static void main(String[] args) &#123; Date date = new Date(); System.out.println(date); Calendar calendar = new GregorianCalendar(); calendar.setTime(date); calendar.add(Calendar.DAY_OF_YEAR, 1); System.out.println(calendar.getTime()); &#125;&#125; 将代码抽取成方法下面的方法有两个参数：参数一为要加天数的时间，参数二为添加的天数 12345678910111213/** * 给日期加天数 * * @param date 要加天数的时间 * @param days 添加的天数 * @return */public static Date dateAddDays(Date date, int days) &#123; Calendar calendar = new GregorianCalendar(); calendar.setTime(date); calendar.add(Calendar.DAY_OF_YEAR, days); return calendar.getTime();&#125; 结果可以看到第二个时间比第一个时间多了一天","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"JavaScript格式化时间","slug":"428","date":"2022-01-24T15:20:25.000Z","updated":"2022-03-26T12:23:56.073Z","comments":true,"path":"428.html","link":"","permalink":"https://blog.zoutl.cn/428.html","excerpt":"","text":"格式化方法1234567891011121314151617181920function dateFormat(fmt, date) &#123; let ret; const opt = &#123; &quot;Y+&quot;: date.getFullYear().toString(), // 年 &quot;m+&quot;: (date.getMonth() + 1).toString(), // 月 &quot;d+&quot;: date.getDate().toString(), // 日 &quot;H+&quot;: date.getHours().toString(), // 时 &quot;M+&quot;: date.getMinutes().toString(), // 分 &quot;S+&quot;: date.getSeconds().toString() // 秒 // 有其他格式化字符需求可以继续添加，必须转化成字符串 &#125;; for (let k in opt) &#123; ret = new RegExp(&quot;(&quot; + k + &quot;)&quot;).exec(fmt); if (ret) &#123; fmt = fmt.replace(ret[1], (ret[1].length == 1) ? (opt[k]) : (opt[k].padStart(ret[1].length, &quot;0&quot;))) &#125; ; &#125; return fmt;&#125; 调用12345//格式化现在的时间dateFormat(&quot;YYYY-mm-dd HH:MM:SS&quot;, new Date());//格式化指定的时间dateFormat(&quot;YYYY-mm-dd HH:MM:SS&quot;, new Date(&quot;2021-01-24T11:09:59.000+00:00&quot;)); PS.来源：js 日期时间的格式化 - 简书 (jianshu.com)","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Hexo博客的标题包含特殊字符","slug":"427","date":"2022-01-23T10:54:48.000Z","updated":"2022-04-15T16:35:21.683Z","comments":true,"path":"427.html","link":"","permalink":"https://blog.zoutl.cn/427.html","excerpt":"","text":"概述hexo博客的标题里是不能包含特殊字符的，不然会报错：err: YAMLException: unexpected end of the stream within a single quoted scalar 解决办法用英文的单引号&#39;&#39;将标题包起来即可","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"MySQL报错：java.sql.SQLSyntax: You have an error in your SQL syntax的解决办法","slug":"426","date":"2022-01-21T17:25:06.000Z","updated":"2022-04-14T11:28:20.530Z","comments":true,"path":"426.html","link":"","permalink":"https://blog.zoutl.cn/426.html","excerpt":"","text":"报错原因表的字段使用了MySQL的关键字 解决办法将对应的字段修改成非MySQL关键字，MySQL关键字如下表 关键字 关键字 关键字 ADD ALL ALTER ANALYZE AND AS ASC ASENSITIVE BEFORE BETWEEN BIGINT BINARY BLOB BOTH BY CALL CASCADE CASE CHANGE CHAR CHARACTER CHECK COLLATE COLUMN CONDITION CONNECTION CONSTRAINT CONTINUE CONVERT CREATE CROSS CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER CURSOR DATABASE DATABASES DAY_HOUR DAY_MICROSECOND DAY_MINUTE DAY_SECOND DEC DECIMAL DECLARE DEFAULT DELAYED DELETE DESC DESCRIBE DETERMINISTIC DISTINCT DISTINCTROW DIV DOUBLE DROP DUAL EACH ELSE ELSEIF ENCLOSED ESCAPED EXISTS EXIT EXPLAIN FALSE FETCH FLOAT FLOAT4 FLOAT8 FOR FORCE FOREIGN FROM FULLTEXT GOTO GRANT GROUP HAVING HIGH_PRIORITY HOUR_MICROSECOND HOUR_MINUTE HOUR_SECOND IF IGNORE IN INDEX INFILE INNER INOUT INSENSITIVE INSERT INT INT1 INT2 INT3 INT4 INT8 INTEGER INTERVAL INTO IS ITERATE JOIN KEY KEYS KILL LABEL LEADING LEAVE LEFT LIKE LIMIT LINEAR LINES LOAD LOCALTIME LOCALTIMESTAMP LOCK LONG LONGBLOB LONGTEXT LOOP LOW_PRIORITY MATCH MEDIUMBLOB MEDIUMINT MEDIUMTEXT MIDDLEINT MINUTE_MICROSECOND MINUTE_SECOND MOD MODIFIES NATURAL NOT NO_WRITE_TO_BINLOG NULL NUMERIC ON OPTIMIZE OPTION OPTIONALLY OR ORDER OUT OUTER OUTFILE PRECISION PRIMARY PROCEDURE PURGE RAID0 RANGE READ READS REAL REFERENCES REGEXP RELEASE RENAME REPEAT REPLACE REQUIRE RESTRICT RETURN REVOKE RIGHT RLIKE SCHEMA SCHEMAS SECOND_MICROSECOND SELECT SENSITIVE SEPARATOR SET SHOW SMALLINT SPATIAL SPECIFIC SQL SQLEXCEPTION SQLSTATE SQLWARNING SQL_BIG_RESULT SQL_CALC_FOUND_ROWS SQL_SMALL_RESULT SSL STARTING STRAIGHT_JOIN TABLE TERMINATED THEN TINYBLOB TINYINT TINYTEXT TO TRAILING TRIGGER TRUE UNDO UNION UNIQUE UNLOCK UNSIGNED UPDATE USAGE USE USING UTC_DATE UTC_TIME UTC_TIMESTAMP VALUES VARBINARY VARCHAR VARCHARACTER VARYING WHEN WHERE WHILE WITH WRITE X509 XOR YEAR_MONTH ZEROFILL","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"Spring Data JPA实体类常用注解","slug":"425","date":"2022-01-21T09:46:40.000Z","updated":"2022-04-14T01:46:37.662Z","comments":true,"path":"425.html","link":"","permalink":"https://blog.zoutl.cn/425.html","excerpt":"","text":"下面展示的是我使用到的注解（可以满足基本的开发情况），其它注解等用到的时候再补充 @Entity标识实体类是JPA实体，告诉JPA在程序运行时生成实体类对应表 @Table使用属性name设置实体类在数据库所对应的表名 @Id标识类里所在变量为主键 @GeneratedValue设置主键生成策略，此方式依赖于具体的数据库，strategy=GenerationType.IDENTITY时主键策略为自增 @Column表示属性所对应字段名进行个性化设置，name属性的值为在数据库的字段名称（使用这个属性时需要配置application.yml，不然无法生效，代码如下所示），length属性的值为字段的长度 @Transient表示属性并非数据库表字段的映射,ORM框架将忽略该属性 实体类代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ledao.entity;import lombok.Data;import javax.persistence.*;/** * 用户实体类 * * @author LeDao * @company * @create 2022-01-21 16:26 */@Data@Entity@Table(name = &quot;t_user&quot;)public class User &#123; /** * 编号 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; /** * 用户名 */ @Column(name = &quot;userName&quot;, length = 100) private String userName; /** * 昵称 */ @Column(name = &quot;nickName&quot;, length = 100) private String nickName; /** * 密码 */ @Column(length = 100) private String password; /** * 用户类型,1代表管理员,2代表普通用户 */ private Integer type; /** * 用户状态,1代表正常,2代表被封禁 */ private Integer state; /** * 是否可借书 */ @Column(name = &quot;isBorrow&quot;) private Integer isBorrow;&#125;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://blog.zoutl.cn/tags/Spring-Data-JPA/"}]},{"title":"Spring Boot引入Spring Data JPA","slug":"424","date":"2022-01-21T09:10:02.000Z","updated":"2022-04-14T11:27:36.055Z","comments":true,"path":"424.html","link":"","permalink":"https://blog.zoutl.cn/424.html","excerpt":"","text":"引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt;&lt;/dependency&gt; application.yml1234567891011121314151617181920212223server: port: 80 servlet: context-path: / tomcat: uri-encoding: UTF-8# 数据源配置spring: application: name: microservice-student datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_bookmanagesystem?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: 123456 jpa: hibernate: ddl-auto: update naming: physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl #配置后可以通过@Column注解的name属性自定义数据库的字段名称 show-sql: true 实体类使用了lombok，如果不想使用就自行生成setter和getter方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ledao.entity;import lombok.Data;import javax.persistence.*;/** * 用户实体类 * * @author LeDao * @company * @create 2022-01-21 16:26 */@Data@Entity@Table(name = &quot;t_user&quot;)public class User &#123; /** * 编号 */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; /** * 用户名 */ @Column(name = &quot;userName&quot;, length = 100) private String userName; /** * 昵称 */ @Column(name = &quot;nickName&quot;, length = 100) private String nickName; /** * 密码 */ @Column(length = 100) private String password; /** * 用户类型,1代表管理员,2代表普通用户 */ private Integer type; /** * 用户状态,1代表正常,2代表被封禁 */ private Integer state; /** * 是否可借书 */ @Column(name = &quot;isBorrow&quot;) private Integer isBorrow;&#125; Repository接口1234567891011121314package com.ledao.repository;import com.ledao.entity.User;import org.springframework.data.jpa.repository.JpaRepository;/** * 用户Repository接口 * * @author LeDao * @company * @create 2022-01-21 17:01 */public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 测试12345678910111213141516171819202122232425262728package com.ledao;import com.ledao.entity.User;import com.ledao.repository.UserRepository;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;@SpringBootTestclass BookManageSystemApplicationTests &#123; @Resource private UserRepository userRepository; @Test void contextLoads() &#123; User user = new User(); user.setUserName(&quot;admin&quot;); user.setNickName(&quot;乐道&quot;); user.setPassword(&quot;admin&quot;); user.setType(1); user.setState(1); user.setIsBorrow(1); userRepository.save(user); &#125;&#125; 结果如果数据库的t_user表中新增了一条记录，说明引入Spring Data JPA成功","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://blog.zoutl.cn/tags/Spring-Data-JPA/"}]},{"title":"IntelliJ IDEA插件EditStarters报错：Request failure! Your spring boot version may not be supported的解决办法","slug":"423","date":"2022-01-21T08:10:28.000Z","updated":"2022-04-14T02:43:19.991Z","comments":true,"path":"423.html","link":"","permalink":"https://blog.zoutl.cn/423.html","excerpt":"","text":"报错原因插件不支持当前使用的Spring Boot版本 解决办法将Spring Boot的版本改为2.6.2即可，其它版本我没有试过，如果要使用其它版本的Spring Boot，请自行尝试 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"HTML特殊字符编码对照表","slug":"422","date":"2022-01-21T05:48:28.000Z","updated":"2022-04-10T15:34:16.534Z","comments":true,"path":"422.html","link":"","permalink":"https://blog.zoutl.cn/422.html","excerpt":"","text":"特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码 特殊符号 命名实体 十进制编码 Α &amp;Alpha; &amp;#913; Β &amp;Beta; &amp;#914; Γ &amp;Gamma; &amp;#915; Δ &amp;Delta; &amp;#916; Ε &amp;Epsilon; &amp;Epsilon; Ζ &amp;Zeta; &amp;#918; Η &amp;Eta; &amp;#919; Θ &amp;Theta; &amp;#920; Ι &amp;Iota; &amp;#921; Κ &amp;Kappa; &amp;#922; Λ &amp;Lambda; &amp;#923; Μ &amp;Mu; &amp;#924; Ν &amp;Nu; &amp;#925; Ξ &amp;Xi; &amp;#926; Ο &amp;Omicron; &amp;#927; Π &amp;Pi; &amp;#928; Ρ &amp;Rho; &amp;#929; Σ &amp;Sigma; &amp;#931; Τ &amp;Tau; &amp;#932; Υ &amp;Upsilon; &amp;#933; Φ &amp;Phi; &amp;#934; Χ &amp;Chi; &amp;#935; Ψ &amp;Psi; &amp;#936; Ω &amp;Omega; &amp;#937; α &amp;alpha; &amp;#945; β &amp;beta; &amp;#946; γ &amp;gamma; &amp;#947; δ &amp;delta; &amp;#948; ε &amp;epsilon; &amp;#949; ζ &amp;zeta; &amp;#950; η &amp;eta; &amp;#951; θ &amp;theta; &amp;#952; ι &amp;iota; &amp;#953; κ &amp;kappa; &amp;#954; λ &amp;lambda; &amp;#955; μ &amp;mu; &amp;#956; ν &amp;nu; &amp;#957; ξ &amp;xi; &amp;#958; ο &amp;omicron; &amp;#959; π &amp;pi; &amp;#960; ρ &amp;rho; &amp;#961; ς &amp;sigmaf; &amp;#962; σ &amp;sigma; &amp;#963; τ &amp;tau; &amp;#964; υ &amp;upsilon; &amp;#965; φ &amp;phi; &amp;#966; χ &amp;chi; &amp;#967; ψ &amp;psi; &amp;#968; ω &amp;omega; &amp;#969; ϑ &amp;thetasym; &amp;#977; ϒ &amp;upsih; &amp;#978; ϖ &amp;piv; &amp;#982; • &amp;bull; &amp;#8226; … &amp;hellip; &amp;#8230; ′ &amp;prime; &amp;#8242; ″ &amp;Prime; &amp;#8243; ‾ &amp;oline; &amp;#8254; ⁄ &amp;frasl; &amp;#8260; ℘ &amp;weierp; &amp;#8472; ℑ &amp;image; &amp;#8465; ℜ &amp;real; &amp;#8476; ™ &amp;trade; &amp;#8482; ℵ &amp;alefsym; &amp;#8501; ← &amp;larr; &amp;#8592; ↑ &amp;uarr; &amp;#8593; → &amp;rarr; &amp;#8594; ↓ &amp;darr; &amp;#8595; ↔ &amp;harr; &amp;#8596; ↵ &amp;crarr; &amp;#8629; ⇐ &amp;lArr; &amp;#8656; ⇑ &amp;uArr; &amp;#8657; ⇒ &amp;rArr; &amp;#8658; ⇓ &amp;dArr; &amp;#8659; ⇔ &amp;hArr; &amp;#8660; ∀ &amp;forall; &amp;#8704; ∂ &amp;part; &amp;#8706; ∃ &amp;exist; &amp;#8707; ∅ &amp;empty; &amp;#8709; ∇ &amp;nabla; &amp;#8711; ∈ &amp;isin; &amp;#8712; ∉ &amp;notin; &amp;#8713; ∋ &amp;ni; &amp;#8715; ∏ &amp;prod; &amp;#8719; ∑ &amp;sum; &amp;#8722; − &amp;minus; &amp;#8722; ∗ &amp;lowast; &amp;#8727; √ &amp;radic; &amp;#8730; ∝ &amp;prop; &amp;#8733; ∞ &amp;infin; &amp;#8734; ∠ &amp;ang; &amp;#8736; ∧ &amp;and; &amp;#8869; ∨ &amp;or; &amp;#8870; ∩ &amp;cap; &amp;#8745; ∪ &amp;cup; &amp;#8746; ∫ &amp;int; &amp;#8747; ∴ &amp;there4; &amp;#8756; ∼ &amp;sim; &amp;#8764; ≅ &amp;cong; &amp;#8773; ≈ &amp;asymp; &amp;#8773; ≠ &amp;ne; &amp;#8800; ≡ &amp;equiv; &amp;#8801; ≤ &amp;le; &amp;#8804; ≥ &amp;ge; &amp;#8805; ⊂ &amp;sub; &amp;#8834; ⊃ &amp;sup; &amp;#8835; ⊄ &amp;nsub; &amp;#8836; ⊆ &amp;sube; &amp;#8838; ⊇ &amp;supe; &amp;#8839; ⊕ &amp;oplus; &amp;#8853; ⊗ &amp;otimes; &amp;#8855; ⊥ &amp;perp; &amp;#8869; ⋅ &amp;sdot; &amp;#8901; ⌈ &amp;lceil; &amp;#8968; ⌉ &amp;rceil; &amp;#8969; ⌊ &amp;lfloor; &amp;#8970; ⌋ &amp;rfloor; &amp;#8971; ◊ &amp;loz; &amp;#9674; ♠ &amp;spades; &amp;#9824; ♣ &amp;clubs; &amp;#9827; ♥ &amp;hearts; &amp;#9829; ♦ &amp;diams; &amp;#9830; &amp;nbsp; &amp;#160; ¡ &amp;iexcl; &amp;#161; ¢ &amp;cent; &amp;#162; £ &amp;pound; &amp;#163; ¤ &amp;curren; &amp;#164; ¥ &amp;yen; &amp;#165; ¦ &amp;brvbar; &amp;#166; § &amp;sect; &amp;#167; ¨ &amp;uml; &amp;#168; © &amp;copy; &amp;#169; ª &amp;ordf; &amp;#170; « &amp;laquo; &amp;#171; ¬ &amp;not; &amp;#172; ­ &amp;shy; &amp;#173; ® &amp;reg; &amp;#174; ¯ &amp;macr; &amp;#175; ° &amp;deg; &amp;#176; ± &amp;plusmn; &amp;#177; ² &amp;sup2; &amp;#178; ³ &amp;sup3; &amp;#179; ´ &amp;acute; &amp;#180; µ &amp;micro; &amp;#181 &quot; &amp;quot; &amp;#34; &lt; &amp;lt; &amp;#60; &gt; &amp;gt; &amp;#62; &#39; &amp;#39;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"EasyUI Combobox组合框从Java后端获取数据","slug":"421","date":"2022-01-19T09:08:17.000Z","updated":"2022-04-14T01:40:26.736Z","comments":true,"path":"421.html","link":"","permalink":"https://blog.zoutl.cn/421.html","excerpt":"","text":"代码HTML代码editable=&quot;true&quot;代表该组合框可以编辑，valueField:&#39;id&#39;代表每个选项的值对应的是goodsType的id，textField:&#39;name&#39;代表我们看到的文本是goodsType的name 1&amp;nbsp;商品类型:&amp;nbsp;&lt;input class=&quot;easyui-combobox&quot; id=&quot;s_goodsTypeId&quot; style=&quot;width: 140px&quot; editable=&quot;true&quot; data-options=&quot;panelHeight:&#x27;auto&#x27;,valueField:&#x27;id&#x27;,textField:&#x27;name&#x27;,url:&#x27;/admin/goodsType/comboList&#x27;&quot;/&gt; Java代码下面只展示GoodsType实体类和组合框请求的方法comboList，GoodsTypeMapper、GoodsTypeService和GoodsTypeServiceImpl三个类就不展示了 GoodsType实体类1234567891011121314151617181920212223242526272829303132333435363738package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * 商品类别实体类 * * @author LeDao * @company * @create 2022-01-15 21:08 */@Data@TableName(value = &quot;t_goods_type&quot;)public class GoodsType &#123; /** * 编号 */ @TableId private Integer id; /** * 名称 */ private String name; /** * 排序 */ @TableField(value = &quot;sortNum&quot;) private Integer sortNum; /** * 分类下商品数量 */ @TableField(exist = false) private Integer goodsNum;&#125; 请求的方法comboList1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ledao.controller.admin;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.ledao.entity.Goods;import com.ledao.entity.GoodsType;import com.ledao.service.GoodsService;import com.ledao.service.GoodsTypeService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 后台商品类别Controller层 * * @author LeDao * @company * @create 2022-01-15 21:17 */@RestController@RequestMapping(&quot;/admin/goodsType&quot;)public class GoodsTypeAdminController &#123; @Resource private GoodsTypeService goodsTypeService; @Resource private GoodsService goodsService; /** * 下拉框模糊查询商品类别 * * @param q * @return */ @RequestMapping(&quot;/comboList&quot;) public List&lt;GoodsType&gt; comboList(String q) &#123; if (q == null) &#123; q = &quot;&quot;; &#125; QueryWrapper&lt;GoodsType&gt; goodsTypeQueryWrapper = new QueryWrapper&lt;&gt;(); goodsTypeQueryWrapper.like(&quot;name&quot;, q); return goodsTypeService.list(goodsTypeQueryWrapper); &#125;&#125; 效果 注意事项如果设置了组合框可以编辑且组合框的值为数字，那么就需要判断用户的输入是否正确（即：判断组合框获取到的值是否为数字），这是因为：如果组合框看到的文本在数据库中不存在时我们通过组合框获取到的值为在组合框看到的文本，这时向后端传入一个不是数字的字符串，而后端要接收的却是数字，那么后端就会报错","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"EasyUI","slug":"EasyUI","permalink":"https://blog.zoutl.cn/tags/EasyUI/"}]},{"title":"校园二手交易平台","slug":"420","date":"2022-01-18T16:04:47.000Z","updated":"2022-04-14T11:17:51.088Z","comments":true,"path":"420.html","link":"","permalink":"https://blog.zoutl.cn/420.html","excerpt":"","text":"项目地址GitHub地址：a6678696/SecondHandTrade: 校园二手交易平台 (github.com) 使用的技术本项目核心技术采用Spring Boot+Mybatis-Plus；开发工具 idea；数据库MySQL5.6；模版引擎采用的是Thymeleaf；在线编辑器CKEditor；基于JavaMail实现用QQ邮箱发送邮件；前台界面采用了Bootstrap4框架；后台界面采用了jQuery EasyUI框架；Redis存储用户购物车信息；Gson处理JSON数据；Quartz定时任务； 功能介绍普通用户 添加商品到购物车、预订商品 前台登录、通过邮箱接受验证码注册和找回密码 查看和修改个人信息 发布商品和管理自己发布的商品（修改、删除、查询、上架、下架、完成交易、取消商品被预订） 管理自己的联系方式（添加、修改、删除、查询） 查看预订记录以及取消预订 查看自己的消息 给管理员留言以及管理自己的留言（查询、修改、删除） 管理员 管理普通用户（添加、修改、删除、查询、封禁与取消封禁） 商品类别管理（添加、修改、删除、查询） 商品管理（查询、删除、审核商品、推荐商品） 管理用户联系方式（修改、删除、查询） 管理用户留言（答复用户的留言、删除、查询） 管理首页的轮播图（添加、修改、删除、查询） 管理公告（添加、修改、删除、查询） 管理预订记录（查询、删除） 管理用户消息（查询、删除） 安全退出后台 系统 每隔60分钟自动将推荐时间过期的商品的推荐状态设置为不推荐 图片展示前台首页 商品分类 查看用户求购 搜索商品 查看商品详情 登录 注册 找回密码 查看公告详情 个人中心 查看个人信息 修改个人信息 管理自己的联系方式 发布商品 管理我的商品 查看自己的消息 留言管理 给管理员留言 我的购物车 注销登录 后台首页 用户管理 商品类别管理 商品管理 用户联系方式管理 用户留言管理 轮播图管理 公告管理 预订记录管理 用户消息管理 安全退出登录","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"HTML取消页面的左右滚动条","slug":"419","date":"2022-01-18T13:40:07.000Z","updated":"2022-03-28T16:39:02.514Z","comments":true,"path":"419.html","link":"","permalink":"https://blog.zoutl.cn/419.html","excerpt":"","text":"要取消滚动条，只需要将&lt;body&gt;标签样式的overflow-x或overflow-y设置为hidden即可，其中overflow-x为左右滚动条，overflow-y为上下滚动条，代码示例如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body style=&quot;overflow-x: hidden&quot;&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"CKEditor设置编辑器的宽度以及高度","slug":"418","date":"2022-01-18T01:57:26.000Z","updated":"2022-04-14T01:39:54.220Z","comments":true,"path":"418.html","link":"","permalink":"https://blog.zoutl.cn/418.html","excerpt":"","text":"概述设置CKEditor编辑器宽度和高度的方法有两种： 设置textarea标签的宽度和高度 在CKEditor替换textarea的JavaScript代码中设置 实现设置textarea标签的宽度和高度rows属性是高度，cols属性是宽度，它们的值没有单位 1&lt;textarea id=&quot;content&quot; name=&quot;content&quot; rows=&quot;30&quot; cols=&quot;80&quot;&gt;&lt;/textarea&gt; 在CKEditor替换textarea的JavaScript代码中设置如果上面的方法没有用，就使用此方法 123&lt;script type=&quot;text/javascript&quot;&gt; CKEDITOR.replace(&quot;contentGoods&quot;, &#123;height: &#x27;240px&#x27;, width: &#x27;100%&#x27;&#125;);&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CKEditor","slug":"CKEditor","permalink":"https://blog.zoutl.cn/tags/CKEditor/"}]},{"title":"使用Thymeleaf的项目搜索时回显搜索的条件","slug":"417","date":"2022-01-17T13:23:35.000Z","updated":"2022-04-14T01:48:00.417Z","comments":true,"path":"417.html","link":"","permalink":"https://blog.zoutl.cn/417.html","excerpt":"","text":"概述搜索后的新页面，一般情况下搜索条件的值都会被设置为空，但是如果想修改上一次搜索的条件再搜索，就需要获取到上一次的搜索条件 实现过程代码 HTML代码（只有搜索form标签的代码，显示数据的代码已删除） th:value获取上一次搜索条件的值 123456789101112131415161718192021222324252627282930313233343536&lt;form action=&quot;/toGoodsManagePage&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;row&quot; style=&quot;margin-left: 3px&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;nameSearchGoods&quot; name=&quot;name&quot; style=&quot;width: 200px&quot; th:value=&quot;$&#123;name&#125;&quot; placeholder=&quot;请输入商品名称...&quot;&gt; &lt;select id=&quot;goodsTypeIdSearchGoods&quot; name=&quot;goodsTypeId&quot; th:value=&quot;$&#123;goodsTypeId&#125;&quot; style=&quot;width: 200px;margin-left: 2px&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;&quot;&gt;选择商品类别...&lt;/option&gt; &lt;div th:each=&quot;goodsType:$&#123;goodsTypeList&#125;&quot;&gt; &lt;option th:text=&quot;$&#123;goodsType.name&#125;&quot; th:value=&quot;$&#123;goodsType.id&#125;&quot; th:selected=&quot;$&#123;goodsTypeId==goodsType.id&#125;&quot;&gt;&lt;/option&gt; &lt;/div&gt; &lt;/select&gt; &lt;select id=&quot;stateSearchGoods&quot; name=&quot;state&quot; th:value=&quot;$&#123;state&#125;&quot; style=&quot;width: 200px;margin-left: 2px&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;&quot;&gt;选择商品状态...&lt;/option&gt; &lt;div&gt; &lt;option value=&quot;0&quot; th:selected=&quot;$&#123;state==0&#125;&quot;&gt;未审核&lt;/option&gt; &lt;option value=&quot;1&quot; th:selected=&quot;$&#123;state==1&#125;&quot;&gt;上架中&lt;/option&gt; &lt;option value=&quot;2&quot; th:selected=&quot;$&#123;state==2&#125;&quot;&gt;审核不通过&lt;/option&gt; &lt;option value=&quot;3&quot; th:selected=&quot;$&#123;state==3&#125;&quot;&gt;已下架&lt;/option&gt; &lt;option value=&quot;4&quot; th:selected=&quot;$&#123;state==4&#125;&quot;&gt;交易完成&lt;/option&gt; &lt;/div&gt; &lt;/select&gt; &lt;select id=&quot;isRecommendSearchGoods&quot; name=&quot;isRecommend&quot; th:value=&quot;$&#123;recommend&#125;&quot; style=&quot;width: 200px;margin-left: 2px&quot; class=&quot;form-control&quot;&gt; &lt;option value=&quot;&quot;&gt;商品是否被推荐...&lt;/option&gt; &lt;div&gt; &lt;option value=&quot;0&quot; th:selected=&quot;$&#123;recommend==0&#125;&quot;&gt;不推荐&lt;/option&gt; &lt;option value=&quot;1&quot; th:selected=&quot;$&#123;recommend==1&#125;&quot;&gt;被推荐&lt;/option&gt; &lt;/div&gt; &lt;/select&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary status-icon hint--top&quot; style=&quot;margin-left: 2px&quot; aria-label=&quot;搜索&quot;&gt;&lt;i class=&quot;fa fa-search&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;a href=&quot;javascript:resetSearchGoodsValue()&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-info status-icon hint--top&quot; aria-label=&quot;重置&quot; style=&quot;margin-left: 2px&quot;&gt;&lt;i class=&quot;fa fa-rotate-right&quot;&gt;&lt;/i&gt;&lt;/button&gt;&lt;/a&gt; &lt;/div&gt;&lt;/form&gt; Java代码（只保留了向页面传值的代码，其它业务代码已删除） ModelAndView.addObject(String 参数一,String 参数二)方法向页面传值，参数一为键，参数二为值 123456789101112131415161718192021222324252627282930/** * 跳转到我的商品管理界面 * * @return */@RequestMapping(&quot;/toGoodsManagePage&quot;)public ModelAndView toGoodsManagePage(HttpSession session, Goods searchGoods) &#123; ModelAndView mav = new ModelAndView(); if (searchGoods.getName() != null) &#123; goodsQueryWrapper.like(&quot;name&quot;, searchGoods.getName()); mav.addObject(&quot;name&quot;, searchGoods.getName()); &#125; if (searchGoods.getGoodsTypeId() != null) &#123; goodsQueryWrapper.eq(&quot;goodsTypeId&quot;, searchGoods.getGoodsTypeId()); mav.addObject(&quot;goodsTypeId&quot;, searchGoods.getGoodsTypeId()); &#125; if (searchGoods.getState() != null) &#123; goodsQueryWrapper.eq(&quot;state&quot;, searchGoods.getState()); mav.addObject(&quot;state&quot;, searchGoods.getState()); &#125; if (searchGoods.getIsRecommend() != null) &#123; goodsQueryWrapper.eq(&quot;isRecommend&quot;, searchGoods.getIsRecommend()); mav.addObject(&quot;recommend&quot;, searchGoods.getIsRecommend()); &#125; mav.addObject(&quot;title&quot;, &quot;我的商品管理--LeDao校园二手交易平台&quot;); mav.addObject(&quot;mainPage&quot;, &quot;page/goodsManage&quot;); mav.addObject(&quot;mainPageKey&quot;, &quot;#b&quot;); mav.setViewName(&quot;index&quot;); return mav;&#125; 效果 CKEDITOR.replace(\"contentGoods\", {height: '240px', width: '100%'});javascript","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://blog.zoutl.cn/tags/Thymeleaf/"}]},{"title":"Thymeleaf在一个页面嵌入另一个页面","slug":"416","date":"2022-01-17T11:22:45.000Z","updated":"2022-04-14T01:48:07.983Z","comments":true,"path":"416.html","link":"","permalink":"https://blog.zoutl.cn/416.html","excerpt":"","text":"用法向一个页面嵌入其它页面的情况一般有两种： 被嵌入页面的名称不确定 这种情况需要后端的介入，被嵌入页面的名称由后端传入，一般情况下使用Thymeleaf的项目都有一个主页面（要嵌入其它页面的页面，通常命名为index.html），我们可以在主页面上引入各种CSS、JS文件，被嵌入的页面也可以使用这些CSS、JS文件，这样做的好处是：统一管理CSS、JS文件 被嵌入页面的名称已确定 这种情况不需要后端，被嵌入页面的名称直接写在要嵌入页面的页面上，如果多个页面上都有一部分代码是相同的，那么我们就可以将相同的代码抽取出来放到一个新页面上（也就是被嵌入的页面），然后在要嵌入的页面上嵌入新页面即可，这样做的好处是：使用嵌入页面前如果需要修改就要修改多个地方，而使用嵌入页面后只需要修改一个地方即可 实现过程名称不确定 主页面index.html（要嵌入页面的页面） 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;!--suppress ALL--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title th:text=&quot;$&#123;title&#125;&quot;&gt;&lt;/title&gt; &lt;link rel=&quot;short icon&quot; th:href=&quot;@&#123;/static/images/favicon.ico&#125;&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/static/css/hint.css&#125;&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script th:src=&quot;@&#123;/static/js/my.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/ckeditor/ckeditor.js&#125;&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;width: 92%;margin-left: 4%&quot;&gt; &lt;div th:include=&quot;$&#123;mainPage&#125;::$&#123;mainPageKey&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 登录页面login.html（被嵌入的页面） 12345678910111213&lt;!DOCTYPE html&gt;&lt;!--suppress ALL--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;b&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; java代码 mainPage为被嵌入页面路径及名称，mainPageKey为被嵌入页面的&lt;div&gt;标签的id，index为主页面index.html的名称（省略后缀名即可） 1234567891011121314/** * 跳转到用户登录界面 * * @return */@RequestMapping(&quot;/toLoginPage&quot;)public ModelAndView toLoginPage() &#123; ModelAndView mav = new ModelAndView(); mav.addObject(&quot;title&quot;, &quot;用户登录--LeDao校园二手交易平台&quot;); mav.addObject(&quot;mainPage&quot;, &quot;page/login&quot;); mav.addObject(&quot;mainPageKey&quot;, &quot;#b&quot;); mav.setViewName(&quot;index&quot;); return mav;&#125; 名称已确定 要嵌入页面的页面（menuPersonalHubs为被嵌入页面的名称） 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;!--suppress ALL--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;b&quot;&gt; &lt;div class=&quot;row&quot; style=&quot;margin-top: 5px&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;div th:include=&quot;common/menuPersonalHubs::#m&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-9&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; menuPersonalHubs.html（被嵌入的页面） 12345678910111213&lt;!DOCTYPE html&gt;&lt;!--suppress ALL--&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;m&quot;&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; PS.被嵌入页面的&lt;div&gt;标签的id一定要和实际的对应哦，不然会出错","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://blog.zoutl.cn/tags/Thymeleaf/"}]},{"title":"改变Windows系统文件夹的样式及颜色","slug":"415","date":"2022-01-15T03:18:06.000Z","updated":"2022-04-14T11:26:57.449Z","comments":true,"path":"415.html","link":"","permalink":"https://blog.zoutl.cn/415.html","excerpt":"","text":"安装软件下载链接百度网盘链接：https://pan.baidu.com/s/1wiMAMEtUgJ_lQyqo-izIMA 提取码：n0vf 安装解压后即可运行，解压后的文件夹有两个exe可执行文件：FolderPainter.exe和FolderPainter_x64.exe，64位系统使用FolderPainter_x64.exe，其它使用FolderPainter_x64.exe 操作步骤设置软件语言为中文打开软件后，依次选择右下角的Menu、Languages、Chinese-Simplified即可 安装颜色、样式、图标要安装哪个就在左侧的选择框中给哪个打勾（下图只安装了颜色），然后点击安装即可（卸载的方法也一样） 使用右键点击某个文件夹，然后选择文件夹颜色再选中自己喜欢的颜色即可，如果要恢复原状就选中默认文件夹图标","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"MyBatis-Plus更新字段时无法设置为null值","slug":"414","date":"2022-01-12T10:31:10.000Z","updated":"2022-04-14T02:20:19.584Z","comments":true,"path":"414.html","link":"","permalink":"https://blog.zoutl.cn/414.html","excerpt":"","text":"问题概述我们在更新某个用户信息时，如果要将该用户信息的某个字段更新为null值，直接设置用户实体的对应属性为null值是不行的，因为MyBatis-Plus默认看到null值就不更新该字段 解决办法在实体类的对应属性上添加注解@TableField(updateStrategy = FieldStrategy.IGNORED) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ledao.entity;import com.baomidou.mybatisplus.annotation.FieldStrategy;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;import java.util.Date;/** * 留言实体类 * * @author LeDao * @company * @create 2022-01-12 13:40 */@Data@TableName(value = &quot;t_contact&quot;)public class Contact &#123; /** * 编号 */ @TableId private Integer id; /** * 留言内容 */ private String content; /** * 答复 */ @TableField(updateStrategy = FieldStrategy.IGNORED) private String reply; /** * 留言时间 */ private Date time; /** * 留言用户id（普通用户） */ @TableField(value = &quot;userId&quot;) private Integer userId; /** * 回复用户id（管理员） */ @TableField(value = &quot;userIdReply&quot;) private Integer userIdReply;&#125;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"关于Ajax无法给请求方法外面的变量赋值","slug":"413","date":"2022-01-10T03:37:14.000Z","updated":"2022-04-10T04:36:12.379Z","comments":true,"path":"413.html","link":"","permalink":"https://blog.zoutl.cn/413.html","excerpt":"","text":"原因$.ajax默认是异步的， 异步回调在js主线程执行结束后才会被执行 解决办法 如果确实需要获取ajax的结果赋值给请求方法外面的变量，那么可以ajax多加一个参数：async=false，就会同步执行 Ajax完整请求代码1234567891011121314function checkRegisterValue() &#123; let imageCode; $.ajax(&#123; url: &quot;/user/getRegisterCode&quot;, type: &quot;get&quot;, async: false, success: function (result) &#123; if (result.success) &#123; imageCode = result.imageCode; &#125; &#125; &#125;);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"IntelliJ IDEA执行Maven命令时报错：No valid Maven installation found. Either set the homedirectory in the configuration dialog or set the M2_HOME environment variable on your system.的解决办法","slug":"412","date":"2022-01-06T14:11:55.000Z","updated":"2022-04-14T02:44:02.226Z","comments":true,"path":"412.html","link":"","permalink":"https://blog.zoutl.cn/412.html","excerpt":"","text":"报错原因idea配置的Maven安装路径和实际的不符 解决办法打开idea设置的Maven配置，修改Maven home path为本机的Maven安装路径即可（一定要是bin文件夹的上层目录）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"解决：GitHub将Java项目判断为JavaScript项目","slug":"411","date":"2022-01-03T15:15:03.000Z","updated":"2022-04-14T01:53:22.799Z","comments":true,"path":"411.html","link":"","permalink":"https://blog.zoutl.cn/411.html","excerpt":"","text":"原因GitHub判断项目类型，主要是通过分析什么类型的文件占比最高，例如：如果JavaScript文件占比最高则GitHub就会认定项目为JavaScript项目 解决办法 在本地仓库新建一个名称为.gitattributes的文件，文件内容如下： 1234*.js linguist-language=java*.css linguist-language=java*.html linguist-language=java*.jsp linguist-language=java 然后push到GitHub即可 PS.不要直接在GitHub仓库新建这个文件，不然后期提交会造成：远程仓库和本地仓库的内容不一致（报错：Push to origin/master was rejected），这个报错的解决办法查看博客：idea 提交代码到 GitHub 报错：Push to origin/master was rejected | LeDao 的博客 (zoutl.cn)","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"IntelliJ IDEA提交代码到GitHub报错：Push to origin/master was rejected的解决办法","slug":"410","date":"2022-01-03T15:03:04.000Z","updated":"2022-04-14T02:43:57.472Z","comments":true,"path":"410.html","link":"","permalink":"https://blog.zoutl.cn/410.html","excerpt":"","text":"报错原因远程仓库和本地仓库的内容不一致 解决办法 打开Git Bash命令，进入本地仓库对应的项目文件夹（即：.git文件夹所在目录，右击项目文件夹选择Git Bash Here） 输入以下命令：（可能会打开一个文件，输入:q并按回车键退出即可） 1git pull origin master --allow-unrelated-histories 然后重新push到GitHub即可 PS.这个错误是可以避免的，只要不直接修改远程库的文件即可。如果要修改就去修改本地仓库的文件，然后push到远程库","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"IntelliJ IDEA配置远程调试","slug":"409","date":"2022-01-02T06:56:23.000Z","updated":"2022-04-14T02:43:53.489Z","comments":true,"path":"409.html","link":"","permalink":"https://blog.zoutl.cn/409.html","excerpt":"","text":"概述所谓远程调试，是指将Java项目打包成war或者jar包并且部署后，在idea中进行调试 实现过程idea配置远程JVM调试 打开添加配置界面 选择Remote JVM Debug 填写相关配置 Name随意填写，Host填运行Java项目的服务器IP，Post填项目所在端口号，Use moudule classpath选择调试的项目模块，其它的配置和下图一样即可 配置远程调试接口Java项目打包有两种方式：①war包 ②jar包，所以配置方式也不同 当项目打包成war包 修改Tomcat的bin文件夹的catalina.sh，在下图的位置添加以下代码：（调试端口为5005，记得开放防火墙的5005端口，如果是云服务器还需要配置安全组规则） 1JAVA_OPTS=&quot;$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005&quot; 当项目打包成jar包，使用以下命令部署项目 1java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 web.jar 测试运行好项目后，选择刚刚配置好的Debug服务，然后点击Debug按钮即可","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"Java获取程序运行时间","slug":"408","date":"2021-12-26T13:02:39.000Z","updated":"2022-04-14T02:20:06.341Z","comments":true,"path":"408.html","link":"","permalink":"https://blog.zoutl.cn/408.html","excerpt":"","text":"问题描述有时候我们需要获取某段代码的运行时间，以便和修改后的代码对比，看看新代码的性能是否得到提升 解决办法具体解决方法为，在执行该段代码前获取当前时间，执行完该段代码后再次获取当前时间，后面的时间减去前面的时间即可得到程序运行的时间，时间单位越小越精确 获取当前时间一般有两种方式： 以毫秒为单位 使用System.currentTimeMillis() 以纳秒为单位 使用System.nanoTime() 代码实现以毫秒为单位 Java代码 123456789101112131415161718package com.ledao;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) &#123; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long endTime = System.currentTimeMillis(); System.out.println(&quot;程序运行时间为:&quot; + (endTime - startTime)+&quot;毫秒&quot;); &#125;&#125; 结果 以纳秒为单位 Java代码 123456789101112131415161718package com.ledao;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) &#123; long startTime = System.nanoTime(); for (int i = 0; i &lt; 10000; i++) &#123; System.out.println(i); &#125; long endTime = System.nanoTime(); System.out.println(&quot;程序运行时间为:&quot; + (endTime - startTime) + &quot;纳秒&quot;); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java数组排序","slug":"407","date":"2021-12-25T05:55:15.000Z","updated":"2022-04-14T02:20:03.836Z","comments":true,"path":"407.html","link":"","permalink":"https://blog.zoutl.cn/407.html","excerpt":"","text":"升序排序 使用Arrays工具类的sort方法，只有一个参数，参数为要排序的数组 12345678910111213141516171819package com.ledao;import java.util.Arrays;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) &#123; int[] nums = new int[]&#123;2, 1, 6, 3, 9&#125;; Arrays.sort(nums); for (int num : nums) &#123; System.out.print(num + &quot; &quot;); &#125; &#125;&#125; 降序排序 使用Arrays工具类的sort方法，有两个参数，参数一为要排序的数组，参数二为比较器（Collections.reverseOrder()方法返回的比较器），注意数组的类型为Integer而不是int 1234567891011121314151617181920package com.ledao;import java.util.Arrays;import java.util.Collections;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) &#123; Integer[] nums = new Integer[]&#123;2, 1, 6, 3, 9&#125;; Arrays.sort(nums, Collections.reverseOrder()); for (int num : nums) &#123; System.out.print(num + &quot; &quot;); &#125; &#125;&#125; 使用Arrays工具类的sort方法，有两个参数，参数一为要排序的数组，参数二为比较器（搞一个Comparator的匿名内部类，且重写compare方法），注意数组的类型为Integer而不是int 123456789101112131415161718192021222324252627package com.ledao;import java.util.Arrays;import java.util.Comparator;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) &#123; Integer[] nums = new Integer[]&#123;2, 1, 6, 3, 9&#125;; Comparator&lt;Integer&gt; comparator = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; //o2在前就是降序排序 return o2 - o1; &#125; &#125;; Arrays.sort(nums, comparator); for (int num : nums) &#123; System.out.print(num + &quot; &quot;); &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java上传图片到又拍云","slug":"406","date":"2021-12-23T05:59:31.000Z","updated":"2022-04-16T01:32:36.461Z","comments":true,"path":"406.html","link":"","permalink":"https://blog.zoutl.cn/406.html","excerpt":"","text":"引入依赖123456&lt;!-- https://mvnrepository.com/artifact/com.upyun/java-sdk --&gt;&lt;dependency&gt; &lt;groupId&gt;com.upyun&lt;/groupId&gt; &lt;artifactId&gt;java-sdk&lt;/artifactId&gt; &lt;version&gt;4.2.3&lt;/version&gt;&lt;/dependency&gt; 代码实现获取又拍云的配置信息要获取云存储的服务名称、操作员的用户名、操作员的密码，获取方法查看博客：实现 Typora 自动上传图片到又拍云 | LeDao 的博客 (zoutl.cn) Java代码12345678910111213141516171819202122package com.ledao;import com.upyun.RestManager;import java.io.File;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) throws Exception &#123; //本地图片 File file = new File(&quot;E://lucene/1.jpg&quot;); //参数一为云存储的服务名称、参数二为操作员的用户名、参数三为操作员的密码 RestManager restManager = new RestManager(&quot;ledao3&quot;, &quot;java22&quot;, &quot;hpX6eBSoBYUMs9KCxUim0h&quot;); //第一个参数为上传的文件夹以及最终文件名（最终文件名的后缀名要和本地上传的一样），第二个参数为本地图片的路径，第三个参数为图片上传的参数 restManager.writeFile(&quot;/test/2.jpg&quot;, file, null); &#125;&#125; 结果去又拍云指定文件夹中查看，可以看到图片已经上传成功 PS.更多文件或文件夹操作查看官方文档：又拍云文档中心 (upyun.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"又拍云","slug":"又拍云","permalink":"https://blog.zoutl.cn/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"}]},{"title":"Java压缩图片","slug":"405","date":"2021-12-22T18:26:12.000Z","updated":"2022-04-14T02:19:59.919Z","comments":true,"path":"405.html","link":"","permalink":"https://blog.zoutl.cn/405.html","excerpt":"","text":"引入依赖123456&lt;!-- https://mvnrepository.com/artifact/net.coobird/thumbnailator --&gt;&lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt;&lt;/dependency&gt; 代码实现Java代码12345678910111213141516171819package com.ledao;import net.coobird.thumbnailator.Thumbnails;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;E://lucene/1.jpg&quot;); Thumbnails.of(file).scale(1f).outputQuality(0.5f).toFile(&quot;E://lucene/2.jpg&quot;); &#125;&#125; 参数说明of的参数是原图的路径 scale的参数是图片的大小，值在0到1之间，1f就是原图大小，0.5就是原图的一半大小，这里的大小是指图片的长宽 outputQuality的参数是图片的质量，值也是在0到1，越接近于1质量越好，越接近于0质量越差 toFile的参数是压缩后的图片路径 结果从下图可以看出，2.jpg的大小被压缩了","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"实现Typora自动上传图片到又拍云","slug":"403","date":"2021-12-22T16:01:57.000Z","updated":"2022-03-26T13:16:44.512Z","comments":true,"path":"403.html","link":"","permalink":"https://blog.zoutl.cn/403.html","excerpt":"","text":"问题描述我使用Typora写博客，使用的图床是又拍云云存储。博客用到的图片就需要先把图片上传至又拍云（打开又拍云上传的过程很繁琐），然后在博客中使用。如果可以在使用Typora写博客引用本地图片时，直接上传至又拍云就很方便了 实现过程安装和配置PicGo 下载与安装 下载地址为：PicGo (molunerfinn.com)，下载完成后，直接安装到指定位置即可 PicGo配置又拍云存储路径 需要配置的PicGo参数如下图所示，前4个必须设置，最后一个为存储图片的路径（如果不设置就上传根目录），这些参数的获取步骤继续看下面的步骤 创建自己的云存储服务，下图的服务名称就是设定存储空间名，本步骤可以获取设定存储空间名和设定加速域名 打开云存储服务的配置后，选择存储管理标签页，在页面的最下面添加云存储的操作员，操作员的权限只选择可写入即可，本步骤可以获取操作员以及操作员密码 步骤一： 步骤二： 指定存储路径不填就上传到云存储服务的根目录，如果是根目录下的文件夹就填文件夹名称/，如果是根目录文件夹内的文件夹就填文件夹名称/文件夹名称/，以此类推，此步骤可以获取指定存储路径 这个时候就可以在PicGo的上传区上传图片到又拍云了 Typora配置本地PicGo程序打开Typora的偏好设置的图像设置，然后依次配置下图划红线的五处即可 结果Typora引用本地图片后，就会上传到又拍云，并且引用的路径也改为又拍云的 PS.Typora上传图片时，一定要先运行PicGo程序；如果没有运行PicGo程序，Typora会自动启动PicGo程序，总之，图片上传失败一般都是因为PicGo程序（PicGo程序未启动、PicGo程序的图床配置不正确）","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://blog.zoutl.cn/tags/Typora/"},{"name":"又拍云","slug":"又拍云","permalink":"https://blog.zoutl.cn/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"}]},{"title":"Java将Markdown转化为HTML","slug":"402","date":"2021-12-18T14:18:07.000Z","updated":"2022-04-14T02:19:56.799Z","comments":true,"path":"402.html","link":"","permalink":"https://blog.zoutl.cn/402.html","excerpt":"","text":"引入依赖123456&lt;!-- https://mvnrepository.com/artifact/com.atlassian.commonmark/commonmark --&gt;&lt;dependency&gt; &lt;groupId&gt;com.atlassian.commonmark&lt;/groupId&gt; &lt;artifactId&gt;commonmark&lt;/artifactId&gt; &lt;version&gt;0.12.1&lt;/version&gt;&lt;/dependency&gt; Java代码123456789101112131415161718192021222324package com.ledao.util;import org.commonmark.node.Node;import org.commonmark.parser.Parser;import org.commonmark.renderer.html.HtmlRenderer;/** * @author LeDao * @company * @create 2021-12-18 21:40 */public class MarkdownToHtmlUtil &#123; public static String convert(String md)&#123; Parser parser=Parser.builder().build(); Node document = parser.parse(md); HtmlRenderer htmlRenderer=HtmlRenderer.builder().build(); return htmlRenderer.render(document); &#125; public static void main(String[] args) &#123; System.out.println(convert(&quot;### 111&quot;)); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.zoutl.cn/tags/Markdown/"}]},{"title":"Elasticsearch的head插件基本操作","slug":"401","date":"2021-12-17T07:19:20.000Z","updated":"2022-04-14T02:19:54.345Z","comments":true,"path":"401.html","link":"","permalink":"https://blog.zoutl.cn/401.html","excerpt":"","text":"增加索引在复合查询页添加查询链接填：http://192.168.0.116:9200/student/，192.168.0.116是虚拟机的IP地址，9200是Elasticsearch对外开放的端口，student是索引的名称 提交方式选择：PUT 最后点击提交请求按钮即可 在索引页添加在索引页点击新建索引按钮，在弹出框输入索引名称、分片数、副本数，然后点击OK键即可 删除索引在概览页的指定索引的动作中选中删除，然后在弹出框输入删除，然后确定即可 关闭索引在概览页的指定索引的动作中选中关闭 给索引添加和修改文档在复合查询页的查询选项输入链接：http://192.168.0.116:9200/book/java/3/，提交方式选择POST，链接详解如下表： 字段 说明 192.168.0.116 虚拟机IP 9200 Elasticsearch对外开放的端口号 book 索引名称 java 索引类型 3 文档的id 如果文档id在Elasticsearch中不存在就添加文档，存在就是修改文档 添加或修改的文档内容应当使用JSON格式，如下：（输入JSON串后可以点击验证JSON按钮可以验证输入的JSON串是否正确） 12345&#123; &quot;name&quot;: &quot;JVM实战&quot;, &quot;publishDate&quot;: &quot;2021-12-12&quot;, &quot;price&quot;: 88&#125; 查询索引文档在复合查询页的查询选项输入链接：http://192.168.0.116:9200/book/java/3/，提交方式选择GET，查询条件不用填直接提交请求即可 删除索引文档在复合查询页的查询选项输入链接：http://192.168.0.116:9200/book/java/3/，提交方式选择DELETE，查询条件不用填直接提交请求即可","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://blog.zoutl.cn/tags/Elasticsearch/"}]},{"title":"CentOS7使用安装包安装Node.js","slug":"399","date":"2021-12-14T21:16:26.000Z","updated":"2022-04-14T02:37:13.844Z","comments":true,"path":"399.html","link":"","permalink":"https://blog.zoutl.cn/399.html","excerpt":"","text":"下载安装包有两种方式： 下载到本地后再上传到虚拟机 复制下载链接后，虚拟机使用wget命令直接下载到虚拟机 下载后上传下载地址：Download | Node.js (nodejs.org)，直接点击下图的画红圈链接即可下载，然后上传到虚拟机 直接下载 复制安装包的链接 使用Linux命令下载 1wget https://nodejs.org/dist/v16.13.1/node-v16.13.1-linux-x64.tar.xz 安装解压1tar -xJf node-v16.13.1-linux-x64.tar.xz 配置环境变量打开/etc/profile，然后在最后加上以下代码：（路径要自己的，不要直接用我的） 123#Node.js环境export NODE_HOME=/home/data/node-v16.13.1-linux-x64export PATH=$NODE_HOME/bin:$PATH 执行下面一条命令让环境变量生效 1source /etc/profile 安装淘宝镜像cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 验证输入以下两条命令分别验证Node.js、npm和cnpm，有版本号说明安装成功 12345678#验证Node.jsnode -v#验证npmnpm -v#验证cnpmcnpm -v PS.在线安装Node.js更方便，查看博客：CentOS7 在线安装 Node.js | LeDao 的博客 (zoutl.cn)","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.zoutl.cn/tags/Node-js/"}]},{"title":"CentOS7安装Elasticsearch的head插件","slug":"398","date":"2021-12-14T20:50:22.000Z","updated":"2022-04-14T02:19:50.633Z","comments":true,"path":"398.html","link":"","permalink":"https://blog.zoutl.cn/398.html","excerpt":"","text":"准备工作 安装Node.js，查看博客：CentOS7 在线安装 Node.js | LeDao 的博客 (zoutl.cn) 安装Git，查看博客：CentOS7 安装 Git 的最新版本 | LeDao 的博客 (zoutl.cn) 安装输入以下命令即可完成克隆、安装、启动（安装使用cnpm命令而不是使用npm命令，不然可能会报错） 1234567891011#克隆git clone git://github.com/mobz/elasticsearch-head.git#进入插件目录cd elasticsearch-head#安装cnpm install#启动，用cnpm命令也可以npm run start 配置Elasticsearch需要配置一下，才允许head插件访问Elasticsearch，打开Elasticsearch的conf目录的elasticsearch.yml，然后在最下面加上以下代码： 12http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 使用重启Elasticsearch，再启动head插件，在浏览器地址栏输入：http://虚拟机IP:9100，而插件连接的地址为：http://虚拟机IP:9200","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://blog.zoutl.cn/tags/Elasticsearch/"}]},{"title":"CentOS7安装Git的最新版本","slug":"397","date":"2021-12-14T20:39:11.000Z","updated":"2022-04-14T02:37:09.794Z","comments":true,"path":"397.html","link":"","permalink":"https://blog.zoutl.cn/397.html","excerpt":"","text":"安装输入下面命令即可完成安装 1yum install -y git 查看版本号1git --version 卸载1yum remove git","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"Java操作Elasticsearch","slug":"396","date":"2021-12-14T19:16:18.000Z","updated":"2022-04-14T02:19:42.304Z","comments":true,"path":"396.html","link":"","permalink":"https://blog.zoutl.cn/396.html","excerpt":"","text":"引入依赖引入的依赖版本必须和正在运行的Elasticsearch版本一致 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 实现 连接Elasticsearch 123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.google.gson.JsonObject;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.common.xcontent.XContentType;import org.elasticsearch.transport.client.PreBuiltTransportClient;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.net.InetAddress;/** * @author LeDao * @company * @create 2021-12-15 2:57 */public class MyTest &#123; private static String host = &quot;192.168.0.116&quot;; private static int port = 9300; private TransportClient client = null; /** * 操作q获取连接 * * @throws Exception */ @Before public void getClient() throws Exception &#123; client = new PreBuiltTransportClient(Settings.EMPTY) .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(host), port)); &#125; /** * 操作索引关闭连接 */ @After public void closeClient() &#123; if (client != null) &#123; client.close(); &#125; &#125;&#125; 增加索引并且在这个索引下添加文档 123456789101112131415@Testpublic void addIndex() &#123; JsonObject jsonObject = new JsonObject(); jsonObject.addProperty(&quot;name&quot;, &quot;Java编程思想&quot;); jsonObject.addProperty(&quot;publishDate&quot;, &quot;2012-11-23&quot;); jsonObject.addProperty(&quot;price&quot;, 88); IndexResponse indexResponse = client .prepareIndex(&quot;book&quot;, &quot;java&quot;, &quot;1&quot;) .setSource(jsonObject.toString(), XContentType.JSON) .get(); System.out.println(&quot;索引名称:&quot; + indexResponse.getIndex()); System.out.println(&quot;索引类型:&quot; + indexResponse.getType()); System.out.println(&quot;文档id:&quot; + indexResponse.getId()); System.out.println(&quot;当前状态:&quot; + indexResponse.status());&#125; 删除索引 12345678910@Testpublic void deleteIndex() &#123; DeleteResponse deleteResponse = client .prepareDelete(&quot;book&quot;, &quot;java&quot;, &quot;1&quot;) .get(); System.out.println(&quot;索引名称:&quot; + deleteResponse.getIndex()); System.out.println(&quot;索引类型:&quot; + deleteResponse.getType()); System.out.println(&quot;文档id:&quot; + deleteResponse.getId()); System.out.println(&quot;当前状态:&quot; + deleteResponse.status());&#125; 修改索引的文档 123456789101112131415@Testpublic void updateIndex() &#123; JsonObject jsonObject = new JsonObject(); jsonObject.addProperty(&quot;name&quot;, &quot;Java编程思想2&quot;); jsonObject.addProperty(&quot;publishDate&quot;, &quot;2012-11-22&quot;); jsonObject.addProperty(&quot;price&quot;, 77); UpdateResponse updateResponse = client .prepareUpdate(&quot;book&quot;, &quot;java&quot;, &quot;1&quot;) .setDoc(jsonObject.toString(), XContentType.JSON).get(); System.out.println(&quot;索引名称:&quot; + updateResponse.getIndex()); System.out.println(&quot;索引类型:&quot; + updateResponse.getType()); System.out.println(&quot;文档id:&quot; + updateResponse.getId()); System.out.println(&quot;当前状态:&quot; + updateResponse.status());&#125; 查询索引文档 12345678/** * 查询索引 */@Testpublic void getIndex() &#123; GetResponse getResponse = client.prepareGet(&quot;book&quot;, &quot;java&quot;, &quot;1&quot;).get(); System.out.println(getResponse.getSourceAsString());&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://blog.zoutl.cn/tags/Elasticsearch/"}]},{"title":"Java实现与Elasticsearch的连接","slug":"395","date":"2021-12-14T19:07:31.000Z","updated":"2022-04-14T02:19:40.462Z","comments":true,"path":"395.html","link":"","permalink":"https://blog.zoutl.cn/395.html","excerpt":"","text":"引入依赖引入的依赖版本必须和正在运行的Elasticsearch版本一致 12345&lt;dependency&gt; &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt; &lt;artifactId&gt;transport&lt;/artifactId&gt; &lt;version&gt;5.5.2&lt;/version&gt;&lt;/dependency&gt; 实现Java代码123456789101112131415161718192021222324package com.ledao;import org.elasticsearch.client.transport.TransportClient;import org.elasticsearch.common.settings.Settings;import org.elasticsearch.common.transport.InetSocketTransportAddress;import org.elasticsearch.transport.client.PreBuiltTransportClient;import java.net.InetAddress;/** * @author LeDao * @company * @create 2021-12-15 2:59 */public class Test &#123; public static void main(String[] args) throws Exception &#123; String host = &quot;192.168.0.116&quot;; int port = 9300; TransportClient client = new PreBuiltTransportClient(Settings.EMPTY).addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(host), port)); System.out.println(client); client.close(); &#125;&#125; 运行结果出现划红线的信息说明与Elasticsearch连接成功","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://blog.zoutl.cn/tags/Elasticsearch/"}]},{"title":"CentOS7安装Elasticsearch5.5.2","slug":"394","date":"2021-12-14T13:54:12.000Z","updated":"2022-04-14T11:26:34.142Z","comments":true,"path":"394.html","link":"","permalink":"https://blog.zoutl.cn/394.html","excerpt":"","text":"下载安装包下载地址为：Elasticsearch 5.5.2 | Elastic，下载tar版本的安装包 安装安装jre1.8运行Elasticsearch5.5.2需要jre1.8及以上，安装jre过程查看博客：CentOS7 安装和配置 jre1.8 | LeDao 的博客 (zoutl.cn) 上传到Linux服务器在/home目录下创建一个名称为es的目录，然后将下载好的文件上传到这个目录 解压安装包通过以下命令解压完成后，就已经安装完成了 1tar -zxvf elasticsearch-5.5.2.tar.gz 运行新建用户并赋予权限新建一个用户elastic专门运行Elasticsearch，因为root用户一般不用来运行Elasticsearch的，输入以下三条命令： 12345678#新建一个名为elastic的用户useradd elastic#把目录权限赋予给elasticchown -R elastic:elastic /home/es/elasticsearch-5.5.2/#切换当前身份为elasticsu elastic 第一次运行输入以下命令运行Elasticsearch： 1sh /home/es/elasticsearch-5.5.2/bin/elasticsearch 可能出现的报错 报错1 之所以会报错，是因为Elasticsearch需要的运行内存过大（Elasticsearch默认需要的运行内存为2G，而我的虚拟机的运行内存也是2G，所以这个虚拟机是运行不了Elasticsearch的），解决办法：修改Elasticsearch默认需要的运行内存，该配置文件在/home/es/elasticsearch-5.5.2/config目录下，文件名称为jvm.options,我修改为128M（内存过小Elasticsearch会自动挂掉，所以还是将虚拟机内存修改为4G比较好） 报错2 关于[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]的解决办法如下：（每个进程最大同时打开文件数太小） 切换到root用户 修改/etc/security/limits.conf文件，添加或修改如下行： 12* hard nofile 65536* soft nofile 65536 然后再切换到elastic用户，一定要切换，不然上面的配置不会立即生效，查看当前每个进程最大同时打开文件数的两个命令如下： 12ulimit -Hnulimit -Sn 关于[2]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]的解决办法如下： 切换root用户 方法一：输入命令，不推荐使用此方法，此方法只是临时有效，系统重启后就会失效 1sudo sysctl -w vm.max_map_count=2621441 方法二：修改/etc/sysctl.conf文件，增加配置vm.max_map_count=262144，保存后要执行下面一条命令让配置生效，推荐使用此方法，系统重启后也有效 1sudo sysctl -p /etc/sysctl.conf 再次运行切换到elastic用户，再次输入以下命令运行Elasticsearch 1sh /home/es/elasticsearch-5.5.2/bin/elasticsearch 上面的命令是在前台运行Elasticsearch，一般都是在后台运行以方便进行其它操作，停止Elasticsearch使用快捷键CTRL+C，后台运行的命令如下：（也就是在之前的命令后面加上-d） 1sh /home/es/elasticsearch-5.5.2/bin/elasticsearch -d 使用以下命令查看Elasticsearch是否启动成功，出现下图的信息说明启动成功 1ps -ef | grep elasticsearch 验证服务是否正常验证服务是否正常运行，执行以下命令： 1curl http://localhost:9200 如果正常就会出现下图的信息 允许外网连接 修改配置 在/home/es/elasticsearch-5.5.2/config/elasticsearch.yml中找到并修改下图的配置 重启Elasticsearch服务 查看Elasticsearch服务的进程号 1ps -ef | grep elasticsearch 关闭进程 1kill -9 2328 再次启动Elasticsearch 1sh /home/es/elasticsearch-5.5.2/bin/elasticsearch -d 关闭防火墙 通过以下两条命令关闭防火墙并且设置开机不要启动 12345#关闭systemctl stop firewalld#禁止开机启动systemctl disable firewalld 在电脑上的浏览器输入虚拟机IP:9200，出现下图的结果说明外网连接成功 PS.如果修改了配置不生效，那就切换一下当前身份：在root身份修改了配置后，再将当前身份切换到elastic身份","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://blog.zoutl.cn/tags/Elasticsearch/"}]},{"title":"Nginx获取真实用户IP","slug":"393","date":"2021-12-14T07:45:31.000Z","updated":"2022-04-14T02:38:37.441Z","comments":true,"path":"393.html","link":"","permalink":"https://blog.zoutl.cn/393.html","excerpt":"","text":"问题概述通过Nginx反向代理后，HttpServletRequest.getRemoteAddr()方法无法获取到用户的真实IP，只能获取到本机IP127.0.0.1，这是因为传入Java后端的是Nginx本机的IP 解决办法将用户的IP存储到Nginx的消息头，Java后端直接通过消息头获取用户真实的IP 解决过程Nginx将真实IP存储到消息头在Nginx配置文件的http{}中加入以下代码： 123456789# 下面三行为重点，添加后就可以获取到客户端真实IPset_real_ip_from 0.0.0.0/0;real_ip_header X-Forwarded-For;real_ip_recursive on; # 下面三行为常见反向代理传递真实客户端IP的配置，配置在http&#123;&#125;中，则全局应用在下面的所有server中proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; Java获取真实IP1234567891011121314151617181920212223242526272829package com.ledao.util;import javax.servlet.http.HttpServletRequest;/** * @author LeDao * @company * @create 2021-12-14 12:20 */public class IpUtil &#123; public static String getIpAddr(HttpServletRequest request) &#123; String fromSource = &quot;X-Real-IP&quot;; String ip = request.getHeader(fromSource); if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;X-Forwarded-For&quot;); &#125; if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;); &#125; if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123; ip = request.getRemoteAddr(); &#125; return ip; &#125;&#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx配置SSL证书","slug":"392","date":"2021-12-13T15:08:18.000Z","updated":"2022-04-14T02:38:34.994Z","comments":true,"path":"392.html","link":"","permalink":"https://blog.zoutl.cn/392.html","excerpt":"","text":"添加访问规则在云服务器的安全组中的入方向添加访问规则，端口范围为：443/443，Nginx配置SSL证书需要监听这个端口 下载证书下载Nginx类型的SSL证书 解压证书解压后有两个文件，文件后缀名分别为：.pem和.key 上传证书在Linux服务器的/etc/nginx/conf.d下创建cert目录，上传证书到刚刚创建的cert目录，记住文件路径 安装证书在/etc/nginx/conf.d的default.conf配置文件添加以下代码：（upstream为反向代理的端口号，第一个server为反向代理配置，第二个server为SSl证书配置） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253upstream blog &#123; server localhost:8080;&#125;server &#123; listen 80; server_name www.zoutl.cn; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://blog; proxy_connect_timeout 30; #连接超时 默认为60秒 proxy_read_timeout 30; #读取超时 默认为60秒 proxy_send_timeout 30; #发送超时 默认为60秒 access_log off; break; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125;server &#123; listen 443 ssl; server_name www.zoutl.cn; ssl_certificate /etc/nginx/conf.d/cert/5564023_www.zoutl.cn.pem; #需要将cert-file-name.pem替换成已上传的证书文件的名称。 ssl_certificate_key /etc/nginx/conf.d/cert/5564023_www.zoutl.cn.key; #需要将cert-file-name.key替换成已上传的证书私钥文件的名称。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #表示使用的加密套件的类型。 ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型。 ssl_prefer_server_ciphers on; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; proxy_pass http://www.zoutl.cn; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 验证证书在域名前加上https://，然后在浏览器地址栏输入即可 强制跳转https在反向代理配置中加上以下代码：（在server_name下添加即可） 1rewrite ^(.*)$ https://$host$1; #将所有HTTP请求通过rewrite指令重定向到HTTPS。","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"SSL证书","slug":"SSL证书","permalink":"https://blog.zoutl.cn/tags/SSL%E8%AF%81%E4%B9%A6/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx绑定二级域名到指定端口","slug":"391","date":"2021-12-13T08:30:48.000Z","updated":"2022-04-14T02:38:32.197Z","comments":true,"path":"391.html","link":"","permalink":"https://blog.zoutl.cn/391.html","excerpt":"","text":"我的Nginx版本号为：1.20.2，配置文件路径为：/etc/nginx，在conf.d文件夹的conf.d文件中添加以下代码： 123456789101112131415161718192021222324252627282930upstream blog &#123; #绑定8080端口 server localhost:8080; #集群 #server localhost:8081;&#125;server &#123; listen 80; server_name www.zoutl.cn; #要绑定二级域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; proxy_pass http://blog; #要和指定的upstream相对应 proxy_connect_timeout 30; #连接超时 默认为60秒 proxy_read_timeout 30; #读取超时 默认为60秒 proxy_send_timeout 30; #发送超时 默认为60秒 access_log off; break; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 将上面代码复制过来后，要修改的地方有三处： upstream的名称，以及upstream里的端口号 server下的server_name，server_name的值为二级域名 server下的location /的proxy_pass填http://upstream的名称","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"IntelliJ IDEA修改新建项目时Maven默认本地仓库地址","slug":"390","date":"2021-12-07T13:55:22.000Z","updated":"2022-04-14T02:43:48.218Z","comments":true,"path":"390.html","link":"","permalink":"https://blog.zoutl.cn/390.html","excerpt":"","text":"打开idea的新建项目默认配置设置 修改默认的本地仓库地址，记得勾上Override","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"Java集合Stream流操作常用方法","slug":"389","date":"2021-11-30T11:16:51.000Z","updated":"2022-04-14T02:19:25.880Z","comments":true,"path":"389.html","link":"","permalink":"https://blog.zoutl.cn/389.html","excerpt":"","text":"创建流要创建一个集合的流很简单，只需要在该集合的后面接上.stream()即可 1234567891011121314151617import java.util.Arrays;import java.util.List;import java.util.stream.Stream;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); Stream&lt;String&gt; stringStream = stringList.stream(); &#125;&#125; filter过滤通过filter方法可以选出符合条件的元素 1234567891011121314151617import java.util.Arrays;import java.util.List;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //选出以&quot;al&quot;开头的元素 stringList.stream().filter(s -&gt; s.startsWith(&quot;al&quot;)).forEach(System.out::println); &#125;&#125; map处理元素通过map方法可以对元素进行一些处理，下面的代码将所有字符串都转换成大写 123456789101112131415161718import java.util.Arrays;import java.util.List;import java.util.function.Function;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //将集合的所有字符串元素转换成大写 stringList.stream().map((Function&lt;String, Object&gt;) String::toUpperCase).forEach(System.out::println); &#125;&#125; 获取指定数量元素通过limit方法可以获取指定数量的元素 123456789101112131415161718import java.util.Arrays;import java.util.List;import java.util.function.Function;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //只取前3个元素 stringList.stream().limit(3).forEach(System.out::println); &#125;&#125; 跳过指定下标前元素通过skip方法可以跳过指定下标前面的元素，即：将指定下标前面的元素删除 123456789101112131415161718import java.util.Arrays;import java.util.List;import java.util.function.Function;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //跳过下标2前的元素,也就是下标0,1两个元素 stringList.stream().skip(2).forEach(System.out::println); &#125;&#125; 计算元素个数使用count方法计算元素的个数 123456789101112131415161718import java.util.Arrays;import java.util.List;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //选出以&quot;al&quot;开头的元素并计算元素的个数 Long count=stringList.stream().filter(s -&gt; s.startsWith(&quot;al&quot;)).count(); System.out.println(count); &#125;&#125; 排序通过sorted方法可以对集合进行排序 123456789101112131415161718import java.util.Arrays;import java.util.Comparator;import java.util.List;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //将所有元素升序排序 stringList.stream().sorted(String::compareTo).forEach(System.out::println); &#125;&#125; 生成新集合通过collect方法可以生成一个新的集合 1234567891011121314151617181920import java.util.Arrays;import java.util.Comparator;import java.util.List;import java.util.stream.Collectors;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //将所有元素升序排序后生成一个新的集合 List&lt;String&gt; resultList = stringList.stream().sorted(String::compareTo).collect(Collectors.toList()); resultList.forEach(System.out::println); &#125;&#125; 生成Object数组通过toArray方法生成Object数组 1234567891011121314151617181920import java.util.Arrays;import java.util.Comparator;import java.util.List;import java.util.stream.Collectors;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; stringList = Arrays.asList(&quot;atn&quot;, &quot;tom&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;leo&quot;); //将所有元素升序排序后生成数组 Object[] strings = stringList.stream().sorted(String::compareTo).toArray(); System.out.println(Arrays.toString(strings)); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"List对象集合排序","slug":"388","date":"2021-11-29T12:57:02.000Z","updated":"2022-04-14T02:19:23.769Z","comments":true,"path":"388.html","link":"","permalink":"https://blog.zoutl.cn/388.html","excerpt":"","text":"实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.ledao.entity;/** * 学生实体类 * * @author LeDao * @company * @create 2021-11-21 23:19 */public class Student &#123; /** * 编号 */ private Integer id; /** * 姓名 */ private String name; /** * 年龄 */ private Integer age; public Student() &#123; &#125; public Student(Integer id, String name, Integer age) &#123; this.id = id; this.name = name; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 排序Collections.sort该方法有两个参数，参数一为要排序的对象集合，参数二为比较器 1234567891011121314151617181920212223242526272829303132import com.ledao.entity.Student;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(16); studentList.add(new Student(2, &quot;atn&quot;, 14)); studentList.add(new Student(1, &quot;tom&quot;, 12)); studentList.add(new Student(3, &quot;bob&quot;, 11)); studentList.add(new Student(5, &quot;alex&quot;, 13)); Collections.sort(studentList, new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getAge()-o2.getAge(); &#125; &#125;); for (Student student : studentList) &#123; System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge()); &#125; &#125;&#125; List.sort方法参数为比较器 12345678910111213141516171819202122232425262728293031import com.ledao.entity.Student;import java.util.ArrayList;import java.util.Comparator;import java.util.List;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(16); studentList.add(new Student(2, &quot;atn&quot;, 14)); studentList.add(new Student(1, &quot;tom&quot;, 12)); studentList.add(new Student(3, &quot;bob&quot;, 11)); studentList.add(new Student(5, &quot;alex&quot;, 13)); studentList.sort(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getAge() - o2.getAge(); &#125; &#125;); for (Student student : studentList) &#123; System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge()); &#125; &#125;&#125; Stream流操作通过Stream流操作会返回一个新的并且经过排序的List集合，具体步骤为：①创建要排序集合的流 ②进行排序 ③生成新集合 1234567891011121314151617181920212223242526272829303132import com.ledao.entity.Student;import java.util.ArrayList;import java.util.Comparator;import java.util.List;import java.util.stream.Collectors;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(16); studentList.add(new Student(2, &quot;atn&quot;, 14)); studentList.add(new Student(1, &quot;tom&quot;, 12)); studentList.add(new Student(3, &quot;bob&quot;, 11)); studentList.add(new Student(5, &quot;alex&quot;, 13)); List&lt;Student&gt; resultList=studentList.stream().sorted(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student o1, Student o2) &#123; return o1.getId()-o2.getId(); &#125; &#125;).collect(Collectors.toList()); for (Student student : resultList) &#123; System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge()); &#125; &#125;&#125; 实体类实现Comparable接口实体类实现Comparable接口的compareTo方法，然后再使用Collections.sort方法（参数只有一个：要排序的集合） 实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.ledao.entity;/** * 学生实体类 * * @author LeDao * @company * @create 2021-11-21 23:19 */public class Student implements Comparable&lt;Student&gt;&#123; /** * 编号 */ private Integer id; /** * 姓名 */ private String name; /** * 年龄 */ private Integer age; public Student() &#123; &#125; public Student(Integer id, String name, Integer age) &#123; this.id = id; this.name = name; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public int compareTo(Student o) &#123; return o.getId()-this.getId(); &#125;&#125; 测试方法 12345678910111213141516171819202122232425262728import com.ledao.entity.Student;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.stream.Collectors;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Student&gt; studentList = new ArrayList&lt;&gt;(16); studentList.add(new Student(2, &quot;atn&quot;, 14)); studentList.add(new Student(1, &quot;tom&quot;, 12)); studentList.add(new Student(3, &quot;bob&quot;, 11)); studentList.add(new Student(5, &quot;alex&quot;, 13)); Collections.sort(studentList); for (Student student : studentList) &#123; System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+student.getAge()); &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"List一般集合排序","slug":"387","date":"2021-11-27T12:53:50.000Z","updated":"2022-04-14T02:19:21.754Z","comments":true,"path":"387.html","link":"","permalink":"https://blog.zoutl.cn/387.html","excerpt":"","text":"Collections.sort只有一个参数参数为要排序的集合，将集合升序排序 123456789101112131415161718192021222324252627282930313233import com.ledao.entity.Student;import java.util.*;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; integerList = Arrays.asList(1, 4, 2, 5, 3); Collections.sort(integerList); integerList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;Character&gt; characterList = Arrays.asList(&#x27;a&#x27;,&#x27;v&#x27;,&#x27;b&#x27;,&#x27;c&#x27;); Collections.sort(characterList); characterList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;String&gt; stringList = Arrays.asList(&quot;abc&quot;, &quot;fcd&quot;, &quot;bfd&quot;); Collections.sort(stringList); stringList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;Long&gt; longList = Arrays.asList(111L,332L,22L); Collections.sort(longList); longList.forEach(System.out::println); &#125;&#125; 有两个参数第一个参数是要排序的集合，第二个参数是比较器，排序结果由比较器确定（比较器内第一个参数在前面就是升序，在后面就是降序） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import com.ledao.entity.Student;import java.util.*;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; integerList = Arrays.asList(1, 4, 2, 5, 3); Collections.sort(integerList, new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; //第一个参数在前,升序 //return o1-o2; //第一个参数在后,降序 return o2-o1; &#125; &#125;); integerList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;Character&gt; characterList = Arrays.asList(&#x27;a&#x27;,&#x27;v&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;A&#x27;); Collections.sort(characterList, new Comparator&lt;Character&gt;() &#123; @Override public int compare(Character o1, Character o2) &#123; //第一个参数在后,降序 return o2.compareTo(o1); &#125; &#125;); characterList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;String&gt; stringList = Arrays.asList(&quot;abc&quot;, &quot;fcd&quot;, &quot;bfd&quot;,&quot;Abd&quot;); Collections.sort(stringList, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; //return o2.compareTo(o1); //第一个参数在后,降序,忽略大小写 return o2.compareToIgnoreCase(o1); &#125; &#125;); stringList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;Long&gt; longList = Arrays.asList(111L,332L,22L); Collections.sort(longList, new Comparator&lt;Long&gt;() &#123; @Override public int compare(Long o1, Long o2) &#123; return o2.compareTo(o1); &#125; &#125;); longList.forEach(System.out::println); &#125;&#125; List.sort只有一个参数，参数为比较器，一般推荐用这种方法排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import com.ledao.entity.Student;import java.util.*;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; integerList = Arrays.asList(1, 4, 2, 5, 3); integerList.sort(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2-o1; &#125; &#125;); integerList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;Character&gt; characterList = Arrays.asList(&#x27;a&#x27;,&#x27;v&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;A&#x27;); characterList.sort(new Comparator&lt;Character&gt;() &#123; @Override public int compare(Character o1, Character o2) &#123; return o2.compareTo(o1); &#125; &#125;); characterList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;String&gt; stringList = Arrays.asList(&quot;abc&quot;, &quot;fcd&quot;, &quot;bfd&quot;,&quot;Abd&quot;); stringList.sort(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.compareTo(o1); &#125; &#125;); stringList.forEach(System.out::println); System.out.println(&quot;---------------&quot;); List&lt;Long&gt; longList = Arrays.asList(111L,332L,22L); longList.sort(new Comparator&lt;Long&gt;() &#123; @Override public int compare(Long o1, Long o2) &#123; return o2.compareTo(o1); &#125; &#125;); longList.forEach(System.out::println); &#125;&#125; Stream流操作通过Stream流操作会返回一个新的并且经过排序的List集合，具体步骤为：①创建要排序集合的流 ②进行排序 ③生成新集合 123456789101112131415161718192021222324252627import com.ledao.entity.Student;import java.util.*;import java.util.stream.Collectors;/** * @author LeDao * @company * @create 2021-11-22 20:43 */public class Test &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; integerList = Arrays.asList(1, 4, 2, 5, 3); List&lt;Integer&gt; resultList = integerList .stream()//创建流 .sorted(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;)//排序,降序 .collect(Collectors.toList()); //生成一个新的 List resultList.forEach(System.out::println); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"MyBatis-Plus实体类注解","slug":"386","date":"2021-11-21T15:02:56.000Z","updated":"2022-04-14T01:45:32.433Z","comments":true,"path":"386.html","link":"","permalink":"https://blog.zoutl.cn/386.html","excerpt":"","text":"@TableName表名注解，在类名上面使用，通过value属性的值可以让MyBatis-Plus知道当前实体类对应的是数据库的哪一个表 该注解的属性如下表所示： 属性 类型 必须指定 默认值 描述 value String 否 “” 表名 schema String 否 “” schema keepGlobalPrefix boolean 否 false 是否保持使用全局的 tablePrefix 的值(如果设置了全局 tablePrefix 且自行设置了 value 的值) resultMap String 否 “” xml 中 resultMap 的 id autoResultMap boolean 否 false 是否自动构建 resultMap 并使用(如果设置 resultMap 则不会进行 resultMap 的自动构建并注入) excludeProperty String[] 否 {} 需要排除的属性名(@since 3.3.1) @TableId主键注解，在id字段上使用，value属性值填数据库中主键id的名称，type属性值填主键的规则 属性 类型 必须指定 默认值 描述 value String 否 “” 主键字段名 type Enum 否 IdType.NONE 主键类型 主键的规则type的值如下： 值 描述 IdType.AUTO 数据库ID自增 IdType.NONE 无状态,该类型为未设置主键类型(注解里等于跟随全局,全局里约等于 INPUT) IdType.INPUT insert前自行set主键值 IdType.ASSIGN_ID 分配ID(主键类型为Number(Long和Integer)或String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) IdType.ASSIGN_UUID 分配UUID,主键类型为String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认default方法) 除了通过type属性值来配置主键的规则外，还可以通过application.yml文件来配置 1234mybatis-plus: global-config: db-config: id-type: auto #主键规则为自增 @TableField字段注解（非主键），在实体类字段上使用，value属性值填数据库对应的字段名，exist属性值则填true（true则代表是数据库中的字段）或false（false则代表不是数据库中的字段），更多属性如下： 属性 类型 必须指定 默认值 描述 value String 否 “” 数据库字段名 el String 否 “” 映射为原生 #&#123; ... &#125; 逻辑,相当于写在 xml 里的 #&#123; ... &#125; 部分 exist boolean 否 true 是否为数据库表字段 condition String 否 “” 字段 where 实体查询比较条件,有值设置则按设置的值为准,没有则为默认全局的 %s=#&#123;%s&#125;,参考(opens new window) update String 否 “” 字段 update set 部分注入, 例如：update=”%s+1”：表示更新时会set version=version+1(该属性优先级高于 el 属性) insertStrategy Enum N DEFAULT 举例：NOT_NULL: insert into table_a(&lt;if test=&quot;columnProperty != null&quot;&gt;column&lt;/if&gt;) values (&lt;if test=&quot;columnProperty != null&quot;&gt;#&#123;columnProperty&#125;&lt;/if&gt;) updateStrategy Enum N DEFAULT 举例：IGNORED: update table_a set column=#&#123;columnProperty&#125; whereStrategy Enum N DEFAULT 举例：NOT_EMPTY: where &lt;if test=&quot;columnProperty != null and columnProperty!=&#39;&#39;&quot;&gt;column=#&#123;columnProperty&#125;&lt;/if&gt; fill Enum 否 FieldFill.DEFAULT 字段自动填充策略 select boolean 否 true 是否进行 select 查询 keepGlobalFormat boolean 否 false 是否保持使用全局的 format 进行处理 jdbcType JdbcType 否 JdbcType.UNDEFINED JDBC类型 (该默认值不代表会按照该值生效) typeHandler Class&lt;? extends TypeHandler&gt; 否 UnknownTypeHandler.class 类型处理器 (该默认值不代表会按照该值生效) numericScale String 否 “” 指定小数点后保留的位数 @Version乐观锁注解、标记 @Verison 在字段上 @EnumValue通枚举类注解（注解在枚举字段上） @TableLogic表字段逻辑处理注解（逻辑删除） 属性 类型 必须指定 默认值 描述 value String 否 “” 逻辑未删除值 delval String 否 “” 逻辑删除值 @KeySequence序列主键策略 oracle 属性 类型 必须指定 默认值 描述 value String 否 “” 序列名 clazz Class 否 Long.class id的类型, 可以指定String.class，这样返回的Sequence值是字符串”1” @InterceptorIgnore插件主体(必看!)(since 3.4.0) | MyBatis-Plus (baomidou.com) @OrderBy内置 SQL 默认指定排序，优先级低于 wrapper 条件查询 属性 类型 必须指定 默认值 描述 isDesc boolean 否 是 是否倒序查询 sort short 否 Short.MAX_VALUE 数字越小越靠前","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"阿里云CentOS7系统手动修复漏洞","slug":"385","date":"2021-11-14T09:32:12.000Z","updated":"2022-04-14T02:37:03.414Z","comments":true,"path":"385.html","link":"","permalink":"https://blog.zoutl.cn/385.html","excerpt":"","text":"概述阿里云后台自动修复漏洞是需要收费的，然而手动修复漏洞只需要3个步骤： 清理缓存信息 安装所有软件和系统更新 安全重启系统 修复过程依次输入以下三条命令即可 清理缓存信息1yum clean all 安装所有软件和系统更新1yum -y update 安全重启系统1reboot","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"阿里云","slug":"阿里云","permalink":"https://blog.zoutl.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"实现图片居中显示","slug":"384","date":"2021-11-06T08:23:30.000Z","updated":"2022-03-26T13:46:57.778Z","comments":true,"path":"384.html","link":"","permalink":"https://blog.zoutl.cn/384.html","excerpt":"","text":"解决办法将 img 标签放在 p 标签内，然后 p 标签使用样式text-align: center 代码123&lt;p style=&quot;text-align: center&quot;&gt; &lt;img style=&quot;height: 66px&quot; src=&quot;https://image.zoutl.cn/hexo/images/logo.png&quot;&gt;&lt;/p&gt; 结果","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Windows11的右键菜单恢复成Windows10","slug":"383","date":"2021-11-04T03:59:24.000Z","updated":"2022-04-14T02:01:36.895Z","comments":true,"path":"383.html","link":"","permalink":"https://blog.zoutl.cn/383.html","excerpt":"","text":"下载工具下载地址：Windows 11 Classic Context Menu v1.0 (sordum.org) 使用工具按钮1为恢复成 Windows10 右键菜单，按钮2为恢复成 Windows11 右键菜单","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"Spring Boot快速搭建XXL-JOB分布式任务调度平台","slug":"382","date":"2021-11-03T01:02:34.000Z","updated":"2022-04-14T02:19:13.991Z","comments":true,"path":"382.html","link":"","permalink":"https://blog.zoutl.cn/382.html","excerpt":"","text":"搭建过程拉取源码使用Git命令从GitHub或Gitee拉取XXL-JOB项目 GitHub项目地址为：https://github.com/xuxueli/xxl-job/ Gitee项目地址为：https://gitee.com/xuxueli0323/xxl-job 拉取源码命令如下： 12345#从GitHub拉取git clone https://github.com/xuxueli/xxl-job.git#从Gitee拉取git clone https://gitee.com/xuxueli0323/xxl-job.git 导入数据库数据库文件在 xxl-job\\doc\\db 目录下，数据库新建一个名为 xxl_job 的数据库，并导入该数据库文件 idea导入项目导入 idea 后，配置 JDK ，然后修改 xxl-job-admin 模块下的配置文件 application.properties ，找到数据库配置并修改成自己的数据库配置 12345### xxl-job, datasourcespring.datasource.url=jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghaispring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 运行项目可以直接在 idea 上运行，也可以打包成 jar 包后运行 直接运行 直接启动 xxl-job-admin 模块的 XxlJobAdminApplication.java 文件即可，浏览器地址栏输入：http://localhost:8080/xxl-job-admin/，用户名为：admin，密码为：123456 打包成 jar 包 直接点击 Maven 工具栏的 xxl-job 模块的 package 按钮即可打包成 jar 包 打包好的文件在 xxl-job-admin 模块的 target 文件夹中，名称为：xxl-job-admin-2.3.0.jar ，如果看不到 target 文件夹，就点击 Project 栏右上角的设置按钮并且选择 Show Excluded Files ，打勾代表已启用 使用 CMD 命令进入 jar 包所在文件夹，使用下面命令启动项目 1java -jar xxl-job-admin-2.3.0.jar 在项目中使用新建一个 Spring Boot 项目，命名为：xxlJobDemo，新建项目时直接选择 Spring Web 依赖 引入依赖123456&lt;!-- https://mvnrepository.com/artifact/com.xuxueli/xxl-job-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.xuxueli&lt;/groupId&gt; &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt;&lt;/dependency&gt; 新建logback.xml在 resources 目录下，添加 logback.xml 文件，内容如下： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration debug=&quot;false&quot; scan=&quot;true&quot; scanPeriod=&quot;1 seconds&quot;&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name=&quot;log.path&quot; value=&quot;E:/data/applogs/xxl-job/xxl-job-executor-sample-springboot.log&quot;/&gt; &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=&quot;file&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;$&#123;log.path&#125;&lt;/file&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;.%d&#123;yyyy-MM-dd&#125;.zip&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%date %level [%thread] %logger&#123;36&#125; [%file : %line] %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;console&quot;/&gt; &lt;appender-ref ref=&quot;file&quot;/&gt; &lt;/root&gt;&lt;/configuration&gt; 修改application.properties123456789101112131415161718192021# web portserver.port=8888# log configlogging.config=classpath:logback.xmlspring.application.name=xxlJobDemo### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=xxlJobDemo### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；xxl.job.executor.port=9999### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=E:/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=10 新建XXL-JOB配置类新建一个 XXL-JOB 配置类，命名为：XxlJobConfig.java，内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.ldeao.xxljobdemo.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * XXL-JOB配置类 * * @author LeDao * @company * @create 2021-11-03 10:16 */@Configurationpublic class XxlJobConfig &#123; private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class); @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;) private String adminAddresses; @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;) private String accessToken; @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;) private String appname; @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;) private String address; @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;) private String ip; @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;) private int port; @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;) private String logPath; @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;) private int logRetentionDays; @Bean public XxlJobSpringExecutor xxlJobExecutor() &#123; logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;); XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor(); xxlJobSpringExecutor.setAdminAddresses(adminAddresses); xxlJobSpringExecutor.setAppname(appname); xxlJobSpringExecutor.setAddress(address); xxlJobSpringExecutor.setIp(ip); xxlJobSpringExecutor.setPort(port); xxlJobSpringExecutor.setAccessToken(accessToken); xxlJobSpringExecutor.setLogPath(logPath); xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays); return xxlJobSpringExecutor; &#125;&#125; 新建任务类新建一个定时任务类，命名为：Test.java 12345678910111213141516171819202122232425262728293031package com.ldeao.xxljobdemo.xxljobhandler;import com.xxl.job.core.biz.model.ReturnT;import com.xxl.job.core.handler.annotation.XxlJob;import com.xxl.job.core.log.XxlJobLogger;import org.springframework.stereotype.Component;/** * 测试Handler * * @author LeDao * @company * @create 2021-11-03 10:18 */@Componentpublic class Test &#123; /** * Bean模式，一个方法为一个任务 * 1、在Spring Bean实例中，开发Job方法，方式格式要求为 &quot;public ReturnT&lt;String&gt; execute(String param)&quot; * 2、为Job方法添加注解 &quot;@XxlJob(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。 * 3、执行日志：需要通过 &quot;XxlJobLogger.log&quot; 打印执行日志； */ @XxlJob(&quot;demoJobHandler1&quot;) public ReturnT&lt;String&gt; demoJobHandler1(String param) throws Exception &#123; System.out.println(&quot;java, Hello World~~~&quot;); XxlJobLogger.log(&quot;java, Hello World~~~&quot;); XxlJobLogger.log(&quot;param:&quot; + param); return ReturnT.SUCCESS; &#125;&#125; 启动项目按 Spring Boot 方式启动即可，点击 idea 的启动按钮或者直接运行 XxlJobDemoApplication.java 这个类 将定时任务添加到XXL-JOB 添加执行器 在执行器管理界面添加一个执行器，表单填写要求如下： AppName 填 xxlJobDemo ，要与 application.properties 配置的一致 名称可以根据自己的情况填写，填项目名称即可 注册方式选自动注册时不要填机器地址，选手动录入则需要填写机器地址，所以直接选自动注册即可 添加任务 在任务管理界面添加一个任务，表单填写要求如下： 执行器选刚刚创建的 xxlJobDemo 任务描述和负责人根据实际情况填写 调度类型选 CRON ，Cron 点击编辑选择即可 运行模式选择 BEAN，JobHandler 填定时任务类的对应方法（要和Bean的名称一致） 其它的默认就行 启动任务在任务管理中找到指定任务，然后启动它即可，可以执行一次，然后去 idea 控制台查看结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"XXL-JOB","slug":"XXL-JOB","permalink":"https://blog.zoutl.cn/tags/XXL-JOB/"}]},{"title":"Listary搜索技巧","slug":"381","date":"2021-11-02T02:31:37.000Z","updated":"2022-03-26T13:50:45.133Z","comments":true,"path":"381.html","link":"","permalink":"https://blog.zoutl.cn/381.html","excerpt":"","text":"在指定文件夹内搜索有两种方法： 在 Listary 搜索框中输入文件夹名称\\搜索关键词 直接打开该文件夹，然后直接输入搜索关键词 在指定盘符内搜索以 D 盘为例，有两种方法： 在 Listary 搜索框中输入 d:\\（大写也可以），然后后面接搜索关键词即可 可以直接打开 D 盘，然后直接输入搜索关键词 搜索指定类型文件这里以搜索 PDF 文件为例，首先去 Listary 选项中设置，点击+号添加 PDF 文件的过滤器，名称直接填 PDF ，关键词填 pdf（大写也行），搜索选项选择文件，扩展名填pdf（多个扩展名用英语的分号隔开），然后即可通过pdf:搜索关键词搜索pdf文件 在指定网站搜索概述这里以谷歌搜索为例，一般情况要使用谷歌搜索，我们需要先启动浏览器，然后打开谷歌搜索的网址，然后输入搜索关键词进行搜索 如果使用 Listary，可以直接输入搜索关键词即可，而无需启动浏览器和输入谷歌搜索的网址 配置如下图，关键字和 URL 为重要选项，关键词可以根据自己的习惯填（我的是 gg ），URL 则是每个网址都是固定的，谷歌的是http://www.google.com/search?q=&#123;query&#125; 使用在Listary搜索框输入gg +搜索关键词，gg 后有空格，然后按下回车键即可，如果输入 gg 后直接回车会启动系统默认的浏览器，并且打开谷歌搜索网页 PS.下面列出一些搜索网址的搜索 URL： 百度搜索：http://www.baidu.com/s?wd=&#123;query&#125; 必应搜索：http://www.bing.com/search?q=&#123;query&#125; 优酷搜索：https://so.youku.com/search_video/q_&#123;query&#125; 如何自定义其它网址搜索呢？这其实很简单，这里以百度搜索为例，直接在百度中搜索java，然后复制搜索后的链接，然后可以得到https://www.baidu.com/s?wd=java&amp;rsv_spt=1&amp;rsv_iqid=0xb78f2ec700110b36&amp;issp=1&amp;f=8&amp;rsv_bp=0&amp;rsv_idx=2&amp;ie=utf-8&amp;rqlang=&amp;tn=baiduhome_pg&amp;ch=，https://www.baidu.com/s?后面接搜索条件，观察后可以发现wd=java就是搜索关键词匹配的条件，所以https://www.baidu.com/s?wd=java也可以在百度中搜索 java 关键词，然后将 java 替换成 &#123;query&#125; 即可，即完整的 Listary 百度搜索URL为http://www.baidu.com/s?wd=&#123;query&#125;","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Listary","slug":"Listary","permalink":"https://blog.zoutl.cn/tags/Listary/"}]},{"title":"CentOS7在线安装Node.js","slug":"380","date":"2021-10-31T16:44:43.000Z","updated":"2022-04-14T02:37:00.457Z","comments":true,"path":"380.html","link":"","permalink":"https://blog.zoutl.cn/380.html","excerpt":"","text":"查看旧版Node.js查看是否已经安装了旧的Node.js，如果安装过Node.js就把它卸载 1yum remove nodejs 获取Node.js资源1curl --silent --location https://rpm.nodesource.com/setup_16.x | bash - 可以安装的Node.js版本如下图所示，分别为：12、14、16三个版本 安装Node.js1yum install -y nodejs 安装淘宝镜像cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 查看安装版本输入以下3条命令都可以看到安装的版本号说明安装已经成功 123node -vnpm -vcnpm -v PS.用安装包安装Node.js查看博客：CentOS7 使用安装包安装 Node.js | LeDao 的博客 (zoutl.cn)","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.zoutl.cn/tags/Node-js/"}]},{"title":"在IntelliJ IDEA中使用Git命令","slug":"379","date":"2021-10-31T13:33:25.000Z","updated":"2022-04-14T02:43:14.450Z","comments":true,"path":"379.html","link":"","permalink":"https://blog.zoutl.cn/379.html","excerpt":"","text":"打开设置打开idea的设置界面，找到Tools -&gt; Terminal 设置本地Git在上图的Shell path中选择本地Git的bash.exe安装路径 使用Git命令点击idea最下面的Terminal，即可打开Git命令行界面，然后就可以使用Git命令了","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"Java继承的super和this关键字","slug":"378","date":"2021-10-29T03:02:06.000Z","updated":"2022-04-14T02:19:00.584Z","comments":true,"path":"378.html","link":"","permalink":"https://blog.zoutl.cn/378.html","excerpt":"","text":"介绍在Java继承中，super关键字用于调用父类的属性和方法，而this则用于调用子类自身的属性和方法，this也可以省略不写 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; Dog dog = new Dog(); dog.eatTest(); &#125;&#125;class Animal &#123; String name = &quot;Animal&quot;; void eat() &#123; System.out.println(&quot;动物吃饭&quot;); &#125;&#125;class Dog extends Animal &#123; String name = &quot;Dog&quot;; @Override void eat() &#123; System.out.println(&quot;小狗吃饭&quot;); &#125; void eatTest() &#123; //调用父类的eat()方法 super.eat(); //调用自己的eat()方法,this也可以省略 this.eat(); //调用父类的name System.out.println(super.name); //调用自己的name System.out.println(this.name); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java实现从Excel读取数据","slug":"377","date":"2021-10-26T11:28:08.000Z","updated":"2022-04-14T02:18:58.052Z","comments":true,"path":"377.html","link":"","permalink":"https://blog.zoutl.cn/377.html","excerpt":"","text":"引入依赖12345678910111213141516171819202122232425262728293031&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.78&lt;/version&gt;&lt;/dependency&gt; 实现过程定义监听器定义一个监听器继承 AnalysisEventListener 类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import com.alibaba.excel.context.AnalysisContext;import com.alibaba.excel.event.AnalysisEventListener;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import lombok.Data;import lombok.EqualsAndHashCode;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author LeDao */@Data@EqualsAndHashCode(callSuper = true)public class ExcelListener extends AnalysisEventListener&lt;Object&gt; &#123; /** * 自定义用于暂时存储data */ private List&lt;JSONObject&gt; dataList = new ArrayList&lt;&gt;(); /** * 导入表头 */ private Map&lt;String, Integer&gt; importHeads = new HashMap&lt;&gt;(16); /** * 这个每一条数据解析都会来调用 */ @Override public void invoke(Object data, AnalysisContext context) &#123; String headStr = JSON.toJSONString(data); dataList.add(JSONObject.parseObject(headStr)); &#125; /** * 这里会一行行的返回头 */ @Override public void invokeHeadMap(Map&lt;Integer, String&gt; headMap, AnalysisContext context) &#123; for (Integer key : headMap.keySet()) &#123; if (importHeads.containsKey(headMap.get(key))) &#123; continue; &#125; importHeads.put(headMap.get(key), key); &#125; &#125; /** * 所有数据解析完成了 都会来调用 */ @Override public void doAfterAllAnalysed(AnalysisContext context) &#123; &#125;&#125; 测试类12345678910111213141516171819202122232425262728import com.alibaba.excel.EasyExcel;import com.alibaba.fastjson.JSONObject;import java.util.List;import java.util.Map;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; //读取Excel的文件位置 String fileName = &quot;E:\\\\测试.xlsx&quot;; ExcelListener excelListener = new ExcelListener(); EasyExcel.read(fileName, excelListener).sheet().doRead(); //表格头数据 Map&lt;String, Integer&gt; heads = excelListener.getImportHeads(); System.out.println(heads); //每一行数据 List&lt;JSONObject&gt; dataList = excelListener.getDataList(); for (JSONObject jsonObject : dataList) &#123; System.out.println(jsonObject); &#125; &#125;&#125; 结果表格数据 读取的结果 PS.上面是直接读取电脑磁盘上的 Excel 表，也可以读取前端上传的 Excel 表 12345678910@PostMapping(&quot;upload&quot;)@ResponseBodypublic String upload(MultipartFile file) throws IOException &#123; ExcelListener excelListener = new ExcelListener(); EasyExcel.read(file.getInputStream(), excelListener).sheet().doRead(); //表格头数据 Map&lt;String, Integer&gt; heads = excelListener.getImportHeads(); //每一行数据 List&lt;JSONObject&gt; dataList = excelListener.getDataList();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java实现写数据到Excel","slug":"376","date":"2021-10-24T23:10:39.000Z","updated":"2022-04-16T14:38:43.215Z","comments":true,"path":"376.html","link":"","permalink":"https://blog.zoutl.cn/376.html","excerpt":"","text":"引入依赖123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.poi/poi-ooxml --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt;&lt;/dependency&gt; 实现过程一般数据插入1234567891011121314151617181920212223242526272829303132333435363738394041import com.alibaba.excel.EasyExcel;import com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; //生成的excel表名 String fileName = &quot;E:\\\\测试.xlsx&quot;; //插入列名 List&lt;List&lt;String&gt;&gt; head = new ArrayList&lt;&gt;(); List&lt;String&gt; head0 = new ArrayList&lt;&gt;(); head0.add(&quot;姓名&quot;); List&lt;String&gt; head1 = new ArrayList&lt;&gt;(); head1.add(&quot;年龄&quot;); List&lt;String&gt; head2 = new ArrayList&lt;&gt;(); head2.add(&quot;生日&quot;); head.add(head0); head.add(head1); head.add(head2); //插入数据 List&lt;List&lt;Object&gt;&gt; datalist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; List&lt;Object&gt; data = new ArrayList&lt;&gt;(); data.add(&quot;张三&quot; + i); data.add(11); data.add(new Date()); datalist.add(data); &#125; //开始生成excel表 EasyExcel.write(fileName).head(head).registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).sheet().doWrite(datalist); &#125;&#125; 使用对象自定义列名实体类的字段上使用 @ExcelProperty 注解，例如：@ExcelProperty(value = “编号”) Link实体类代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243package entity;import com.alibaba.excel.annotation.ExcelIgnore;import com.alibaba.excel.annotation.ExcelProperty;/** * @author LeDao * @company * @create 2021-07-20 8:22 */public class Link &#123; @ExcelProperty(value = &quot;编号&quot;) private Integer id; @ExcelProperty(value = &quot;链接名称&quot;) private String linkName; @ExcelProperty(value = &quot;链接地址&quot;) private String linkUrl; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLinkName() &#123; return linkName; &#125; public void setLinkName(String linkName) &#123; this.linkName = linkName; &#125; public String getLinkUrl() &#123; return linkUrl; &#125; public void setLinkUrl(String linkUrl) &#123; this.linkUrl = linkUrl; &#125;&#125; 测试类代码如下 123456789101112131415161718192021222324252627import com.alibaba.excel.EasyExcel;import com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy;import entity.Link;import java.util.ArrayList;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; String fileName = &quot;E:\\\\测试.xlsx&quot;; List&lt;Link&gt; linkList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Link link = new Link(); link.setId(i); link.setLinkName(&quot;LeDao的博客&quot;+i); link.setLinkUrl(&quot;https://blog.zoutl.cn&quot;); linkList.add(link); &#125; EasyExcel.write(fileName, Link.class).registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).sheet().doWrite(linkList); &#125;&#125; 忽略字段实体类的字段上使用 @ExcelIgnore 注解即可，下面代码中的 id 已被忽略，不会写到 Excel 表中 12345678910111213141516171819202122232425262728293031323334353637383940414243package entity;import com.alibaba.excel.annotation.ExcelIgnore;import com.alibaba.excel.annotation.ExcelProperty;/** * @author LeDao * @company * @create 2021-07-20 8:22 */public class Link &#123; @ExcelIgnore private Integer id; @ExcelProperty(value = &quot;链接名称&quot;) private String linkName; @ExcelProperty(value = &quot;链接地址&quot;) private String linkUrl; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLinkName() &#123; return linkName; &#125; public void setLinkName(String linkName) &#123; this.linkName = linkName; &#125; public String getLinkUrl() &#123; return linkUrl; &#125; public void setLinkUrl(String linkUrl) &#123; this.linkUrl = linkUrl; &#125;&#125; 写入指定的列在实体类的字段上使用 @ExcelProperty 注解，并使用 index 参数，第一列为 0 12345678910111213141516171819202122232425262728293031323334353637383940414243package entity;import com.alibaba.excel.annotation.ExcelIgnore;import com.alibaba.excel.annotation.ExcelProperty;/** * @author LeDao * @company * @create 2021-07-20 8:22 */public class Link &#123; @ExcelProperty(value = &quot;编号&quot;, index = 0) private Integer id; @ExcelProperty(value = &quot;链接名称&quot;, index = 1) private String linkName; @ExcelProperty(value = &quot;链接地址&quot;, index = 2) private String linkUrl; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLinkName() &#123; return linkName; &#125; public void setLinkName(String linkName) &#123; this.linkName = linkName; &#125; public String getLinkUrl() &#123; return linkUrl; &#125; public void setLinkUrl(String linkUrl) &#123; this.linkUrl = linkUrl; &#125;&#125; 在模板后追加数据下面的代码是直接在 测试.xlsx 的基础上追加数据，然后生成了 测试2.xlsx ，不要在 EasyExcel.write() 方法中传入对象，不然又会生成新的表头 12345678910111213141516171819202122232425262728import com.alibaba.excel.EasyExcel;import entity.Link;import java.util.ArrayList;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; String templateName = &quot;E:\\\\测试.xlsx&quot;; String fileName = &quot;E:\\\\测试2.xlsx&quot;; List&lt;Link&gt; linkList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Link link = new Link(); link.setId(i); link.setLinkName(&quot;LeDao的博客&quot; + i); link.setLinkUrl(&quot;https://blog.zoutl.cn&quot;); linkList.add(link); &#125; //只传文件路径，不传对象，如果传了对象又会生成新的表头 EasyExcel.write(fileName).withTemplate(templateName).sheet().doWrite(linkList); &#125;&#125; 实现列名和内容居中在实体上加上两个注解即可 12@HeadStyle(horizontalAlignment = HorizontalAlignment.CENTER)@ContentStyle(horizontalAlignment = HorizontalAlignment.CENTER) 居中、左侧对齐、右侧对齐的设置如下： HorizontalAlignment.CENTER表示居中 HorizontalAlignment.LEFT表示左侧对齐 HorizontalAlignment.RIGHT表示右侧对齐","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"MySQL使用存储过程","slug":"375","date":"2021-10-11T12:46:12.000Z","updated":"2022-04-14T02:34:18.734Z","comments":true,"path":"375.html","link":"","permalink":"https://blog.zoutl.cn/375.html","excerpt":"","text":"概述介绍存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。 优点 通过把处理封装在容易使用的单元中，简化复杂的操作。 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。 这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。 提高性能。因为使用存储过程比使用单独的SQL语句要快。 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。 换句话说，使用存储过程有3个主要的好处，即简单、安全、高性能。 缺点 一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。 可能没有创建存储过程的安全访问权限。许多数据库管理员限制存储过程的创建权限，允许用户使用存储过程，但不允许他们创建存储过程 尽管有这些缺陷，存储过程还是非常有用的，并且应该尽可能地使用 创建和使用无参数获取全部学生的人数 123456DELIMITER // CREATE PROCEDURE student_num_all() BEGIN SELECT COUNT(*) FROM t_student; END// DELIMITER; SQL语句详解如下： DELIMITER //告诉命令行程序使用//作为新的语句结束分隔符，//也可以用其它的符号代替，例如：将//替换成&amp;&amp; CREATE PROCEDURE student_num_all()定义了一个名为student_num_all的存储过程 BEGIN和END语句用来限定存储过程体 使用存储过程的SQL语句如下： 使用一个名称为student_num_all的存储过程 1CALL student_num_all; 有参数根据班级id获取学生数 123456DELIMITER // CREATE PROCEDURE student_num_by_classId(IN classId INT) BEGIN SELECT COUNT(*) AS total FROM t_student WHERE class_id=classId; END// DELIMITER; 使用一个名称为student_num_by_classId的存储过程，传入的参数为classId 1CALL student_num_by_classId(2); 调用产生的结果上面的两个例子调用存储过程时都是直接显示结果并且只返回一个结果，如果存储过程中含有多条SQL语句且返回多个结果，那么就需要使用 OUT 和 INTO 关键词 返回对应班级id的学生人数、学生年龄的最大值、学生年龄的最小值 12345678DELIMITER // CREATE PROCEDURE student_num_by_classId2(IN classId INT,OUT stu_num INT,OUT max1 INT,OUT min1 INT) BEGIN SELECT COUNT(*) INTO stu_num FROM t_student WHERE class_id=classId; SELECT MAX(age) INTO max1 FROM t_student; SELECT MIN(age) INTO min1 FROM t_student; END// DELIMITER; 使用一个名为student_num_by_classId2的存储过程 1CALL student_num_by_classId(2,@total,@max1,@min1); 使用产生的结果 1SELECT @total AS total,@max1 AS max_age,@min1 AS min_age; 删除删除一个名为student_num_all的存储过程 1DROP PROCEDURE student_num_all; 检查为显示用来创建一个存储过程的CREATE语句，使用SHOW CREATE PROCEDURE语句 1SHOW CREATE PROCEDURE student_num_all; 列出所有存储过程 1SHOW PROCEDURE STATUS; 如果要限制输出，则使用 LIKE 关键词过滤结果，后面需要接一个完整的存储过程名称 1SHOW PROCEDURE STATUS LIKE &#x27;student_num_by_classId&#x27;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"Swagger3的Docket开关&过滤&分组配置","slug":"374","date":"2021-10-05T14:49:18.000Z","updated":"2022-04-14T02:18:52.658Z","comments":true,"path":"374.html","link":"","permalink":"https://blog.zoutl.cn/374.html","excerpt":"","text":"概述通过设置Docket，还可以配置很多功能，比如是否开启swagger，过滤，分组等 开启和关闭swagger开发环境开启swagger，生产环境就关闭swagger 123456789101112131415161718192021222324252627282930313233package com.ledao.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import java.util.ArrayList;/** * Swagger配置 * * @author LeDao * @company * @create 2021-10-05 22:04 */@Configurationpublic class SwaggerConfig &#123; /** * 配置swagger的Docket bean * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) //true为开启swagger,false为关闭swagger .enable(true); &#125;&#125; 过滤过滤方式有两种：①根据包路径过滤 ②根据请求路径过滤，这两种过滤方式可以单独使用，也可以结合使用 根据包路径先调用select方法，然后调用apis方法，最后调用build方法 123456789101112131415161718192021222324252627282930313233343536373839package com.ledao.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import java.util.ArrayList;/** * Swagger配置 * * @author LeDao * @company * @create 2021-10-05 22:04 */@Configurationpublic class SwaggerConfig &#123; /** * 配置swagger的Docket bean * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) //true为开启,false为关闭 .enable(true) .select() //根据包路径过滤 .apis(RequestHandlerSelectors.basePackage(&quot;com.ledao.controller&quot;)) .build(); &#125;&#125; 根据请求路径先调用select方法，然后调用apis方法，最后调用build方法 123456789101112131415161718192021222324252627282930313233343536373839package com.ledao.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import java.util.ArrayList;/** * Swagger配置 * * @author LeDao * @company * @create 2021-10-05 22:04 */@Configurationpublic class SwaggerConfig &#123; /** * 配置swagger的Docket bean * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) //true为开启,false为关闭 .enable(true) .select() //根据请求路径过滤 .paths(PathSelectors.ant(&quot;/student/**&quot;)) .build(); &#125;&#125; 结合使用1234567891011121314151617181920212223242526272829303132333435363738394041package com.ledao.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import java.util.ArrayList;/** * Swagger配置 * * @author LeDao * @company * @create 2021-10-05 22:04 */@Configurationpublic class SwaggerConfig &#123; /** * 配置swagger的Docket bean * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) //true为开启,false为关闭 .enable(true) .select() //根据包路径过滤 .apis(RequestHandlerSelectors.basePackage(&quot;com.ledao.controller&quot;)) //根据请求路径过滤 .paths(PathSelectors.ant(&quot;/student/**&quot;)) .build(); &#125;&#125; 分组在实际项目开发中，把复杂项目划分多模块给多个小组或者多个人负责开发，所以每个小组或者个人要实现自己的分组，方便查找到API接口开发负责人，沟通和处理问题 通过.groupName设置分组名称，有多少个分组就搞几份配置，下面代码设置了两个分组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.ledao.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import java.util.ArrayList;/** * Swagger配置 * * @author LeDao * @company * @create 2021-10-05 22:04 */@Configurationpublic class SwaggerConfig &#123; /** * 配置swagger的Docket bean * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) .groupName(&quot;开发组001&quot;) //true为开启,false为关闭 .enable(true) .select() //根据包路径过滤 .apis(RequestHandlerSelectors.basePackage(&quot;com.ledao.controller&quot;)) //根据请求路径过滤 .paths(PathSelectors.ant(&quot;/student/**&quot;)) .build() .apiInfo(createApiInfo()); &#125; @Bean public ApiInfo createApiInfo() &#123; return new ApiInfo( &quot;LeDao Swagger3&quot;, &quot;LeDao Api文档&quot;, &quot;3.0&quot;, &quot;https://blog.zoutl.cn&quot;, new Contact(&quot;LeDao&quot;, &quot;https://blog.zoutl.cn&quot;, &quot;f110@gmail.com&quot;), &quot;Apache 2.0&quot;, &quot;https://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;&gt;() ); &#125; /** * 配置swagger的Docket bean * * @return */ @Bean public Docket createRestApi2() &#123; return new Docket(DocumentationType.OAS_30) .groupName(&quot;开发组002&quot;) //true为开启,false为关闭 .enable(true) .select() //根据包路径过滤 .apis(RequestHandlerSelectors.basePackage(&quot;com.ledao.test&quot;)) //根据请求路径过滤 .paths(PathSelectors.ant(&quot;/teacher/**&quot;)) .build() .apiInfo(createApiInfo2()); &#125; @Bean public ApiInfo createApiInfo2() &#123; return new ApiInfo( &quot;乐道 Swagger3&quot;, &quot;乐道 Api文档&quot;, &quot;3.0&quot;, &quot;https://blog.zoutl.cn&quot;, new Contact(&quot;乐道&quot;, &quot;https://blog.zoutl.cn&quot;, &quot;f119@gmail.com&quot;), &quot;Apache 2.0&quot;, &quot;https://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;&gt;() ); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Swagger3","slug":"Swagger3","permalink":"https://blog.zoutl.cn/tags/Swagger3/"}]},{"title":"Swagger3的API信息配置","slug":"373","date":"2021-10-05T14:33:24.000Z","updated":"2022-04-14T02:18:50.359Z","comments":true,"path":"373.html","link":"","permalink":"https://blog.zoutl.cn/373.html","excerpt":"","text":"概述通过修改API信息配置，可以让前端开发人员更方便地知道API文档是谁编写的，以方便联系 配置类代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ledao.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import java.util.ArrayList;/** * Swagger配置 * * @author LeDao * @company * @create 2021-10-05 22:04 */@Configurationpublic class SwaggerConfig &#123; /** * 配置swagger的Docket bean * * @return */ @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.OAS_30) .apiInfo(createApiInfo()); &#125; @Bean public ApiInfo createApiInfo() &#123; return new ApiInfo( &quot;LeDao Swagger3&quot;, &quot;LeDao Api文档&quot;, &quot;3.0&quot;, &quot;https://blog.zoutl.cn&quot;, new Contact(&quot;LeDao&quot;, &quot;https://blog.zoutl.cn&quot;, &quot;f110@gmail.com&quot;), &quot;Apache 2.0&quot;, &quot;https://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList&lt;&gt;() ); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Swagger3","slug":"Swagger3","permalink":"https://blog.zoutl.cn/tags/Swagger3/"}]},{"title":"Swagger3常用注解","slug":"372","date":"2021-10-05T13:03:45.000Z","updated":"2022-04-14T02:18:48.924Z","comments":true,"path":"372.html","link":"","permalink":"https://blog.zoutl.cn/372.html","excerpt":"","text":"@EnableOpenApi该注解添加在Spring Boot项目的启动类上，然后在整个项目上使用Swagger3了 123456789101112131415161718package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import springfox.documentation.oas.annotations.EnableOpenApi;/** * @author LeDao */@EnableOpenApi@SpringBootApplicationpublic class SwaggerTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SwaggerTestApplication.class, args); &#125;&#125; @Api添加在Controller类上，有两个参数： tags：说明该类的作用，可以在UI界面上看到的注解 value：该参数没什么意义，在UI界面上也看到，所以不需要配置 1234567891011121314151617181920package com.ledao.controller;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * 首页Controller * * @author LeDao * @company * @create 2021-10-05 17:35 */@Api(tags = &quot;首页Controller&quot;)@Controllerpublic class IndexController &#123;&#125; @ApiOperation添加在在Controller类的方法上，有两个参数： value：说明方法的用途、作用 notes：方法的备注说明 123456@ApiOperation(value = &quot;跳转到首页&quot;)@ResponseBody@GetMapping(&quot;/&quot;)public String root() &#123; return &quot;&lt;a href=&#x27;http://localhost:8080/student/delete?id=2&#x27;&gt;删除学生&lt;/a&gt;&quot;;&#125; @ApiImplicitParams用在请求的方法上，表示一组参数说明，结合注解@ApiImplicitParam一起使用 @ApiImplicitParam该注解用在@ApiImplicitParams内，该注解的参数如下： name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 .header 请求参数的获取：@RequestHeader .query 请求参数的获取：@RequestParam .path 用于restful接口，请求参数的获取：@PathVariable .div 不常用 .form 不常用 dataType：参数类型，默认String，其它值dataType=&quot;Integer&quot; defaultValue：参数的默认值 123456789101112131415161718/** * 添加学生 * * @param id * @param name * @param age * @return */@ApiOperation(value = &quot;添加学生&quot;)@ApiImplicitParams(&#123; @ApiImplicitParam(name = &quot;id&quot;, value = &quot;编号&quot;, required = true), @ApiImplicitParam(name = &quot;name&quot;, value = &quot;姓名&quot;, required = true), @ApiImplicitParam(name = &quot;age&quot;, value = &quot;年龄&quot;, required = true)&#125;)@GetMapping(&quot;/add&quot;)public Student add(Integer id, String name, Integer age) &#123; return new Student(id, name, age);&#125; @ApiResponses用在请求的方法上，表示一组响应码，结合注解@ApiResponse一起使用 @ApiResponse用在@ApiResponses中，一般用于表达一个错误的响应信息，参数如下： code：数字，例如400 message：信息，例如”请求参数没填好“ response：抛出异常的类 123456789101112131415161718/** * 添加学生 * * @param id * @param name * @param age * @return */@ApiOperation(value = &quot;添加学生&quot;)@ApiResponses(&#123; @ApiResponse(code = 408, message = &quot;指定业务得报错信息，返回客户端&quot;), @ApiResponse(code = 400, message = &quot;请求参数没填好&quot;), @ApiResponse(code = 404, message = &quot;请求路径没有或页面跳转路径不对&quot;)&#125;)@GetMapping(&quot;/add&quot;)public Student add(Integer id, String name, Integer age) &#123; return new Student(id, name, age);&#125; @ApiModel用于实体类上，表示一个返回响应数据的信息，参数value填该实体类的作用 这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候 12345678910111213141516package com.ledao.entity;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * 学生实体类 * * @author LeDao * @company * @create 2021-10-05 16:59 */@ApiModel(value = &quot;学生实体类&quot;)public class Student &#123;&#125; @ApiModelProperty该注解添加在实体类的属性上，描述实体类的属性，参数value填参数的作用 12345678910111213141516171819202122232425262728293031package com.ledao.entity;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;/** * 学生实体类 * * @author LeDao * @company * @create 2021-10-05 16:59 */@ApiModel(value = &quot;学生实体类&quot;)public class Student &#123; /** * 编号 */ @ApiModelProperty(value = &quot;编号&quot;) private Integer id; /** * 姓名 */ @ApiModelProperty(value = &quot;姓名&quot;) private String name; /** * 年龄 */ @ApiModelProperty(value = &quot;年龄&quot;) private Integer age;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Swagger3","slug":"Swagger3","permalink":"https://blog.zoutl.cn/tags/Swagger3/"}]},{"title":"Spring Boot使用Swagger3","slug":"371","date":"2021-10-05T11:28:15.000Z","updated":"2022-04-14T02:18:46.254Z","comments":true,"path":"371.html","link":"","permalink":"https://blog.zoutl.cn/371.html","excerpt":"","text":"引入依赖12345&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; 添加注解在启动类添加@EnableOpenApi 123456789101112131415161718package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import springfox.documentation.oas.annotations.EnableOpenApi;/** * @author LeDao */@EnableOpenApi@SpringBootApplicationpublic class SwaggerTestApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SwaggerTestApplication.class, args); &#125;&#125; 在Controller类上添加@Api(tags = “该Controller类的用途”)，参数tags主要是描述该Controller类的用途，在Controller类的方法上添加@ApiOperation(value = “该方法的用途”)，参数value主要是描述该方法的用途 1234567891011121314151617181920212223242526package com.ledao.controller;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * 首页Controller * * @author LeDao * @company * @create 2021-10-05 17:35 */@Api(tags = &quot;首页Controller&quot;)@Controllerpublic class IndexController &#123; @ApiOperation(value = &quot;跳转到首页&quot;) @ResponseBody @GetMapping(&quot;/&quot;) public String root() &#123; return &quot;&lt;a href=&#x27;http://localhost:8080/student/delete?id=2&#x27;&gt;删除学生&lt;/a&gt;&quot;; &#125;&#125; 结果浏览器地址栏输入：http://localhost:8080/swagger-ui/ 可以看到项目中拥有的Controller类以及该类的方法 点击具体方法可以看到该方法返回的类型以及参数等 PS.Swagger3常用注解查看博客：Swagger3常用注解 | LeDao的博客 (zoutl.cn)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"Swagger3","slug":"Swagger3","permalink":"https://blog.zoutl.cn/tags/Swagger3/"}]},{"title":"MySQL使用视图","slug":"370","date":"2021-10-03T14:39:34.000Z","updated":"2022-04-14T02:33:57.116Z","comments":true,"path":"370.html","link":"","permalink":"https://blog.zoutl.cn/370.html","excerpt":"","text":"简介视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询，在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据 作用 重用SQL语句 简化复杂的SQL操作，在编写查询后，可以方便地重用它而不必知道它的基本查询细节 使用表的组成部分而不是整个表 保护数据，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限 更改数据格式和表示，视图可返回与底层表的表示和格式不同的数据 规则和限制 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字） 对于可以创建的视图数目没有限制 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖 视图不能索引，也不能有关联的触发器或默认值 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句 实例创建视图创建一个视图，该视图的作用为查询年龄大于10的学生 1CREATE VIEW more_than_ten_ages AS SELECT * FROM t_student WHERE age&gt;10; 使用视图查询年龄大于10并且班级id等于2的学生 1SELECT * FROM more_than_ten_ages WHERE class_id=2;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL组合查询","slug":"369","date":"2021-10-03T14:07:45.000Z","updated":"2022-04-14T02:33:53.783Z","comments":true,"path":"369.html","link":"","permalink":"https://blog.zoutl.cn/369.html","excerpt":"","text":"简介所谓组合查询，就是执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回 使用组合查询的两种情况： 在单个查询中从不同的表返回类似结构的数据 对单个表执行多个查询，按单个查询返回数据 多个SELECT语句之间使用UNION关键字连接，返回的是多条SELECT语句返回结果的并集（即去掉重复的结果，这是默认的），如果不想去掉重复的结果，就在UNION关键字后加上ALL 实例单个SELECT语句查询姓名中包含“赵”字的学生 1SELECT * FROM t_student WHERE student_name LIKE &#x27;%赵%&#x27;; 查询年龄大于10岁的学生 1SELECT * FROM t_student WHERE age&gt;10; 使用UNION返回两条SELECT语句结果的并集，去掉了重复的结果 1SELECT * FROM t_student WHERE student_name LIKE &#x27;%赵%&#x27; UNION SELECT * FROM t_student WHERE age&gt;10; 使用UNION ALL不去掉重复的结果 1SELECT * FROM t_student WHERE student_name LIKE &#x27;%赵%&#x27; UNION ALL SELECT * FROM t_student WHERE age&gt;10; 进行排序在SQL语句的最后加上ORDER BY即可 1SELECT * FROM t_student WHERE student_name LIKE &#x27;%赵%&#x27; UNION ALL SELECT * FROM t_student WHERE age&gt;10 ORDER BY id;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL使用联结","slug":"368","date":"2021-10-03T10:41:01.000Z","updated":"2022-04-14T02:34:27.114Z","comments":true,"path":"368.html","link":"","permalink":"https://blog.zoutl.cn/368.html","excerpt":"","text":"简介使用联结可以用一条SELECT语句检索出多个表的数据，使用联结的前提是表之间存在关联（一个表的除主键外的某一列，即：外键，是另一个表的主键），例如下图：（t_student的class_id是外键，表示班级和学生是一对多的关系，即一个班级有0个或多个学生） 实例使用where查询学生的班号、姓名、年龄 其中班号在表t_class、姓名和年龄在表t_student 表t_student的class_Id字段是外键 1SELECT class_num,student_name,age FROM t_class,t_student WHERE t_class.`id`=t_student.`class_id`; 使用inner join下面的SQL语句的作用和上一条语句的作用是一样的 1SELECT class_num,student_name,age FROM t_class INNER JOIN t_student ON t_class.`id`=t_student.`class_id`; 联结多个表 使用where 查询学生的班号、姓名、语文成绩、数学成绩、英语成绩 其中班号在表t_class，姓名和年龄在表t_student，语文成绩、数学成绩和英语成绩在表t_score2 外键：表t_student的class_id字段，表t_score2的student_id字段 1SELECT class_num,student_name,chinese_score,math_score,english_score FROM t_class,t_student,t_score2 WHERE t_class.`id`=t_student.`class_id` AND t_student.`id`=t_score2.`student_id`; 使用inner join 1SELECT class_num,student_name,chinese_score,math_score,english_score FROM t_class INNER JOIN t_student INNER JOIN t_score2 ON t_class.`id`=t_student.`class_Id` AND t_student.`id`=t_score2.`student_id`;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL使用子查询","slug":"367","date":"2021-10-03T09:11:24.000Z","updated":"2022-04-14T02:33:50.742Z","comments":true,"path":"367.html","link":"","permalink":"https://blog.zoutl.cn/367.html","excerpt":"","text":"简介介绍所谓子查询，就是嵌套在其他查询中的查询 版本要求要使用子查询，必须使用MySQL 4.1或更高级的版本 作用 过滤数据 作为计算字段使用 实例过滤数据查询 t_class 班级表的id小于3的班级的所有学生 1SELECT * FROM t_student WHERE class_id IN (SELECT id FROM t_class WHERE id&lt;3); 作为计算字段使用查询各个班号下的学生人数 1SELECT class_num,(SELECT COUNT(*) FROM t_student WHERE t_student.`class_id`=t_class.`id`) AS student_num FROM t_class;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL分组数据","slug":"366","date":"2021-09-18T05:31:06.000Z","updated":"2022-04-14T02:34:24.465Z","comments":true,"path":"366.html","link":"","permalink":"https://blog.zoutl.cn/366.html","excerpt":"","text":"GROUP BY简介数据分组使用GROUP BY子句，并且会根据分组的字段进行ASC排序 实例将学生按照年龄进行分组，并且统计每个年龄的学生人数，结果的排序为：年龄的升序 1SELECT age,COUNT(*) AS age_count FROM t_student GROUP BY age; HAVING简介分组的数据可以使用HAVING子句进行过滤，在GROUP BY后使用，HAVING后接一个条件，然后就可以筛选出满足条件的数据 实例将学生按照年龄进行分组且学生年龄大于11岁，并且统计每个年龄的学生人数，结果的排序为：年龄的升序 1SELECT age,COUNT(*) AS age_count FROM t_student GROUP BY age HAVING age&gt;11; 排序简介一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法，千万不要仅依赖GROUP BY排序数据 实例将学生按照年龄进行分组且学生年龄大于11岁，并且统计每个年龄的学生人数，结果的排序为：该年龄人数的升序 1SELECT age,COUNT(*) AS age_count FROM t_student GROUP BY age HAVING age&gt;11 ORDER BY age_count;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL汇总数据","slug":"365","date":"2021-09-17T10:10:59.000Z","updated":"2022-04-14T02:33:47.975Z","comments":true,"path":"365.html","link":"","permalink":"https://blog.zoutl.cn/365.html","excerpt":"","text":"聚集函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG()获取全部学生的平均年龄 1SELECT AVG(age) AS avg_age FROM t_student; COUNT()获取学生总数量 1SELECT COUNT(*) AS student_count FROM t_student; MAX()获取学生年龄的最大值 1SELECT MAX(age) AS max_age FROM t_student; MIN()获取学生年龄的最小值 1SELECT MIN(age) AS min_age FROM t_student; SUM()获取学生年龄的总和 1SELECT SUM(age) AS sum_age FROM t_student; 聚集不同值使用DISTINCT参数，只包含不同的值；DISTINCT参数的反义是ALL参数，包含所有的值，ALL参数是默认的 查询所有不同的学生年龄的值 1SELECT DISTINCT age FROM t_student; 组合聚集函数查询学生数量、平均年龄、年龄最大值、年龄最小值 1SELECT COUNT(*) AS student_count,AVG(age) AS avg_age,MAX(age) AS max_age,MIN(age) AS min_age FROM t_student;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL数据处理函数","slug":"364","date":"2021-09-17T01:34:24.000Z","updated":"2022-04-14T02:34:22.005Z","comments":true,"path":"364.html","link":"","permalink":"https://blog.zoutl.cn/364.html","excerpt":"","text":"文本处理函数常用函数 函数 说明 Left() 返回串左边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写 LTrim() 去掉串左边的空格 Right() 返回串右边的字符 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 Upper() 将串转换为大写 实例Left()从左边开始，截取前两位字符 1SELECT LEFT(&quot;123456&quot;,2); Right()从右边开始，截取后两位字符 1SELECT RIGHT(&quot;123456&quot;,2); Length()返回字符串”1234”的长度，长度为4 1SELECT LENGTH(&quot;1234&quot;); Locate()查看子串”12”在字符串”33312345612”中第一次出现的位置，结果为4 1SELECT LOCATE(&quot;12&quot;,&quot;33312345612&quot;); 从第6位开始查找，查看子串”12”在字符串”33312345612”中第一次出现的位置，结果为10 1SELECT LOCATE(&quot;12&quot;,&quot;33312345612&quot;,6); Lower()将字符串的所有大写字母转化为小写 1SELECT LOWER(&quot;aBcDe&quot;); Upper()将字符串的所有小写字母转化为大写 1SELECT UPPER(&quot;aBcDe&quot;); LTrim()去掉字符串左边的空格 1SELECT LTRIM(&quot; abc &quot;); RTrim()去掉字符串右边的空格 1SELECT RTRIM(&quot; abc &quot;); Trim()去掉字符串前后的空格 1SELECT TRIM(&quot; abcd &quot;); Soundex() SubString()截取从第三位开始的及后面的字符串,下面两个sql语句的结果是一样的 12SELECT SUBSTRING(&quot;123456&quot;,3);SELECT SUBSTRING(&quot;123456&quot; FROM 3); 截取从第二位开始的及后面的字符串，且截取的字符串长度为2 12SELECT SUBSTRING(&quot;123456&quot;,2,2);SELECT SUBSTRING(&quot;123456&quot; FROM 2 FOR 2); 日期和时间处理函数常用函数 函数 说明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 实例AddDate()给日期加两天 1SELECT ADDDATE(&quot;2021-09-17 10:34:11&quot;,2); 给日期加一天或周或月或年 12345678#加一天SELECT ADDDATE(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 DAY);#加一周SELECT ADDDATE(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 WEEK);#加一月SELECT ADDDATE(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 MONTH);#加一年SELECT ADDDATE(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 YEAR); AddTime()给日期加1天1小时1分1秒 1SELECT ADDTIME(&quot;2021-09-17 10:34:11&quot;,&quot;1 1:1:1&quot;); CurDate()返回当前日期 1SELECT CURDATE(); CurTime()返回当前时间 1SELECT CURTIME(); Date()返回日期时间的日期部分 1SELECT DATE(&quot;2021-09-17 10:34:11&quot;); DateDiff()返回两个日期之差（结果为天数）,前面的日期减去后面的 1SELECT DATEDIFF(&quot;2022-09-19 11:34:11&quot;,&quot;2021-09-18 10:34:11&quot;); Date_Add()高度灵活的日期运算函数，给一个时间添加秒、分、小时、天、月、年 1234567891011121314#加1天SELECT DATE_ADD(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 DAY);#加1周SELECT DATE_ADD(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 WEEK);#加1月SELECT DATE_ADD(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 MONTH);#加1年SELECT DATE_ADD(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 YEAR);#加1秒SELECT DATE_ADD(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 SECOND);#加1分SELECT DATE_ADD(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 MINUTE);#加1小时SELECT DATE_ADD(&quot;2021-09-17 10:34:11&quot;,INTERVAL 1 HOUR); Date_Format()格式化时间，第一个参数为要格式化的时间，第二个参数为格式 1SELECT DATE_FORMAT(&quot;2021-09-17 10:34:11&quot;,&quot;%Y年%m月%d日 %H时%i分%s秒&quot;); 以下是可用于构建日期格式字符串的说明符及其含义 以下是一些常用的日期格式字符串 Day()返回一个日期的天数部分 1SELECT DAY(&quot;2021-09-17 10:34:11&quot;); DayOfWeek()对于一个日期，返回对应的星期几 1SELECT DAYOFWEEK(&quot;2021-09-17 10:34:11&quot;); Hour()返回一个时间的小时部分 1SELECT HOUR(&quot;2021-09-17 10:34:11&quot;); Minute()返回一个时间的分钟部分 1SELECT MINUTE(&quot;2021-09-17 10:34:11&quot;); Month()返回一个日期的月份部分 1SELECT MONTH(&quot;2021-09-17 10:34:11&quot;); Now()返回当前日期和时间 1SELECT NOW(); Second()返回一个时间的秒部分 1SELECT SECOND(&quot;2021-09-17 10:34:11&quot;); Time()返回一个日期时间的时间部分 1SELECT TIME(&quot;2021-09-17 10:34:11&quot;); Year()返回一个日期的年份部分 1SELECT YEAR(&quot;2021-09-17 10:34:11&quot;); 数值处理函数常用函数 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 实例Abs()返回一个数的绝对值 1SELECT ABS(-1); Cos()返回一个角度的余弦 1SELECT COS(45); Exp()返回一个数的指数值，即：e的多少次方，e约等于2.718281828 1SELECT EXP(2); Mod()返回除操作的余数，前面参数除以后面的参数 1SELECT MOD(10,3); Pi()返回圆周率 1SELECT PI(); Rand()返回一个随机数，产生一个在 0 和 1 之间的随机数 1SELECT RAND(); Sin()返回一个角度的正弦 1SELECT SIN(30); Sqrt()返回一个数的平方根 1SELECT SQRT(4); Tan()返回一个角度的正切 1SELECT TAN(45);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"Spring Boot整合Shiro实现认证和授权","slug":"363","date":"2021-09-16T16:32:09.000Z","updated":"2022-04-14T02:18:35.737Z","comments":true,"path":"363.html","link":"","permalink":"https://blog.zoutl.cn/363.html","excerpt":"","text":"数据库新建数据库数据库命名为 db_shiro，可以直接导入我的数据库文件，那么就不需要查看下面的数据库操作了，sql文件地址为：a6678696/ShiroDemo: Spring Boot整合Shiro实现认证和授权 (github.com) 新建五张表 t_user用户表 t_user_role用户角色表 t_role为角色表 t_role_permission用户权限表 t_permission权限表 插入数据 t_user用户表 1insert into `t_user`(`id`,`userName`,`password`,`nickName`,`salt`) values (1,&#x27;ledao&#x27;,&#x27;8b8d72a8743e5102087b7d3e0423a729&#x27;,&#x27;乐道&#x27;,&#x27;gQKQEpNUeNhRDiGsd3RYqA==&#x27;),(2,&#x27;admin&#x27;,&#x27;838f8ca3ba499ede3585cddcb4d72f05&#x27;,&#x27;小明&#x27;,&#x27;uDCwdPYvZmym7WBNvsgh4Q==&#x27;); t_user_role用户角色表 1insert into `t_user_role`(`id`,`roleId`,`userId`) values (1,1,2),(2,2,2),(3,2,1); t_role角色表 1insert into `t_role`(`id`,`role`) values (1,&#x27;管理员&#x27;),(2,&#x27;教师&#x27;); t_role_permission用户权限表 1insert into `t_role_permission`(`id`,`roleId`,`permissionId`) values (1,1,1),(2,2,1),(3,1,2); t_permission权限表 1insert into `t_permission`(`id`,`permission`) values (1,&#x27;添加学生&#x27;),(2,&#x27;添加教师&#x27;); 表之间的关联 如果要查询某个用户拥有的所有权限，可以先根据用户的id获取该用户的所有角色（用户和角色是一对多的关系，即：一个用户可以拥有0个或多个角色），然后再根据角色的id获取该角色的权限（角色和权限是一对多的关系，即：一个角色可以拥有0个或多个权限），最后该用户的全部权限为：该用户的所有角色对应权限的集合 实现过程项目结构 启动类添加注解添加注解 @MapperScan(“com.ledao.mapper”) ，路径为存放Mapper接口的包 application.yml配置12345678910111213server: port: 80 servlet: context-path: /spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: 123456 url: jdbc:mysql://localhost:3306/db_shiro?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8 thymeleaf: cache: false pom.xml依赖配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 实体类 User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * 用户实体类 * * @author LeDao * @company * @create 2021-09-16 11:03 */@Data@TableName(value = &quot;t_user&quot;)public class User &#123; /** * 编号 */ @TableId private Integer id; /** * 用户名 */ @TableField(value = &quot;userName&quot;) private String userName; /** * 密码 */ private String password; /** * 盐值 */ private String salt; /** * 昵称 */ @TableField(value = &quot;nickName&quot;) private String nickName;&#125; UserRole.java 12345678910111213141516171819202122232425262728293031323334353637package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * 用户角色实体 * 用于绑定用户和角色,即:某个用户有什么角色 * * @author LeDao * @company * @create 2021-09-16 11:15 */@Data@TableName(value = &quot;t_user_role&quot;)public class UserRole &#123; /** * 编号 */ @TableId private Integer id; /** * 用户id */ @TableField(value = &quot;userId&quot;) private Integer userId; /** * 角色id */ @TableField(value = &quot;roleId&quot;) private Integer roleId;&#125; Role.java 12345678910111213141516171819202122232425262728package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * 角色实体类 * * @author LeDao * @company * @create 2021-09-16 11:12 */@Data@TableName(value = &quot;t_role&quot;)public class Role &#123; /** * 编号 */ @TableId private Integer id; /** * 角色名称 */ private String role;&#125; RolePermission.java 12345678910111213141516171819202122232425262728293031323334353637package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * 角色权限实体类 * 用于绑定角色和权限,即:某个角色有什么权限 * * @author LeDao * @company * @create 2021-09-16 11:19 */@Data@TableName(value = &quot;t_role_permission&quot;)public class RolePermission &#123; /** * 编号 */ @TableId private Integer id; /** * 角色id */ @TableField(value = &quot;roleId&quot;) private Integer roleId; /** * 权限id */ @TableField(value = &quot;permissionId&quot;) private Integer permissionId;&#125; Permission.java 12345678910111213141516171819202122232425262728package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * 权限实体类 * * @author LeDao * @company * @create 2021-09-16 11:18 */@Data@TableName(value = &quot;t_permission&quot;)public class Permission &#123; /** * 编号 */ @TableId private Integer id; /** * 权限名称 */ private String permission;&#125; Mapper接口 UserMapper.java 123456789101112package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.User;/** * @author LeDao * @company * @create 2021-09-16 11:46 */public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; UserRoleMapper.java 123456789101112package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.UserRole;/** * @author LeDao * @company * @create 2021-09-16 11:48 */public interface UserRoleMapper extends BaseMapper&lt;UserRole&gt; &#123;&#125; RoleMapper.java 123456789101112package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.Role;/** * @author LeDao * @company * @create 2021-09-16 11:47 */public interface RoleMapper extends BaseMapper&lt;Role&gt; &#123;&#125; RolePermissionMapper.java 123456789101112package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.RolePermission;/** * @author LeDao * @company * @create 2021-09-16 11:49 */public interface RolePermissionMapper extends BaseMapper&lt;RolePermission&gt; &#123;&#125; PermissionMapper.java 123456789101112package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.Permission;/** * @author LeDao * @company * @create 2021-09-16 11:49 */public interface PermissionMapper extends BaseMapper&lt;Permission&gt; &#123;&#125; Service接口 UserService.java 1234567891011121314151617181920package com.ledao.service;import com.baomidou.mybatisplus.extension.service.IService;import com.ledao.entity.User;/** * @author LeDao * @company * @create 2021-09-16 11:56 */public interface UserService extends IService&lt;User&gt; &#123; /** * 根据用户名获取用户信息 * * @param userName * @return */ User findByUserName(String userName);&#125; UserRoleService.java 1234567891011121314151617181920212223package com.ledao.service;import com.baomidou.mybatisplus.extension.service.IService;import com.ledao.entity.User;import com.ledao.entity.UserRole;import java.util.List;/** * @author LeDao * @company * @create 2021-09-16 12:52 */public interface UserRoleService extends IService&lt;UserRole&gt; &#123; /** * 根据用户id获取用户的角色 * * @param userId * @return */ List&lt;UserRole&gt; findByUserId(Integer userId);&#125; RoleService.java 1234567891011121314151617181920package com.ledao.service;import com.baomidou.mybatisplus.extension.service.IService;import com.ledao.entity.Role;/** * @author LeDao * @company * @create 2021-09-16 12:59 */public interface RoleService extends IService&lt;Role&gt; &#123; /** * 根据id获取角色 * * @param id * @return */ Role findById(Integer id);&#125; RolePermissionService.java 12345678910111213141516171819202122package com.ledao.service;import com.baomidou.mybatisplus.extension.service.IService;import com.ledao.entity.RolePermission;import java.util.List;/** * @author LeDao * @company * @create 2021-09-16 13:08 */public interface RolePermissionService extends IService&lt;RolePermission&gt; &#123; /** * 根据角色id获取该角色的所有权限 * * @param roleId * @return */ List&lt;RolePermission&gt; findByRoleId(Integer roleId);&#125; PermissionService.java 1234567891011121314151617181920package com.ledao.service;import com.baomidou.mybatisplus.extension.service.IService;import com.ledao.entity.Permission;/** * @author LeDao * @company * @create 2021-09-16 13:41 */public interface PermissionService extends IService&lt;Permission&gt; &#123; /** * 根据id获取权限 * * @param id * @return */ Permission findById(Integer id);&#125; Service接口实现类 UserServiceImpl.java 1234567891011121314151617181920212223242526272829package com.ledao.service.impl;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.ledao.entity.User;import com.ledao.mapper.UserMapper;import com.ledao.service.UserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * @author LeDao * @company * @create 2021-09-16 11:59 */@Service(&quot;userService&quot;)public class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService &#123; @Resource private UserMapper userMapper; @Override public User findByUserName(String userName) &#123; QueryWrapper&lt;User&gt; userQueryWrapper = new QueryWrapper&lt;&gt;(); userQueryWrapper.eq(&quot;userName&quot;, userName); return userMapper.selectOne(userQueryWrapper); &#125;&#125; UserRoleServiceImpl.java 123456789101112131415161718192021222324252627282930package com.ledao.service.impl;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.ledao.entity.UserRole;import com.ledao.mapper.UserRoleMapper;import com.ledao.service.UserRoleService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;/** * @author LeDao * @company * @create 2021-09-16 12:54 */@Service(&quot;userRoleService&quot;)public class UserRoleServiceImpl extends ServiceImpl&lt;UserRoleMapper,UserRole&gt; implements UserRoleService &#123; @Resource private UserRoleMapper userRoleMapper; @Override public List&lt;UserRole&gt; findByUserId(Integer userId) &#123; QueryWrapper&lt;UserRole&gt; userRoleQueryWrapper = new QueryWrapper&lt;&gt;(); userRoleQueryWrapper.eq(&quot;userId&quot;, userId); return userRoleMapper.selectList(userRoleQueryWrapper); &#125;&#125; RoleServiceImpl.java 1234567891011121314151617181920212223242526package com.ledao.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.ledao.entity.Role;import com.ledao.mapper.RoleMapper;import com.ledao.service.RoleService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * @author LeDao * @company * @create 2021-09-16 13:00 */@Service(&quot;roleService&quot;)public class RoleServiceImpl extends ServiceImpl&lt;RoleMapper,Role&gt; implements RoleService &#123; @Resource private RoleMapper roleMapper; @Override public Role findById(Integer id) &#123; return roleMapper.selectById(id); &#125;&#125; RolePermissionServiceImpl.java 123456789101112131415161718192021222324252627282930package com.ledao.service.impl;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.ledao.entity.RolePermission;import com.ledao.mapper.RolePermissionMapper;import com.ledao.service.RolePermissionService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;/** * @author LeDao * @company * @create 2021-09-16 13:11 */@Service(&quot;rolePermissionService&quot;)public class RolePermissionServiceImpl extends ServiceImpl&lt;RolePermissionMapper,RolePermission&gt; implements RolePermissionService &#123; @Resource private RolePermissionMapper rolePermissionMapper; @Override public List&lt;RolePermission&gt; findByRoleId(Integer roleId) &#123; QueryWrapper&lt;RolePermission&gt; rolePermissionQueryWrapper = new QueryWrapper&lt;&gt;(); rolePermissionQueryWrapper.eq(&quot;roleId&quot;, roleId); return rolePermissionMapper.selectList(rolePermissionQueryWrapper); &#125;&#125; PermissionServiceImpl.java 1234567891011121314151617181920212223242526package com.ledao.service.impl;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.ledao.entity.Permission;import com.ledao.mapper.PermissionMapper;import com.ledao.service.PermissionService;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * @author LeDao * @company * @create 2021-09-16 13:41 */@Service(&quot;permissionService&quot;)public class PermissionServiceImpl extends ServiceImpl&lt;PermissionMapper,Permission&gt; implements PermissionService &#123; @Resource private PermissionMapper permissionMapper; @Override public Permission findById(Integer id) &#123; return permissionMapper.selectById(id); &#125;&#125; 自定义Realm123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.ledao.realm;import com.ledao.entity.*;import com.ledao.service.*;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import javax.annotation.Resource;import java.util.List;/** * 自定义Realm * * @author LeDao * @company * @create 2021-09-16 11:44 */public class MyShiroRealm extends AuthorizingRealm &#123; @Resource private UserService userService; @Resource private UserRoleService userRoleService; @Resource private RoleService roleService; @Resource private RolePermissionService rolePermissionService; @Resource private PermissionService permissionService; /** * 授权 * * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); //获取已登录用户的用户名 String userName = (String) principalCollection.getPrimaryPrincipal(); //控制台打印用户名 System.out.println(userName); //获取用户的id Integer userId = userService.findByUserName(userName).getId(); //查询该用户的所有角色 List&lt;UserRole&gt; userRoleList = userRoleService.findByUserId(userId); //如果该用户拥有角色 if (userRoleList.size() &gt; 0) &#123; for (UserRole userRole : userRoleList) &#123; //获取当前角色实体 Role role = roleService.findById(userRole.getRoleId()); //向Shiro添加角色的名称 simpleAuthorizationInfo.addRole(role.getRole()); //控制台打印角色的名称 System.out.println(role.getRole()); //获取该角色的全部权限 List&lt;RolePermission&gt; rolePermissionList = rolePermissionService.findByRoleId(role.getId()); if (rolePermissionList.size() &gt; 0) &#123; for (RolePermission rolePermission : rolePermissionList) &#123; //获取当前权限实体 Permission permission = permissionService.findById(rolePermission.getPermissionId()); //向Shiro添加权限的名称 simpleAuthorizationInfo.addStringPermission(permission.getPermission()); //控制台打印权限的名称 System.out.println(permission.getPermission()); &#125; &#125; &#125; &#125; return simpleAuthorizationInfo; &#125; /** * 认证 * * @param authenticationToken * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String userName = (String) authenticationToken.getPrincipal(); User user = userService.findByUserName(userName); if (user != null) &#123; return new SimpleAuthenticationInfo(user.getUserName(), user.getPassword(), getName()); &#125; else &#123; return null; &#125; &#125;&#125; Shiro配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.ledao.config;import com.ledao.realm.MyShiroRealm;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.LifecycleBeanPostProcessor;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import java.util.HashMap;import java.util.Map;/** * Shiro配置 * * @author LeDao * @company * @create 2021-09-16 14:09 */@Configurationpublic class ShiroConfig &#123; /** * 定义拦截器 * * @param securityManager * @return */ @Bean public ShiroFilterFactoryBean shiroFilter(SecurityManager securityManager) &#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager); //拦截器 Map&lt;String, String&gt; filterChainDefinitionMap = new HashMap&lt;&gt;(16); // 配置不会被拦截的链接 顺序判断 filterChainDefinitionMap.put(&quot;/static/**&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/toLoginPage&quot;, &quot;anon&quot;); filterChainDefinitionMap.put(&quot;/user/login&quot;, &quot;anon&quot;); // 配置退出 过滤器,其中的具体的退出代码Shiro已经替我们实现了 filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;); // &lt;!-- 过滤链定义，从上向下顺序执行，一般将/**放在最为下边 --&gt;:这是一个坑呢，一不小心代码就不好使了; // &lt;!-- authc:所有url都必须认证通过才可以访问; anon:所有url都都可以匿名访问--&gt; filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;); // 如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面 shiroFilterFactoryBean.setLoginUrl(&quot;/toLoginPage&quot;); // 登录成功后要跳转的链接 shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; &#125; /** * 定义自己的Realm * * @return */ @Bean public MyShiroRealm myShiroRealm() &#123; return new MyShiroRealm(); &#125; @Bean public SecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myShiroRealm()); return securityManager; &#125; /** * Shiro生命周期处理器 * * @return */ @Bean public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() &#123; return new LifecycleBeanPostProcessor(); &#125; /** * 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证 * 配置以下两个bean(DefaultAdvisorAutoProxyCreator(可选)和AuthorizationAttributeSourceAdvisor)即可实现此功能 * * @return */ @Bean @DependsOn(&#123;&quot;lifecycleBeanPostProcessor&quot;&#125;) public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator() &#123; DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator(); advisorAutoProxyCreator.setProxyTargetClass(true); return advisorAutoProxyCreator; &#125; @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() &#123; AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager()); return authorizationAttributeSourceAdvisor; &#125;&#125; Controller类 IndexController.java 1234567891011121314151617181920212223242526272829303132333435363738package com.ledao.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/** * @author LeDao * @company * @create 2021-09-16 14:19 */@Controllerpublic class IndexController &#123; /** * 首页 * * @return */ @RequestMapping(&#123;&quot;/&quot;, &quot;/index&quot;&#125;) public ModelAndView index() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;index&quot;); return mav; &#125; /** * 跳转到登录页面 * * @return */ @RequestMapping(&quot;/toLoginPage&quot;) public ModelAndView toLoginPage() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;login&quot;); return mav; &#125;&#125; UserController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.ledao.controller;import com.ledao.entity.User;import com.ledao.service.*;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.annotation.RequiresPermissions;import org.apache.shiro.crypto.hash.SimpleHash;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.annotation.Resource;import javax.servlet.http.HttpSession;/** * @author LeDao * @company * @create 2021-09-16 19:32 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Resource private UserService userService; /** * 登录 * * @param user * @param session * @return */ @RequestMapping(&quot;/login&quot;) public ModelAndView login(User user, HttpSession session) &#123; ModelAndView mav = new ModelAndView(); User currentUser = userService.findByUserName(user.getUserName()); if (currentUser != null) &#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(user.getUserName(), getEncodePassword(&quot;md5&quot;, user.getPassword(), currentUser.getSalt(), 2)); try &#123; subject.login(token); session.setAttribute(&quot;currentUser&quot;, currentUser); mav.setViewName(&quot;index&quot;); &#125; catch (AuthenticationException e) &#123;//登录失败 e.printStackTrace(); mav.addObject(&quot;error&quot;, &quot;用户名或密码错误!!&quot;); mav.addObject(&quot;user&quot;, user); mav.setViewName(&quot;login&quot;); &#125; &#125; else &#123;//用户不存在 mav.addObject(&quot;error&quot;, &quot;用户名或密码错误!!&quot;); mav.addObject(&quot;user&quot;, user); mav.setViewName(&quot;login&quot;); &#125; return mav; &#125; /** * 添加学生 * * @return */ @ResponseBody @RequestMapping(&quot;/addStudent&quot;) @RequiresPermissions(value = &quot;添加学生&quot;) public String addStudent() &#123; return &quot;添加学生成功&quot;; &#125; /** * 添加教师 * * @return */ @ResponseBody @RequestMapping(&quot;/addTeacher&quot;) @RequiresPermissions(value = &quot;添加教师&quot;) public String addTeacher() &#123; return &quot;添加教师成功&quot;; &#125; /** * 获取md5加密后的密码 * * @param encryptName 加密算法名称 * @param password 加密前的密码 * @param salt 盐值 * @param times 加密次数 * @return */ private static String getEncodePassword(String encryptName, String password, String salt, Integer times) &#123; return new SimpleHash(encryptName, password, salt, times).toString(); &#125;&#125; HTML页面 login.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/user/login&quot; method=&quot;post&quot; style=&quot;width: 40%;margin-left: 27%;margin-top: 8%&quot;&gt; &lt;h1 style=&quot;text-align: center&quot;&gt;登录&lt;/h1&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userName&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;userName&quot; name=&quot;userName&quot; class=&quot;form-control&quot; th:value=&quot;$&#123;user==null?&#x27;&#x27;:user.userName&#125;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; th:value=&quot;$&#123;user==null?&#x27;&#x27;:user.password&#125;&quot;&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; class=&quot;btn btn-primary&quot;&gt;&lt;span style=&quot;color: red&quot; th:text=&quot;$&#123;error&#125;&quot;&gt;&lt;/span&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.html 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=&quot;text-align: center&quot;&gt;首页&lt;/h1&gt;&lt;h4 style=&quot;text-align: center&quot;&gt; 当前用户:&lt;span th:text=&quot;$&#123;session.currentUser.nickName&#125;&quot;&gt;&lt;/span&gt;&lt;/h4&gt;&lt;div style=&quot;text-align: center&quot;&gt; &lt;a href=&quot;/logout&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-danger&quot;&gt;注销登录&lt;/button&gt;&lt;/a&gt; &lt;a href=&quot;/user/addTeacher&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;添加教师&lt;/button&gt;&lt;/a&gt; &lt;a href=&quot;/user/addStudent&quot;&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-info&quot;&gt;添加学生&lt;/button&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试运行项目后，在浏览器地址栏输入：localhost/index ，无法访问首页会直接重定向到 localhost/toLoginPage ，这是因为此时没有登录所以不能访问首页 登录成功后，即可进入首页 数据库中有两个用户，用户一：用户名leadao密码123456，用户二：用户名admin密码admin 用户一只有添加学生的权限，所以可以添加学生，但是添加教师时会报错 用户二有添加学生和添加教师的权限，所以可以添加学生和教师 用户一和用户二都可以注销登录 GitHub地址本例子的GitHub地址为：a6678696/ShiroDemo: Spring Boot整合Shiro实现认证和授权 (github.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"Shiro","slug":"Shiro","permalink":"https://blog.zoutl.cn/tags/Shiro/"}]},{"title":"Shiro加密","slug":"362","date":"2021-09-15T13:20:32.000Z","updated":"2022-04-14T02:18:32.509Z","comments":true,"path":"362.html","link":"","permalink":"https://blog.zoutl.cn/362.html","excerpt":"","text":"Java代码1234567891011121314151617181920212223242526package com.ledao;import org.apache.shiro.crypto.SecureRandomNumberGenerator;import org.apache.shiro.crypto.hash.SimpleHash;/** * @author LeDao * @company * @create 2021-09-14 11:10 */public class Test &#123; public static void main(String[] args) &#123; //原始密码 String password = &quot;123456&quot;; //随机盐值 String salt = new SecureRandomNumberGenerator().nextBytes().toString(); //加密次数 int times = 2; //加密算法 String encryptName = &quot;md5&quot;; //加密后的密码 String encodePassword = new SimpleHash(encryptName, password, salt, times).toString(); System.out.println(encodePassword); &#125;&#125; 测试每次的加密结果都不同，因为每次的盐值都不同","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://blog.zoutl.cn/tags/Shiro/"}]},{"title":"Shiro自定义Realm实现认证和授权","slug":"361","date":"2021-09-15T11:46:12.000Z","updated":"2022-04-14T02:18:30.108Z","comments":true,"path":"361.html","link":"","permalink":"https://blog.zoutl.cn/361.html","excerpt":"","text":"自定义Realm新建一个MyRealm类，继承Shiro框架的AuthorizingRealm类，并实现默认的两个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.ledao.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;/** * 自定义Realm实现认证和授权 * * @author LeDao * @company * @create 2021-09-15 19:49 */public class MyRealm extends AuthorizingRealm &#123; /** * 授权 * * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String userName = (String) principalCollection.getPrimaryPrincipal(); //获取角色 Set&lt;String&gt; roles = getRolesByUserName(userName); //获取权限 Set&lt;String&gt; permissions = getPermissionsByUserName(userName); SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo(); simpleAuthorizationInfo.setRoles(roles); simpleAuthorizationInfo.setStringPermissions(permissions); return simpleAuthorizationInfo; &#125; /** * 认证 * * @param authenticationToken 从主体传过来的认证信息 * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //从主体传过来的认证信息中获得用户名 String userName = (String) authenticationToken.getPrincipal(); //根据用户名获取密码 String password = getPasswordByUserName(userName); if (password == null) &#123; return null; &#125; SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(userName, password, &quot;myRealm&quot;); return simpleAuthenticationInfo; &#125; /** * 存储用户的用户名和密码,用于模拟数据库 */ Map&lt;String, String&gt; userMap = new HashMap&lt;&gt;(16); &#123; //加入一个用户名为ledao,密码为123456的用户 userMap.put(&quot;ledao&quot;, &quot;123456&quot;); //设置自定义Realm的名称,取什么无所谓 super.setName(&quot;myRealm&quot;); &#125; /** * 模拟从数据库根据用户名获取密码 * * @param userName 用户名 * @return */ private String getPasswordByUserName(String userName) &#123; return userMap.get(userName); &#125; /** * 模拟从数据库中根据用户名获取角色数据 * * @param userName 用户名 * @return */ private Set&lt;String&gt; getRolesByUserName(String userName) &#123; Set&lt;String&gt; roles = new HashSet&lt;&gt;(); roles.add(&quot;admin&quot;); roles.add(&quot;teacher&quot;); return roles; &#125; /** * 拟从数据库中根据用户名获取权限数据 * * @param userName 用户名 * @return */ private Set&lt;String&gt; getPermissionsByUserName(String userName) &#123; Set&lt;String&gt; permissions = new HashSet&lt;&gt;(); permissions.add(&quot;添加学生&quot;); permissions.add(&quot;添加教师&quot;); return permissions; &#125;&#125; 测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ledao;import com.ledao.realm.MyRealm;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationException;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.subject.Subject;/** * @author LeDao * @company * @create 2021-09-14 11:10 */public class Test &#123; public static void main(String[] args) &#123; MyRealm myRealm = new MyRealm(); //构建securityManager环境 DefaultSecurityManager securityManager = new DefaultSecurityManager(); //securityManager环境添加自定义Realm securityManager.setRealm(myRealm); //提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获取当前securityManager环境的subject主体 Subject subject = SecurityUtils.getSubject(); //设置登录用户的token UsernamePasswordToken token = new UsernamePasswordToken(&quot;ledao&quot;, &quot;123456&quot;); try &#123; //登录 subject.login(token); System.out.println(subject.isAuthenticated() ? &quot;登录成功&quot; : &quot;登录失败&quot;); try &#123; //检查成功登录的用户是否有admin和teacher两个角色 subject.checkRoles(&quot;admin&quot;, &quot;teacher&quot;); try &#123; //检查成功登录的用户是否有admin和teacher1两个角色 subject.checkPermissions(&quot;添加学生&quot;, &quot;添加教师&quot;); &#125; catch (AuthorizationException e) &#123; e.printStackTrace(); System.out.println(&quot;登录的用户与检查的权限不相符!!&quot;); &#125; &#125; catch (AuthorizationException e) &#123; e.printStackTrace(); System.out.println(&quot;登录的用户与检查的角色不相符!!&quot;); &#125; &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); System.out.println(&quot;用户名或密码错误!!&quot;); &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://blog.zoutl.cn/tags/Shiro/"}]},{"title":"Shiro授权","slug":"360","date":"2021-09-15T03:10:02.000Z","updated":"2022-04-14T02:18:28.084Z","comments":true,"path":"360.html","link":"","permalink":"https://blog.zoutl.cn/360.html","excerpt":"","text":"授权过程 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ledao;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.AuthorizationException;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;/** * @author LeDao * @company * @create 2021-09-14 11:10 */public class Test &#123; public static void main(String[] args) &#123; SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); //添加一个用户,该用户的角色有admin和teacher simpleAccountRealm.addAccount(&quot;ledao&quot;, &quot;123456&quot;, &quot;admin&quot;, &quot;teacher&quot;); //构建securityManager环境 DefaultSecurityManager securityManager = new DefaultSecurityManager(); //将上面的用户交给securityManager管理 securityManager.setRealm(simpleAccountRealm); //提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获取当前securityManager环境的subject主体 Subject subject = SecurityUtils.getSubject(); subject.checkRoles(&quot;admin&quot;, &quot;teacher1&quot;); //设置登录用户的token UsernamePasswordToken token = new UsernamePasswordToken(&quot;ledao&quot;, &quot;123456&quot;); try &#123; //登录 subject.login(token); //查看是否登录成功 System.out.println(subject.isAuthenticated() ? &quot;登录成功&quot; : &quot;登录失败&quot;); try &#123; //检查成功登录的用户是否有admin和teacher1两个角色 subject.checkRoles(&quot;admin&quot;, &quot;teacher1&quot;); &#125; catch (AuthorizationException e) &#123; e.printStackTrace(); System.out.println(&quot;登录的用户与检查的角色不相符!!&quot;); &#125; &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); System.out.println(&quot;用户名或密码错误!!&quot;); &#125; &#125;&#125; 测试如果subject.checkRoles(“admin”, “teacher1”)，那么程序会报错，提示没有teacher1这个角色；如果subject.checkRoles(“admin”, “teacher”)，那么程序不会报错","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://blog.zoutl.cn/tags/Shiro/"}]},{"title":"Shiro认证","slug":"359","date":"2021-09-14T10:13:22.000Z","updated":"2022-04-14T02:18:26.664Z","comments":true,"path":"359.html","link":"","permalink":"https://blog.zoutl.cn/359.html","excerpt":"","text":"认证过程 代码实现引入Shiro依赖123456&lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ledao;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;/** * @author LeDao * @company * @create 2021-09-14 11:10 */public class Test &#123; public static void main(String[] args) &#123; SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); //添加一个用户,参数为正确的用户名和密码 simpleAccountRealm.addAccount(&quot;ledao&quot;, &quot;123456&quot;); //构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); //将用户信息放入SecurityManager环境 defaultSecurityManager.setRealm(simpleAccountRealm); //主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); //获取构建SecurityManager环境的当前用户 Subject subject = SecurityUtils.getSubject(); //设置一个token用于登录,参数分别为用户登录的用户名和密码 UsernamePasswordToken token = new UsernamePasswordToken(&quot;ledao&quot;, &quot;123456&quot;); //当前状态为未登录,所以输出false System.out.println(&quot;当前登录状态为:&quot; + subject.isAuthenticated()); try &#123; //登录 subject.login(token); //当前状态为登录成功,所以输出true System.out.println(&quot;当前登录状态为:&quot; + subject.isAuthenticated()); //注销登录 subject.logout(); System.out.println(&quot;当前登录状态为:&quot; + subject.isAuthenticated()); &#125; catch (AuthenticationException e) &#123; e.printStackTrace(); System.out.println(&quot;用户名或密码错误&quot;); &#125; &#125;&#125; 测试 当token的两个参数和正确的用户名密码一致时，登录成功 不一致时，登录失败","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://blog.zoutl.cn/tags/Shiro/"}]},{"title":"Java内部类","slug":"358","date":"2021-09-13T00:42:14.000Z","updated":"2022-04-14T02:18:24.724Z","comments":true,"path":"358.html","link":"","permalink":"https://blog.zoutl.cn/358.html","excerpt":"","text":"概述在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致 内部类可以分为四种：静态内部类、成员内部类、局部内部类和匿名内部类 优点 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据 内部类不为同一包的其他类所见，具有很好的封装性 内部类有效实现了“多重继承”，优化 java 单继承的缺陷 匿名内部类可以很方便的定义回调 应用场景 一些多算法场合 解决一些非面向对象的语句块 适当使用内部类，使得代码更加灵活和富有扩展性 当某个类除了它的外部类，不再被其他的类使用时 实现静态内部类 概念 定义在类内部的静态类，就是静态内部类 静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量，静态内部类的创建方式：new 外部类.静态内部类() 代码实现 12345678910111213141516171819202122/** * 静态内部类 * * @author LeDao * @company * @create 2021-09-13 9:19 */public class Outer &#123; private static final int A = 1; static class StaticInner &#123; public void test() &#123; System.out.println(A); &#125; &#125; public static void main(String[] args) &#123; Outer.StaticInner inner = new Outer.StaticInner(); inner.test(); &#125;&#125; 成员内部类 概念 定义在类内部，成员位置上的非静态类，就是成员内部类 成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式：外部类实例.new 内部类() 代码实现 12345678910111213141516171819202122232425/** * 成员内部类 * * @author LeDao * @company * @create 2021-09-13 9:19 */public class Outer &#123; int a = 1; private static final int B = 2; class Inner &#123; public void test() &#123; System.out.println(a); System.out.println(B); &#125; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.test(); &#125;&#125; 局部内部类 概念 定义在方法中的内部类，就是局部内部类 定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法，局部内部类的创建方式：在对应方法内，new 内部类() 代码实现 12345678910111213141516171819202122232425262728293031/** * 局部内部类 * * @author LeDao * @company * @create 2021-09-13 9:19 */public class Outer &#123; int out_a = 1; private static final int STATIC_B = 2; public void test() &#123; int inner_c = 3; class Inner &#123; void fun() &#123; System.out.println(out_a); System.out.println(STATIC_B); System.out.println(inner_c); &#125; &#125; Inner inner = new Inner(); inner.fun(); &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); outer.test(); &#125;&#125; 匿名内部类 概念 匿名内部类就是没有名字的内部类，日常开发中使用的比较多 除了没有名字，匿名内部类还有以下特点： 匿名内部类必须继承一个抽象类或者实现一个接口 匿名内部类不能定义任何静态成员和静态方法 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法 代码实现 123456789101112131415161718192021222324252627282930313233343536/** * 匿名内部类 * * @author LeDao * @company * @create 2021-09-13 9:19 */public class Outer &#123; public static void main(String[] args) &#123; //测试方法1 new Service() &#123; @Override public void method() &#123; System.out.println(&quot;匿名内部类测试1&quot;); &#125; &#125;.method(); //测试方法2 Service service = new Service() &#123; @Override public void method() &#123; System.out.println(&quot;匿名内部类测试2&quot;); &#125; &#125;; service.method(); &#125;&#125;interface Service &#123; /** * 测试接口1 */ void method();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Docker搭建RabbitMQ集群","slug":"357","date":"2021-09-10T15:06:11.000Z","updated":"2022-04-14T02:39:52.643Z","comments":true,"path":"357.html","link":"","permalink":"https://blog.zoutl.cn/357.html","excerpt":"","text":"拉取镜像拉取RabbitMQ镜像 1docker pull rabbitmq 创建Docker网卡创建一个RabbitMQ的Docker网卡 1docker network create rabbitmqnet 创建RabbitMQ容器分别执行下面3条命令创建3个RabbitMQ容器： 创建RabbitMQ容器1 1docker run -d --name=rabbitmq1 -p 5673:5672 -p 15673:15672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -e RABBITMQ_NODENAME=rabbitmq1 -e RABBITMQ_ERLANG_COOKIE=&#x27;YZSDHWMFSMKEMBDHSGGZ&#x27; -h rabbitmq1 --net=rabbitmqnet RabbitMQ镜像id 创建RabbitMQ容器2 1docker run -d --name=rabbitmq2 -p 5674:5672 -p 15674:15672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -e RABBITMQ_NODENAME=rabbitmq2 -e RABBITMQ_ERLANG_COOKIE=&#x27;YZSDHWMFSMKEMBDHSGGZ&#x27; -h rabbitmq2 --net=rabbitmqnet RabbitMQ镜像id 创建RabbitMQ容器3 1docker run -d --name=rabbitmq3 -p 5675:5672 -p 15675:15672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -e RABBITMQ_NODENAME=rabbitmq3 -e RABBITMQ_ERLANG_COOKIE=&#x27;YZSDHWMFSMKEMBDHSGGZ&#x27; -h rabbitmq3 --net=rabbitmqnet RabbitMQ镜像id 实现集群分别进入RabbitMQ容器2、RabbitMQ容器3，进入容器命令如下： 1docker exec -it RabbitMQ容器id或名称 /bin/bash 在两个容器内部都执行下面的4条命令： 1234rabbitmqctl stop_apprabbitmqctl resetrabbitmqctl join_cluster --ram rabbitmq1@rabbitmq1rabbitmqctl start_app 退出RabbitMQ容器快捷键：CTRL+P+Q，只退出不停止容器 测试浏览器地址栏输入：http://虚拟机IP:15672/ ，并输入用户名admin和密码admin，进入RabbitMQ图形管理页面","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现延时队列","slug":"356","date":"2021-09-09T03:25:30.000Z","updated":"2022-04-14T02:18:20.118Z","comments":true,"path":"356.html","link":"","permalink":"https://blog.zoutl.cn/356.html","excerpt":"","text":"简介延时队列，首先，它是一种队列，队列意味着内部的元素是有序的，元素出队和入队是有方向性的，元素从一端进入，从另一端取出。 其次，延时队列，最重要的特性就体现在它的延时属性上，跟普通的队列不一样的是，普通队列中的元素总是等着希望被早点取出处理，而延时队列中的元素则是希望被在指定时间得到取出和处理，所以延时队列中的元素是都是带时间属性的，通常来说是需要被处理的消息或者任务。 简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列，延时时间到了消息才会进入队列中等待着被消费 使用场景那么什么时候需要用延时队列呢？考虑一下以下场景： 订单在十分钟之内未支付则自动取消 新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒 账单在一周内未支付，则自动结算 用户注册成功后，如果三天内没有登陆则进行短信提醒 用户发起退款，如果三天内没有得到处理则通知相关运营人员 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议 实现方式实现方式有两种： 使用TTL+死信队列 利用RabbitMQ插件，推荐使用此方式 TTL+死信队列生产者生产一条消息发送到TTL交换机，然后分发到TTL队列，消息在队列中待到过期后才会发送到死信交换机，然后分发到死信队列供消费者消费 这种方式的弊端，无法做到通用性，每搞一个新的延迟任务，都要去实现一个实现的TTL+死信队列，比较麻烦，所以不推荐使用 利用RabbitMQ插件生产者生产一条消息发送到延时交换机，延时时间结束消息才会进入队列供消费者消费 下载插件 RabbitMQ插件地址：Community Plugins — RabbitMQ ，进入GitHub下载页面插件 下载最新版本，直接点击链接即可下载 安装插件 先将插件上传到虚拟机的 /home/data 目录下，然后将插件复制到RabbitMQ容器的 /plugins 目录下 1docker cp /home/data/rabbitmq_delayed_message_exchange-3.9.0.ez RabbitMQ容器id或名称:/plugins 进入RabbitMQ容器 1docker exec -it RabbitMQ容器id或名称 /bin/bash 安装命令 1rabbitmq-plugins enable rabbitmq_delayed_message_exchange 重启Rabbit容器 1docker restart RabbitMQ容器id或名称 实现过程 rabbitmq-common模块的RabbitMQConfig添加以下配置创建delayed交换机、队列，以及队列和交换机绑定 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * delayed交换机 */public static final String DELAYED_EXCHANGE = &quot;delayedExchange&quot;;/** * delayed队列 */public static final String DELAYED_QUEUE = &quot;delayedQueue&quot;;/** * delayed路由key */public static final String DELAYED_ROUTING_KEY = &quot;delayedRoutingKey&quot;;/** * 定义delayed交换机 * * @return */@Beanpublic CustomExchange delayedExchange() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;x-delayed-type&quot;, &quot;direct&quot;); return new CustomExchange(DELAYED_EXCHANGE, &quot;x-delayed-message&quot;, true, false, map);&#125;/** * 定义delayed队列 * * @return */@Beanpublic Queue delayedQueue() &#123; return new Queue(DELAYED_QUEUE);&#125;/** * delayed队列绑定delayed交换机 * * @return */@Beanpublic Binding delayedBinding() &#123; return BindingBuilder.bind(delayedQueue()).to(delayedExchange()).with(DELAYED_ROUTING_KEY).noargs();&#125; rabbitmq-producer模块的RabbitMQProducerService类添加一个接口方法： 1234567/** * 发送延时消息 * * @param message 消息内容 * @param delayTime 延时时间,单位为毫秒 */void sendMessageDelayed(String message, Integer delayTime); rabbitmq-producer模块的RabbitMQProducerServiceImpl类实现上面的接口方法： 1234567@Overridepublic void sendMessageDelayed(String message, Integer delayTime) &#123; rabbitTemplate.convertAndSend(RabbitMQConfig.DELAYED_EXCHANGE,RabbitMQConfig.DELAYED_ROUTING_KEY,message,a-&gt;&#123; a.getMessageProperties().setDelay(delayTime); return a; &#125;);&#125; 修改rabbitmq-producer模块的启动类，实现启动就发送两条延时消息 123456789101112131415161718192021222324package com.ledao.producer;import com.ledao.producer.service.RabbitMQProducerService;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;/** * 提供者启动类 * * @author LeDao * @company * @create 2021-09-04 12:26 */@SpringBootApplicationpublic class ProducerApplication &#123; public static void main(String[] args) &#123; ApplicationContext ac = SpringApplication.run(ProducerApplication.class, args); RabbitMQProducerService rabbitMQProducerService = (RabbitMQProducerService) ac.getBean(&quot;rabbitMQProducerService&quot;); rabbitMQProducerService.sendMessageDelayed(&quot;延时消息1&quot;,10000); rabbitMQProducerService.sendMessageDelayed(&quot;延时消息2&quot;,20000); &#125;&#125; rabbitmq-consumer模块的RabbitMQConsumerService类添加一个接口方法： 123456/** * 监听队列接收delayed消息 * * @param message */void receiveMessageDelayed(String message); rabbitmq-consumer模块的RabbitMQConsumerServiceImpl类实现上面的接口方法： 12345@Override@RabbitListener(queues = &#123;RabbitMQConfig.DELAYED_QUEUE&#125;)public void receiveMessageDelayed(String message) &#123; System.out.println(&quot;接收到的延时消息:&quot;+message+&quot; , 当前时间:&quot;+new Date());&#125; 修改rabbitmq-consumer模块application.yml配置文件，主要是将监听策略改为自动确认，方便测试 12345spring: rabbitmq: listener: simple: acknowledge-mode: none #自动确认 到此实现了监听队列接收delayed消息的功能 测试 启动rabbitmq-consumer模块再启动rabbitmq-producer模块，然后去rabbitmq-consumer模块的启动控制台窗口结果，两次消费消息的间隔时间为10秒","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现死信队列","slug":"355","date":"2021-09-08T15:48:31.000Z","updated":"2022-04-14T02:18:18.035Z","comments":true,"path":"355.html","link":"","permalink":"https://blog.zoutl.cn/355.html","excerpt":"","text":"简介当消息成为Dead Message后，可以重新被发送到另一个交换机，这个交换机就是死信交换机DLX（死信交换机），然后这个Dead Message会发送到与之绑定的死信队列。 消息成为Dead Message的三种情况： 消息由于消息有效期(per-message TTL)过期，队列的有效期并不会导致其中的消息过期 消息由于队列超过其长度限制而被丢弃 消息被消费者使用basic.reject或basic.nack方法并且requeue参数值设置为false的方式进行消息确认(negatively acknowledged) 实现过程情况一消息由于消息有效期(per-message TTL)过期 rabbitmq-common模块的RabbitMQConfig类添加配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * dlx交换机名称 */public static final String DLX_DIRECT_EXCHANGE = &quot;dlxExchange&quot;;/** * dlx队列名称 */public static final String DLX_QUEUE = &quot;dlxQueue&quot;;/** * dlx路由key */public static final String DLX_ROUTING_KEY = &quot;dlxRoutingKey&quot;;/** * 定义一个dlx交换机 * * @return */@Beanpublic DirectExchange dlxExchange() &#123; return new DirectExchange(DLX_DIRECT_EXCHANGE);&#125;/** * 定义一个dlx队列 * * @return */@Beanpublic Queue dlxQueue() &#123; return new Queue(DLX_QUEUE);&#125;/** * dlx队列绑定dlx交换机 * * @return */@Beanpublic Binding dlxBinding() &#123; return BindingBuilder.bind(dlxQueue()).to(dlxExchange()).with(DLX_ROUTING_KEY);&#125; 修改rabbitmq-common模块的RabbitMQConfig类的ttlQueue方法，主要实现TTL队列和死信交换机的绑定 1234567891011121314151617/** * 定义一个ttl队列 * * @return */@Beanpublic Queue ttlQueue() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); //设置队列的消息过期时间为4秒 map.put(&quot;x-message-ttl&quot;, 4000); //绑定死信交换机,过期的消息会进入死信交换机然后进入死信队列 map.put(&quot;x-dead-letter-exchange&quot;, DLX_DIRECT_EXCHANGE); //绑定死信交换机的路由 map.put(&quot;x-dead-letter-routing-key&quot;, DLX_ROUTING_KEY); //参数一为队列名称,参数二为是否持久化,参数三是否独享、排外的,参数四为是否自动删除,参数五为队列的其他属性参数 return new Queue(TTL_QUEUE, true, false, false, map);&#125; 测试 首先删除ttlQueue不然该队列的新配置不会生效，向ttlQueue队列发送一个TTL消息后，如果过了消息的有效期，该消息就会变成死信Dead Message，进入死信交换机，最后进入与之绑定的死信队列 情况二消息由于队列超过其长度限制而被丢弃，比如：队列可容纳的最大消息数为10，但是我们一下子向里面发送20条消息，后面的10条消息会变成死信Dead Message，进入死信交换机，最后进入与之绑定的死信队列 rabbitmq-common模块的RabbitMQConfig类的ttlQueue添加配置x-max-length 12345678910111213141516171819/** * 定义一个ttl队列 * * @return */@Beanpublic Queue ttlQueue() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); //设置队列的消息过期时间为4秒 map.put(&quot;x-message-ttl&quot;, 10000); //绑定死信交换机,过期的消息会进入死信交换机然后进入死信队列 map.put(&quot;x-dead-letter-exchange&quot;, DLX_DIRECT_EXCHANGE); //绑定死信交换机的路由 map.put(&quot;x-dead-letter-routing-key&quot;, DLX_ROUTING_KEY); //设置队列的最大长度 map.put(&quot;x-max-length&quot;, 10); //参数一为队列名称,参数二为是否持久化,参数三是否独享、排外的,参数四为是否自动删除,参数五为队列的其他属性参数 return new Queue(TTL_QUEUE, true, false, false, map);&#125; 直接修改rabbitmq-producer模块的启动类，实现批量发送20条ttl消息 1234567891011121314151617181920212223242526package com.ledao.producer;import com.ledao.producer.service.RabbitMQProducerService;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.ComponentScan;/** * 提供者启动类 * * @author LeDao * @company * @create 2021-09-04 12:26 */@SpringBootApplicationpublic class ProducerApplication &#123; public static void main(String[] args) &#123; ApplicationContext ac = SpringApplication.run(ProducerApplication.class, args); RabbitMQProducerService rabbitMQProducerService = (RabbitMQProducerService) ac.getBean(&quot;rabbitMQProducerService&quot;); for (int i = 0; i &lt; 20; i++) &#123; rabbitMQProducerService.sendMessageTll(&quot;消息&quot; + i + 1); &#125; &#125;&#125; 测试 首先删除ttlQueue不然该队列的新配置不会生效，批量向ttlQueue队列发送20条TTL消息后，后面进入的10条消息就会变成死信Dead Message，进入死信交换机，最后进入与之绑定的死信队列，过了消息的有效期，ttlQueue队列的10条消息最后也会变成死信 情况三消息被消费者使用basic.reject或basic.nack方法并且requeue参数值设置为false的方式进行消息确认(negatively acknowledged) rabbitmq-consumer模块的RabbitMQConsumerService类添加一个接口方法： 12345678/** * 监听队列接收ttl消息 * * @param message * @param channel * @param deliveryTag */void receiveMessageTtl(String message, Channel channel, long deliveryTag); rabbitmq-consumer模块的RabbitMQConsumerServiceImpl类实现上面的接口方法： 1234567891011121314151617@Override@RabbitListener(queues = &#123;RabbitMQConfig.TTL_QUEUE&#125;)public void receiveMessageTtl(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) &#123; try &#123; System.out.println(&quot;接收到的消息:&quot; + message); //模拟异常，进入catch方法 System.out.println(1 / 0); &#125; catch (Exception e) &#123; e.printStackTrace(); try &#123; //拒绝的消息不重新入列，会进入死信队列 channel.basicNack(deliveryTag, false, false); &#125; catch (IOException ioException) &#123; ioException.printStackTrace(); &#125; &#125;&#125; 测试 先启动rabbitmq-producer模块发送20条ttl消息，会有10条消息直接变成死信，然后启动rabbitmq-consumer模块消费消息，10条消息都会消费失败变成死信而不会等到消息有效期过期才变成死信","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现TTL(Time-To-Live 过期时间)","slug":"354","date":"2021-09-08T13:01:44.000Z","updated":"2022-04-14T02:18:16.640Z","comments":true,"path":"354.html","link":"","permalink":"https://blog.zoutl.cn/354.html","excerpt":"","text":"简介消息过期时间在指定的过期时间内，如果消息没有被消费，这个消息就会过期从队列中移除 实现方式 给消息设置过期时间 给队列设置过期时间，交换器分发到这个队列的消息都会有相同的过期时间，推荐使用这种方式 注意如果队列设置了消息过期时间并且消息也设置了过期时间，那么数值小的过期时间生效，例如： 一个消息的过期时间为10秒，队列的消息过期时间为20秒，那么该消息的过期时间为10秒 一个消息的过期时间为20秒，队列的消息过期时间为10秒，那么该消息的过期时间为10秒。同一个队列的消息过期时间最好一样，千万不能让队列里的消息延时时间乱七八糟多久的都有，这样的话先入队的消息如果延时时间过长会堵着后入队延时时间小的消息，导致后面的消息到时也无法变成死信转发出去 实现过程给消息设置 创建交换机、队列，交换机绑定队列 在RabbitMQConfig类中添加以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * ttl交换机名称 */public static final String TTL_DIRECT_EXCHANGE = &quot;ttlDirectExchange&quot;;/** * ttl队列名称 */public static final String TTL_QUEUE = &quot;ttlQueue&quot;;/** * ttl路由key */public static final String TTL_ROUTING_KEY = &quot;ttlRoutingKey&quot;;/** * 定义一个ttl交换机 * * @return */@Beanpublic DirectExchange ttlDirectExchange() &#123; return new DirectExchange(TTL_DIRECT_EXCHANGE);&#125;/** * 定义一个ttl队列绑定ttl交换机 * * @return */@Beanpublic Queue ttlQueue() &#123; return new Queue(TTL_QUEUE);&#125;/** * ttl队列 * * @return */@Beanpublic Binding ttlBinding() &#123; return BindingBuilder.bind(ttlQueue()).to(ttlDirectExchange()).with(TTL_ROUTING_KEY);&#125; 实现发送ttl消息 在rabbitmq-producer模块的RabbitMQProducerService类中添加一个接口方法： 123456/** * 发送ttl消息 * * @param message */void sendMessageTll(String message); 在rabbitmq-producer模块的RabbitMQProducerServiceImpl类中实现上面的接口方法： 12345678@Overridepublic void sendMessageTll(String message) &#123; MessageProperties messageProperties = new MessageProperties(); //设置过期时间为10秒 messageProperties.setExpiration(&quot;10000&quot;); Message msg = new Message(message.getBytes(), messageProperties); rabbitTemplate.send(RabbitMQConfig.TTL_DIRECT_EXCHANGE, RabbitMQConfig.TTL_ROUTING_KEY, msg);&#125; 在sendInformationPage.html中添加一个form标签： 12345&lt;form action=&quot;/sendTllMessage&quot; method=&quot;post&quot;&gt; &lt;h2&gt;发送tll消息&lt;/h2&gt; 消息:&lt;input type=&quot;text&quot; name=&quot;message&quot; required=&quot;required&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送&quot;&gt;&lt;/form&gt; 在rabbitmq-producer模块的IndexController类添加sendTllMessage方法： 123456789101112/** * 发送tll消息 * * @param message * @return */@ResponseBody@RequestMapping(&quot;/sendTllMessage&quot;)public String sendTllMessage(String message) &#123; rabbitMQProducerService.sendMessageTll(message); return &quot;发送消息成功&lt;a href=&#x27;/toSendInformationPage&#x27;&gt;&lt;button&gt;继续发送&lt;/button&gt;&lt;/a&gt;&quot;;&#125; 测试 先启动消费者模块再启动生产者模块，浏览器地址栏输入 http://localhost/toSendInformationPage ，发送ttl消息，然后去RabbitMQ管理系统中查看队列的消息，刚刚发送的消息过了10秒（从发送成功开始计算时间）后会自动从队列中删除 给队列设置 直接修改RabbitMQConfig类的ttlQueue()方法 修改前： 123456789/** * 定义一个ttl队列绑定ttl交换机 * * @return */@Beanpublic Queue ttlQueue() &#123; return new Queue(TTL_QUEUE);&#125; 修改后： 123456789101112/** * 定义一个ttl队列绑定ttl交换机 * * @return */@Beanpublic Queue ttlQueue() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;x-message-ttl&quot;, 8000); //参数一为队列名称,参数二为是否持久化,参数三是否独享、排外的,参数四为是否自动删除,参数五为队列的其他属性参数 return new Queue(TTL_QUEUE, true, false, false, map);&#125; 队列参数说明 name: 队列的名称 actualName: 队列的真实名称，默认用name参数，如果name为空，则根据规则生成一个 durable: 是否持久化 exclusive: 是否独享、排外的 autoDelete: 是否自动删除 arguments：队列的其他属性参数，有如下可选项，可参看图2的arguments （1）x-message-ttl：消息的过期时间，单位：毫秒 （2）x-expires：队列过期时间，队列在多长时间未被访问将被删除，单位：毫秒 （3）x-max-length：队列最大长度，超过该最大值，则将从队列头部开始删除消息 （4）x-max-length-bytes：队列消息内容占用最大空间，受限于内存大小，超过该阈值则从队列头部开始删除消息 （5）x-overflow：设置队列溢出行为。这决定了当达到队列的最大长度时消息会发生什么。有效值是drop-head、reject-publish或reject-publish-dlx。仲裁队列类型仅支持drop-head （6）x-dead-letter-exchange：死信交换器名称，过期或被删除（因队列长度超长或因空间超出阈值）的消息可指定发送到该交换器中 （7）x-dead-letter-routing-key：死信消息路由键，在消息发送到死信交换器时会使用该路由键，如果不设置，则使用消息的原来的路由键值 （8）x-single-active-consumer：表示队列是否是单一活动消费者，true时，注册的消费组内只有一个消费者消费消息，其他被忽略，false时消息循环分发给所有消费者(默认false) （9）x-max-priority：队列要支持的最大优先级数;如果未设置，队列将不支持消息优先级 （10）x-queue-mode（Lazy mode）：将队列设置为延迟模式，在磁盘上保留尽可能多的消息，以减少RAM的使用;如果未设置，队列将保留内存缓存以尽可能快地传递消息 （11）x-queue-master-locator：在集群模式下设置镜像队列的主节点信息 测试 先删除之前创建好的队列ttlQueue，启动消费者模块再启动生产者模块，浏览器地址栏输入 http://localhost/toSendInformationPage ，发送ttl消息，然后去RabbitMQ管理系统中查看队列的消息，刚刚发送的消息过了8秒（从发送成功开始计算时间）后会自动从队列中删除（消息的过期时间为10秒，消息所在队列的过期时间为8秒，所以消息的实际过期时间为8秒）","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ消费端并发和限流设置","slug":"353","date":"2021-09-07T13:26:28.000Z","updated":"2022-04-14T02:18:14.112Z","comments":true,"path":"353.html","link":"","permalink":"https://blog.zoutl.cn/353.html","excerpt":"","text":"简介并发：有时候，我们需要加快消息的处理速度，这时候，我们可以通过提高消息处理程序的并发量，来提高消息的处理能力，本质就是多个消费者消费同一个队列的消息 限流：有些场景，消费者端处理并发太大的时候，会影响消息处理端的性能，这时候需要限流 实现过程并发在要并发的监听队列的方法的@RabbitListener注解中配置concurency=“min-max”，min是最小并发数，max是最大并发数 1@RabbitListener(queues = &#123;RabbitMQConfig.DIRECT_QUEUE&#125;,concurrency = &quot;5-8&quot;) 限流在要限流的监听队列的方法所在类RabbitMQConsumerServiceImpl.java中添加以下代码： 1234567891011@Resourceprivate CachingConnectionFactory cachingConnectionFactory;@Bean(name = &quot;limitContainerFactory&quot;)public SimpleRabbitListenerContainerFactory simpleRabbitListenerContainerFactory() &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(cachingConnectionFactory); //设置每次处理消息数量为5 factory.setPrefetchCount(5); return factory;&#125; 在@RabbitListener注解中配置containerFactory = “limitContainerFactory” 1@RabbitListener(queues = &#123;RabbitMQConfig.DIRECT_QUEUE&#125;, concurrency = &quot;5-8&quot;,containerFactory = &quot;limitContainerFactory&quot;)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ消费端手动ACK确认机制","slug":"352","date":"2021-09-06T14:30:05.000Z","updated":"2022-04-14T02:18:11.306Z","comments":true,"path":"352.html","link":"","permalink":"https://blog.zoutl.cn/352.html","excerpt":"","text":"简介ack——acknowledge（vt. 承认；答谢；报偿；告知已收到；确认的意思），在RabbitMQ中指代的是消费者收到消息后确认的一种行为，关注点在于消费者能否实际接收到MQ发送的消息 当消息一旦被消费者接收到，会立刻自动向MQ确认接收，并将响应的message从RabbitMQ消息缓存中移除，但是在实际的业务处理中，会出现消息收到了，但是业务处理出现异常的情况，在自动确认的模式下，该条业务处理失败的message就相当于被丢弃了。如果设置了手动确认，则需要在业务处理完成之后，手动调用channel.basicAck()，手动的签收，如果业务处理失败，则手动调用channel.basicNack()方法拒收，并让MQ重新发送该消息。 RabbitMQ提供了三种确认方式： 自动确认acknowledge=”none”：当消费者接收到消息的时候，就会自动给到RabbitMQ一个回执，告诉RabbitMQ我已经收到消息了，不在乎消费者接收到消息之后业务处理的成功与否，这是RabbitMQ默认的 手动确认acknowledge=”manual”：当消费者收到消息后，不会立刻告诉RabbitMQ已经收到消息了，而是等待业务处理成功后，通过调用代码的方式手动向RabbitMQ确认消息已经收到。当业务处理失败，就可以做一些重试机制，甚至让RabbitMQ重新向消费者发送消息都是可以的，一般使用这种方式 根据异常情况确认acknowledge=”auto”：该方式是通过抛出异常的类型，来做响应的处理（如重发、确认等）,这种方式比较麻烦，一般不使用 实现过程rabbitmq-consumer消费端application.yml添加以下配置： 12345spring: rabbitmq: listener: simple: acknowledge-mode: manual #ack手动确认 rabbitmq-consumer消费端的RabbitMQConsumerService类添加一个接口方法： 12345678/** * 手动确认消息的接收 * * @param message * @param channel * @param deliveryTag */void receiveMessageAck(String message, Channel channel, long deliveryTag); rabbitmq-consumer消费端的RabbitMQConsumerServiceImpl类实现上面的接口方法： 123456789101112131415161718192021222324/** * 手动确认消息的接收 * * @param message 接收的消息 * @param channel 队列和消费端的连接管道 * @param deliveryTag 消息接收tag */@Override@RabbitListener(queues = &#123;RabbitMQConfig.DIRECT_QUEUE&#125;)public void receiveMessageAck(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) &#123; System.out.println(&quot;接收到的消息:&quot; + message); try &#123; //如果没有异常就接收消息,第一个参数为消息接收tag,第二个参数为是否批量确认 channel.basicAck(deliveryTag, t); &#125; catch (IOException e) &#123; e.printStackTrace(); try &#123; //让消息重新入列,第一个参数为消息接收tag,第二个参数为是否批量确认,第三个参数为被拒绝的消息是否重新入列(如果设置为false将会删除被拒绝的消息) channel.basicNack(deliveryTag, false, true); &#125; catch (IOException ioException) &#123; ioException.printStackTrace(); &#125; &#125;&#125; 把rabbitmq-consumer消费端的RabbitMQConsumerServiceImpl类监听RabbitMQConfig.DIRECT_QUEUE队列的消息的@RabbitListener注解删除，这是为了只能让receiveMessageAck()方法消费RabbitMQConfig.DIRECT_QUEUE队列的消息 Channel.basicAck(long deliveryTag, boolean multiple)方法 功能：确认消费 参数说明： 第一个参数deliveryTag：消息ID，从1开始 第二个参数multiple：是否批量，将一次性ack所有小于deliveryTag的消息 Channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)方法 功能：反馈消息消费失败 参数说明： 第一个参数deliveryTag：消息ID，从1开始 第二个参数multiple：是否批量，将一次性拒绝所有小于deliveryTag的消息 第三个参数requeue：被拒绝的消息是否重新入列 Channel.basicReject(long deliveryTag, boolean requeue) 功能：反馈消息消费失败 参数说明： 第一个参数deliveryTag：消息ID，从1开始 第二个参数requeue：被拒绝的消息是否重新入列","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ消息可靠性投递","slug":"351","date":"2021-09-06T13:08:27.000Z","updated":"2022-04-14T02:18:09.223Z","comments":true,"path":"351.html","link":"","permalink":"https://blog.zoutl.cn/351.html","excerpt":"","text":"简介在使用RabbitMQ的时候，消息生产者发送消息不希望出现消息丢失或者投递失败的现象，RabbitMQ在消息投递可靠性方面给我们提供了两种模式：①confirm确认模式 ②return退回模式 confirm确认模式介绍作用于生产者发送到交换机过程，发送成功与否都会调用 消息确认，是指生产者消息投递后，如果Broker收到消息，则会给生产者一个应答生产者进行接收应答，用来确定这条消息是否正常的发送到Broker，这种方式也是消息的可靠性投递的核心保障 实现rabbitmq-producer模块的application.yml文件添加以下配置： 1spring.rabbitmq.publisher-confirm-type=correlated RabbitMQProducerServiceImpl类实现RabbitTemplate.ConfirmCallback接口，再实现confirm方法 123456789101112131415/** * @param correlationData 消息唯一标识 * @param b 交换机是否成功收到消息 true成功 false失败 * @param s 失败原因 */@Overridepublic void confirm(CorrelationData correlationData, boolean b, String s) &#123; System.out.println(&quot;confirm方法被执行了...&quot; + correlationData); if (b) &#123; //发送成功失败原因为null System.out.println(&quot;消息成功发送到交换机&quot; + s); &#125; else &#123; System.out.println(&quot;消息发送失败&quot; + s); &#125;&#125; RabbitMQProducerServiceImpl类注入RabbitTemplate模版 12@Resourceprivate RabbitTemplate rabbitTemplate; RabbitMQProducerServiceImpl类初始化设置，放在所有模板注入的后面 1234@PostConstructpublic void init() &#123; rabbitTemplate.setConfirmCallback(this);&#125; RabbitMQProducerService类添加一个接口方法： 123456/** * 发送消息并返回发送情况 * * @param message */void sendMessageConfirm(String message); RabbitMQProducerServiceImpl类实现上面的接口方法： 12345@Overridepublic void sendMessageConfirm(String message) &#123; CorrelationData correlationData = new CorrelationData(); rabbitTemplate.convertAndSend(RabbitMQConfig.DIRECT_EXCHANGE, RabbitMQConfig.DIRECT_ROUTINGKEY, message,correlationData);&#125; 实现一个调用Confirm方法的发送消息功能 在sendInformationPage.html下添加一个form标签： 12345&lt;form action=&quot;/sendMessageConfirm&quot; method=&quot;post&quot;&gt; &lt;h2&gt;发送消息调用Confirm方法&lt;/h2&gt; 消息:&lt;input type=&quot;text&quot; name=&quot;message&quot; required=&quot;required&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送&quot;&gt;&lt;/form&gt; IndexController类下添加一个方法： 123456789101112/** * 发送消息调用Confirm方法 * * @param message * @return */@ResponseBody@RequestMapping(&quot;/sendMessageConfirm&quot;)public String sendMessageConfirm(String message) &#123; rabbitMQProducerService.sendMessageConfirm(message); return &quot;发送消息成功&lt;a href=&#x27;/toSendInformationPage&#x27;&gt;&lt;button&gt;继续发送&lt;/button&gt;&lt;/a&gt;&quot;;&#125; 测试启动rabbitmq-producer模块,然后在浏览器地址栏输入：http://localhost/toSendInformationPage 进入发送消息页面，发送一条消息 然后去rabbitmq-producer模块启动控制台查看结果 return退回模式介绍作用于交换机发送到队列过程，发送失败才调用 Return Listener用于处理一些不可路由的消息 我们的消息生产者，通过制定一个Exchange和RoutingKey，把消息送达到某一个队列中去，然后我们消费者监听队列，进行消费处理。但是在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或指定的路由key路由不到，这个时候我们需要监听这种不可达的消息 实现rabbitmq-producer模块的application.yml文件添加以下配置： 1spring.rabbitmq.publisher-returns-type=correlated RabbitMQProducerServiceImpl类实现RabbitTemplate.ReturnCallback接口，再实现returnedMessage方法 123456789@Overridepublic void returnedMessage(ReturnedMessage returnedMessage) &#123; System.out.println(&quot;return方法执行...&quot;); System.out.println(&quot;发送的消息内容:&quot; + new String(returnedMessage.getMessage().getBody())); System.out.println(&quot;replyCode：&quot; + returnedMessage.getReplyCode()); System.out.println(&quot;replyText：&quot; + returnedMessage.getReplyText()); System.out.println(&quot;exchange：&quot; + returnedMessage.getExchange()); System.out.println(&quot;routingKey：&quot; + returnedMessage.getRoutingKey());&#125; RabbitMQProducerServiceImpl类初始化设置中添加以下代码： 1rabbitTemplate.setReturnsCallback(this); RabbitMQProducerServiceImpl类修改sendMessageConfirm方法，修改rabbitTemplate.convertAndSend()第二个参数，只要不和对应消息队列的routingKey一样就行（为了让交换器发送到队列失败） 测试和上面confirm确认模式那样测试即可","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现主题模式Topic","slug":"350","date":"2021-09-05T14:42:02.000Z","updated":"2022-04-14T02:18:07.767Z","comments":true,"path":"350.html","link":"","permalink":"https://blog.zoutl.cn/350.html","excerpt":"","text":"简介 主题模式和路由模式很像，但是路由模式是精确匹配，主题模式是模糊匹配，更加灵活，更加强大 主题模式使用的是topic类型的交换机，使用通配符方式实现模糊匹配，匹配符有：*和# 通配符 匹配方式 * 匹配一个单词 # 匹配零个或者多个单词 对上图的3中路由key进行解释： *.orange.* ：orange前后各有一个单词，例如：lazy.orange.rabbit、quick.orange.dog等情况 *.*.rabbit ：rabbit前面后两个单词，例如：lazy.green.rabbit、quick.orange.rabbit等情况 lazy.# ：lazy后面有0个或无数个单词，例如：lazy，lazy.rabbit、lazy.red.rabbit、lazy.red.old.rabbit等情况 实现过程发送topic消息为了方便测试，在rabbitmq-producer模块下添加一个发送指定类型消息功能，首先在sendInformationPage.html中添加一个form标签： 12345&lt;form action=&quot;/sendTopicMessage&quot; method=&quot;post&quot;&gt; &lt;h2&gt;发送topic消息&lt;/h2&gt; 消息:&lt;input type=&quot;text&quot; name=&quot;message&quot; required=&quot;required&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送&quot;&gt;&lt;/form&gt; 在rabbitmq-common模块的RabbitMQConfig类添加以下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * topic交换机名称 */public static final String TOPIC_EXCHANGE = &quot;topicExchange&quot;;/** * topic队列1名称 */public static final String TOPIC_QUEUE1 = &quot;topicQueue1&quot;;/** * topic队列2名称 */public static final String TOPIC_QUEUE2 = &quot;topicQueue2&quot;;/** * 定义一个topic交换机 * * @return */@Beanpublic TopicExchange topicExchange() &#123; return new TopicExchange(TOPIC_EXCHANGE);&#125;/** * 定义一个topic队列1 * * @return */@Beanpublic Queue topicQueue1() &#123; return new Queue(TOPIC_QUEUE1);&#125;/** * 定义一个topic队列2 * * @return */@Beanpublic Queue topicQueue2() &#123; return new Queue(TOPIC_QUEUE2);&#125;/** * topic队列1绑定topic交换机,routingKey为 *.orange.* * * @return */@Beanpublic Binding topicBinding1() &#123; return BindingBuilder.bind(topicQueue1()).to(topicExchange()).with(&quot;*.orange.*&quot;);&#125;/** * topic队列1绑定topic交换机,routingKey为 *.*.rabbit * * @return */@Beanpublic Binding topicBinding2() &#123; return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(&quot;*.*.rabbit&quot;);&#125;/** * topic队列1绑定topic交换机,routingKey为 lazy.# * * @return */@Beanpublic Binding topicBinding3() &#123; return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with(&quot;lazy.#&quot;);&#125; 在RabbitMQProducerService类添加一个接口方法： 1234567/** * 发送topic消息 * * @param message * @param routingKey */void sendTopicMessage(String message, String routingKey); 在RabbitMQProducerServiceImpl类中实现上面的接口方法： 1234@Overridepublic void sendTopicMessage(String message,String routingKey) &#123; amqpTemplate.convertAndSend(RabbitMQConfig.TOPIC_EXCHANGE, routingKey, message);&#125; 在IndexController类添加一个方法： 123456789101112/** * 发送topic消息 * * @param message * @return */@ResponseBody@RequestMapping(&quot;/sendTopicMessage&quot;)public String sendTopicMessage(String message) &#123; rabbitMQProducerService.sendTopicMessage(message, message); return &quot;发送topic消息成功&lt;a href=&#x27;/toSendInformationPage&#x27;&gt;&lt;button&gt;继续发送&lt;/button&gt;&lt;/a&gt;&quot;;&#125; 消费消息在rabbitmq-consumer模块的RabbitMQConsumerService中添加以下接口方法： 12345678910111213/** * 监听队列接收topic消息1 * * @param message */void receiveTopicMessage1(String message);/** * 监听队列接收topic消息2 * * @param message */void receiveTopicMessage2(String message); 在rabbitmq-consumer模块的RabbitMQConsumerServiceImpl中实现上面的接口方法： 1234567891011@Override@RabbitListener(queues = &#123;RabbitMQConfig.TOPIC_QUEUE1&#125;)public void receiveTopicMessage1(String message) &#123; System.out.println(&quot;消费者1---接收到的消息:&quot; + message);&#125;@Override@RabbitListener(queues = &#123;RabbitMQConfig.TOPIC_QUEUE2&#125;)public void receiveTopicMessage2(String message) &#123; System.out.println(&quot;消费者2---接收到的消息:&quot; + message);&#125; 测试启动rabbitmq-consumer模块再启动rabbitmq-producer模块，消费者1消费的是topicQueue1队列的消息，消费者2消费的是topicQueue2队列的消息，交换机和队列绑定情况如下： 然后在浏览器地址栏输入：http://localhost/toSendInformationPage 进入发送消息页面，分别发送topic消息：lazy.orange.rabbit、lazy.red.old.rabbit、lazy.rabbit、orange.rabbit、quick.orange.dog，然后去rabbitmq-consumer模块启动控制台查看结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现路由模式Routing","slug":"349","date":"2021-09-05T04:48:58.000Z","updated":"2022-04-14T02:18:05.610Z","comments":true,"path":"349.html","link":"","permalink":"https://blog.zoutl.cn/349.html","excerpt":"","text":"简介 跟订阅模式类似，只不过在订阅模式的基础上加上了类型，订阅模式是分发到所有绑定到交换机的队列，路由模式只分发到绑定在交换机上面指定路由键的队列。 使用场景：只将一些错误log存到文件中，把所有的log都打印到控制台里 实现过程发送指定类型消息为了方便测试，在rabbitmq-producer模块下添加一个发送指定类型消息功能，消息类型有info、error、warning 首先在sendInformationPage.html中添加一个form标签： 123456789101112&lt;form action=&quot;/sendRoutingMessage&quot;&gt; &lt;h2&gt;发送指定类型的消息&lt;/h2&gt; 消息: &lt;input type=&quot;text&quot; name=&quot;message&quot; required=&quot;required&quot;&gt;&lt;br&gt; 类型: &lt;select name=&quot;routingKey&quot;&gt; &lt;option value=&quot;info&quot;&gt;info&lt;/option&gt; &lt;option value=&quot;error&quot;&gt;error&lt;/option&gt; &lt;option value=&quot;warning&quot;&gt;warning&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;发送&quot;&gt;&lt;/form&gt; 在rabbitmq-common模块的RabbitMQConfig类添加以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * direct路由模式交换机名称 */public static final String DIRECT_ROUTING_EXCHANGE = &quot;directRoutingExchange&quot;;/** * direct路由模式队列1 */public static final String DIRECT_ROUTING_QUEUE1 = &quot;directRoutingQueue1&quot;;/** * direct路由模式队列2 */public static final String DIRECT_ROUTING_QUEUE2 = &quot;directRoutingQueue2&quot;;/** * 定义一个direct路由模式交换机 * * @return */@Beanpublic DirectExchange directRoutingExchange() &#123; return new DirectExchange(DIRECT_ROUTING_EXCHANGE);&#125;/** * 定义一个路由模式队列1 * * @return */@Beanpublic Queue routingQueue1() &#123; return new Queue(DIRECT_ROUTING_QUEUE1);&#125;/** * 定义一个路由模式队列2 * * @return */@Beanpublic Queue routingQueue2() &#123; return new Queue(DIRECT_ROUTING_QUEUE2);&#125;/** * 路由模式队列1绑定路由模式交换机,routingKey为error * * @return */@Beanpublic Binding bindingRouting1() &#123; return BindingBuilder.bind(routingQueue1()).to(directRoutingExchange()).with(&quot;error&quot;);&#125;/** * 路由模式队列2绑定路由模式交换机,routingKey为error * * @return */@Beanpublic Binding bindingRouting2() &#123; return BindingBuilder.bind(routingQueue2()).to(directRoutingExchange()).with(&quot;error&quot;);&#125;/** * 路由模式队列2绑定路由模式交换机,routingKey为info * * @return */@Beanpublic Binding bindingRouting3() &#123; return BindingBuilder.bind(routingQueue2()).to(directRoutingExchange()).with(&quot;info&quot;);&#125;/** * 路由模式队列2绑定路由模式交换机,routingKey为warning * * @return */@Beanpublic Binding bindingRouting4() &#123; return BindingBuilder.bind(routingQueue2()).to(directRoutingExchange()).with(&quot;warning&quot;);&#125; 在RabbitMQProducerService类添加一个接口方法： 1234567/** * 发送路由模式消息 * * @param message * @param routingKey */void sendRoutingMessage(String message, String routingKey); 在RabbitMQProducerServiceImpl类中实现上面的接口方法： 1234@Overridepublic void sendRoutingMessage(String message, String routingKey) &#123; amqpTemplate.convertAndSend(RabbitMQConfig.DIRECT_ROUTING_EXCHANGE,routingKey,message);&#125; 在IndexController类添加一个方法： 12345678910111213/** * 发送路由模式消息 * * @param message * @param routingKey * @return */@ResponseBody@RequestMapping(&quot;/sendRoutingMessage&quot;)public String sendRoutingMessage(String message, String routingKey) &#123; rabbitMQProducerService.sendRoutingMessage(message+&quot;(&quot;+routingKey+&quot;)&quot;, routingKey); return &quot;发送路由模式消息成功&lt;a href=&#x27;/toSendInformationPage&#x27;&gt;&lt;button&gt;继续发送&lt;/button&gt;&lt;/a&gt;&quot;;&#125; 消费消息在rabbitmq-consumer模块的RabbitMQConsumerService中添加以下接口方法： 12345678910111213/** * 监听队列接收路由模式消息1 * * @param message */void receiveRoutingMessage1(String message);/** * 监听队列接收路由模式消息2 * * @param message */void receiveRoutingMessage2(String message); 在rabbitmq-consumer模块的RabbitMQConsumerServiceImpl中实现上面的接口方法： 1234567891011@Override@RabbitListener(queues = &#123;RabbitMQConfig.DIRECT_ROUTING_QUEUE1&#125;)public void receiveRoutingMessage1(String message) &#123; System.out.println(&quot;消费者1---接收到的消息:&quot; + message);&#125;@Override@RabbitListener(queues = &#123;RabbitMQConfig.DIRECT_ROUTING_QUEUE2&#125;)public void receiveRoutingMessage2(String message) &#123; System.out.println(&quot;消费者2---接收到的消息:&quot; + message);&#125; 测试启动rabbitmq-consumer模块再启动rabbitmq-producer模块，，然后在浏览器地址栏输入：http://localhost/toSendInformationPage 进入发送消息页面，分别发送info、error、warning类型的路由模式消息，然后去rabbitmq-consumer模块启动控制台查看结果，可以看到：①消费者1只消费了error类型的消息②消费者2消费了info、error、warning类型的消息","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现订阅模式Publish/Subscribe","slug":"348","date":"2021-09-05T02:48:14.000Z","updated":"2022-04-14T02:18:04.119Z","comments":true,"path":"348.html","link":"","permalink":"https://blog.zoutl.cn/348.html","excerpt":"","text":"简介 生产者生产的消息，所有订阅过的消费者都能够接收到消息 Exchange采用Fanout类型，即广播方式 Fanout类型的交换机会把消息发送到所有绑定到该交换机的队列 适合场景：将同一条消息通过手机短信，APP，邮件等方式推送给用户 实现过程批量发送订阅消息为了方便测试，在rabbitmq-producer模块下添加一个批量发送消息功能，可以自定义批量发送的消息数量 首先在sendInformationPage.html中添加一个form标签： 12345&lt;form action=&quot;/sendFanoutMessageBatch&quot;&gt; &lt;h2&gt;批量发送订阅消息&lt;/h2&gt; 数量:&lt;input type=&quot;text&quot; name=&quot;messageCount&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;批量发送&quot;&gt;&lt;/form&gt; 在rabbitmq-common模块的RabbitMQConfig类添加以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364`/** * fanout交换机名称 */public static final String FANOUT_EXCHANGE = &quot;fanoutExchange&quot;;/** * fanout订阅队列1名称 */public static final String SUB_QUEUE1 = &quot;subQueue1&quot;;/** * fanout订阅队列2名称 */public static final String SUB_QUEUE2 = &quot;subQueue2&quot;;/** * 定义一个fanout交换机,所有订阅了这个交换机的消息队列都会接收到消息 * * @return */@Beanpublic FanoutExchange fanoutExchange() &#123; return new FanoutExchange(FANOUT_EXCHANGE);&#125;/** * 定义一个fanout订阅队列1 * * @return */@Beanpublic Queue subQueue1() &#123; return new Queue(SUB_QUEUE1);&#125;/** * 定义一个fanout订阅队列2 * * @return */@Beanpublic Queue subQueue2() &#123; return new Queue(SUB_QUEUE2);&#125;/** * 定义一个fanout订阅队列1和fanout交换机的绑定 * * @return */@Beanpublic Binding fanoutBinding1() &#123; return BindingBuilder.bind(subQueue1()).to(fanoutExchange());&#125;/** * 定义一个fanout订阅队列2和fanout交换机的绑定 * * @return */@Beanpublic Binding fanoutBinding2() &#123; return BindingBuilder.bind(subQueue2()).to(fanoutExchange());&#125; 在RabbitMQProducerService类添加一个接口方法： 123456/** * 发送fanout消息 * * @param message */void sendFanoutMessage(String message); 在RabbitMQProducerServiceImpl类中实现上面的接口方法： 1234@Overridepublic void sendFanoutMessage(String message) &#123; amqpTemplate.convertAndSend(RabbitMQConfig.FANOUT_EXCHANGE, &quot;&quot;, message);&#125; 在IndexController类添加一个方法： 1234567891011121314/** * 批量发送订阅消息 * * @param messageCount * @return */@ResponseBody@RequestMapping(&quot;/sendFanoutMessageBatch&quot;)public String sendFanoutMessageBatch(int messageCount) &#123; for (int i = 1; i &lt; messageCount + 1; i++) &#123; rabbitMQProducerService.sendFanoutMessage(&quot;订阅消息&quot; + i); &#125; return &quot;批量发送消息到fanout交换机成功&lt;a href=&#x27;/toSendInformationPage&#x27;&gt;&lt;button&gt;继续发送&lt;/button&gt;&lt;/a&gt;&quot;;&#125; 消费消息在rabbitmq-consumer模块的RabbitMQConsumerService中添加以下接口方法： 12345678910111213/** * 监听队列接收订阅消息 * * @param message */void receiveSubMessage1(String message);/** * 监听队列接收订阅消息 * * @param message */void receiveSubMessage2(String message); 在rabbitmq-consumer模块的RabbitMQConsumerServiceImpl中实现上面的接口方法： 1234567891011@Override@RabbitListener(queues = &#123;RabbitMQConfig.SUB_QUEUE1&#125;)public void receiveSubMessage1(String message) &#123; System.out.println(&quot;订阅者1---接收到的消息:&quot; + message);&#125;@Override@RabbitListener(queues = &#123;RabbitMQConfig.SUB_QUEUE2&#125;)public void receiveSubMessage2(String message) &#123; System.out.println(&quot;订阅者2---接收到的消息:&quot; + message);&#125; 测试启动rabbitmq-consumer模块再启动rabbitmq-producer模块，，然后在浏览器地址栏输入：http://localhost/toSendInformationPage 进入发送消息页面，根据自己的需要填入批量发送的消息数量，然后点击发送订阅信息，最后去rabbitmq-consumer模块启动控制台查看结果，可以看到两个订阅者都收到了同一条消息","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ报错：reply-code=404, reply-text=NOT_FOUND - no的解决办法","slug":"347","date":"2021-09-05T02:07:09.000Z","updated":"2022-04-14T02:18:01.834Z","comments":true,"path":"347.html","link":"","permalink":"https://blog.zoutl.cn/347.html","excerpt":"","text":"情况一报错信息reply-code=404, reply-text=NOT_FOUND - no exchange 原因只启动Provider，然后发送消息到队列，如果没有创建交换机（RabbitMQ中原来没有对应交换机），就会报错 解决办法有两种解决办法： ①先启动Consumer，会自动创建RabbitMQ配置类中的交换机和队列，然后启动Provider发送消息到队列即可 ②先启动了Provider，但是先不要发送消息，启动Consumer后再发送消息到队列 情况二报错信息reply-code=404, reply-text=NOT_FOUND - no queue 原因RabbitMQ配置类没有生效 解决办法在Consumer启动类添加注解@ComponentScan，我的配置类在 com.ledao.common.config 目录下，扫描的范围如下：（下面两种方式都行） 1234//扫描到上三级目录，范围更大@ComponentScan(basePackages = &quot;com&quot;)//扫描到上两级目录@ComponentScan(basePackages = &quot;com.ledao&quot;)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"Docker安装Mycat","slug":"346","date":"2021-09-04T19:16:00.000Z","updated":"2022-04-14T02:39:50.954Z","comments":true,"path":"346.html","link":"","permalink":"https://blog.zoutl.cn/346.html","excerpt":"","text":"概述安装方式有两种： pull命令 Dockerfile命令 pull命令拉取镜像1docker pull manondidi/mycat 创建配置目录创建一个目录，路径为：/home/mycat/conf，这个目录用于存放Mycat相关配置文件以及目录挂载 复制文件创建容器 1docker run -p 8066:8066 -d --name mycat Mycat镜像id 复制容器的rule.xml schema.xml server.xml到 /home/mycat/conf 目录下 123docker cp mycat:/usr/local/mycat/conf/rule.xml /home/mycat/confdocker cp mycat:/usr/local/mycat/conf/server.xml /home/mycat/confdocker cp mycat:/usr/local/mycat/conf/schema.xml /home/mycat/conf 删除容器把之前用于复制文件的Mycat容器删除 1234567#停止docker stop Mycat容器id#删除docker rm Mycat容器id#或者直接强制删除docker rm -f Mycat容器id 创建容器1docker run -p 8066:8066 -d --name mycat -v /home/mycat/conf/rule.xml:/usr/local/mycat/conf/rule.xml -v /home/mycat/conf/schema.xml:/usr/local/mycat/conf/schema.xml -v /home/mycat/conf/server.xml:/usr/local/mycat/conf/server.xml --privileged=true Mycat镜像id Dockerfile命令编写Dockerfile命令为：mycatdockerfile，内容如下： 1234567891011121314151617181920FROM centosMAINTAINER LeDao&lt;f1203007469@gmail.com&gt; LABEL name=&quot;LeDao myCat Image&quot; \\ build-date=&quot;2021-09-05 03:55:07&quot; ADD server-jre-8u151-linux-x64.tar.gz /home/ADD Mycat-server-1.6.7.4-release-20200105164103-linux.tar.gz /home/ ENV WORKPATH /home/mycat/WORKDIR $WORKPATH ENV JAVA_HOME /home/jdk1.8.0_151ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8066CMD /home/mycat/bin/mycat console 上传文件上传文件 mycatdockerfile、Mycat-server-1.6.7.4-release-20200105164103-linux.tar.gz、server-jre-8u151-linux-x64.tar.gz 到 /home/data 目录下 文件百度网盘地址如下： 链接：https://pan.baidu.com/s/17wuUK5Kqu9fJnqaV_VOXHw提取码：iw7w 构建镜像记得要先进入 /home/data 目录下，再执行下面命令： 1docker build -f mycatdockerfile -t ledao/mycat:1.0 . 创建配置目录创建一个目录，路径为：/home/mycat/conf，这个目录用于存放Mycat相关配置文件以及目录挂载 复制文件创建容器 1docker run -p 8066:8066 -it 镜像id 复制文件 12docker cp Mycat容器id:/home/mycat/conf/ /home/docker/mycat/docker cp Mycat容器id:/home/mycat/logs/ /home/docker/mycat/ 删除容器把之前用于复制文件的Mycat容器删除 1234567#停止docker stop Mycat容器id#删除docker rm Mycat容器id#或者直接强制删除docker rm -f Mycat容器id 创建容器1docker run -p 8066:8066 -it -v /home/docker/mycat/conf/:/home/mycat/conf/ -v /home/docker/mycat/logs/:/home/mycat/logs/ Mycat镜像id","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"Mycat","slug":"Mycat","permalink":"https://blog.zoutl.cn/tags/Mycat/"}]},{"title":"RabbitMQ实现工作模式Work queues","slug":"345","date":"2021-09-04T17:58:34.000Z","updated":"2022-04-14T02:17:57.553Z","comments":true,"path":"345.html","link":"","permalink":"https://blog.zoutl.cn/345.html","excerpt":"","text":"前提条件已经实现了监听队列接收消息,具体步骤查看：RabbitMQ实现监听队列接收消息 介绍工作模式是一个或者多个消费者共同消费一个队列中的消息，队列中的每一个消息只可能被其中一个消费者消费，比如：多个人抢一个蛋糕，只有一个人可以抢到 应用场景：对于消息任务很多的情况，可以使用工作队列提高任务处理的速度 原理：集群处理大量的消息 实现过程批量发送消息为了方便测试，在rabbitmq-producer模块下添加一个批量发送消息功能，可以自定义批量发送的消息数量 首先在sendInformationPage.html中添加一个form标签： 12345&lt;form action=&quot;/sendInformationBatch&quot;&gt; &lt;h2&gt;批量发送&lt;/h2&gt; 数量:&lt;input type=&quot;text&quot; name=&quot;informationCount&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;批量发送&quot;&gt;&lt;/form&gt; 在IndexController类添加一个方法： 1234567891011121314/** * 批量发送消息 * * @param informationCount * @return */@ResponseBody@RequestMapping(&quot;/sendInformationBatch&quot;)public String sendInformationBatch(Integer informationCount) &#123; for (Integer i = 1; i &lt; informationCount + 1; i++) &#123; rabbitMQProducerService.sendInformation(&quot;消息&quot; + i); &#125; return &quot;批量发送消息到RabbitMQ成功&lt;a href=&#x27;/toSendInformationPage&#x27;&gt;&lt;button&gt;继续发送&lt;/button&gt;&lt;/a&gt;&quot;;&#125; 消费消息在rabbitmq-consumer模块下修改 先在RabbitMQConsumerService类添加一个接口方法： 123456/** * 监听队列接收消息 * * @param message */void receiveMessage3(String message); 然后在RabbitMQConsumerServiceImpl类中实现上面的接口方法 12345@Override@RabbitListener(queues = &#123;RabbitMQConfig.DIRECT_QUEUE&#125;)public void receiveMessage3(String message) &#123; System.out.println(&quot;消费者2---接收到的消息:&quot; + message);&#125; 测试启动rabbitmq-producer模块和rabbitmq-consumer模块，然后在浏览器地址栏输入：http://localhost/toSendInformationPage 进入发送消息页面，根据自己的需要填入批量发送的消息数量，然后点击发送，最后去rabbitmq-consumer模块启动控制台查看结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现监听队列接收消息","slug":"344","date":"2021-09-04T16:10:21.000Z","updated":"2022-04-14T02:17:55.698Z","comments":true,"path":"344.html","link":"","permalink":"https://blog.zoutl.cn/344.html","excerpt":"","text":"说明在博客 RabbitMQ实现消费者接收消息 的基础上修改，接收消息的基本配置查看前面的博客即可 实现过程修改消费者Service类添加接口方法receiveMessage2() 123456/** * 监听队列接收消息 * * @param message */void receiveMessage2(String message); 修改消费者Service实现类实现RabbitMQConsumerService类的接口方法receiveMessage2()，添加注解@RabbitListener实现监听，可以监听多个队列，在{}中用 , 隔开多个队列名称即可 12345@Override@RabbitListener(queues = &#123;RabbitMQConfig.DIRECT_QUEUE&#125;)public void receiveMessage2(String message) &#123; System.out.println(&quot;接收到的消息:&quot; + message);&#125; 测试去rabbitmq-consumer模块启动的控制台查看结果，每成功发送消息一次控制台就打印一次，如果原来就有多个消息就会逐个打印完","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现消费者接收消息","slug":"343","date":"2021-09-04T12:57:02.000Z","updated":"2022-04-14T02:17:53.890Z","comments":true,"path":"343.html","link":"","permalink":"https://blog.zoutl.cn/343.html","excerpt":"","text":"前提已经搭建好RabbitMQ基本环境，搭建步骤查看博客：搭建RabbitMQ基本环境 配置好RabbitMQ的交换机、队列、队列绑定交换机，具体步骤查看博客：RabbitMQ实现生产者发送消息 ，rabbitmq-common模块的RabbitMQConfig.java就是配置类 项目结构 实现过程application.yml配置添加一个application.yml配置文件，内容如下： 12345678910server: port: 81spring: rabbitmq: host: 192.168.0.145 #虚拟机IP port: 5672 #RabbitMQ默认TCP监听端口 username: admin #登录RabbitMQ管理系统的用户名 password: admin #登录RabbitMQ管理系统的密码 virtual-host: / #默认就是/,可不加 接收消息页面123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;接收消息&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; function receiveMessage() &#123; $.ajax(&#123; url: &quot;/receiveMessage&quot;, type: &quot;get&quot;, success: function (result) &#123; $(&quot;#messageReceive&quot;).html(result.message); &#125;, &#125;); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; 接收的消息:&lt;span style=&quot;color: red&quot; id=&quot;messageReceive&quot;&gt;看这里&lt;/span&gt;&lt;br&gt; &lt;a href=&quot;javascript:receiveMessage()&quot;&gt; &lt;button&gt;接收&lt;/button&gt; &lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 消费者Service接口12345678910111213141516171819package com.ledao.consumer.service;/** * RabbitMQService消费者接口 * * @author LeDao * @company * @create 2021-09-04 20:59 */public interface RabbitMQConsumerService &#123; /** * 接收消息 * * @return */ String receiveMessage();&#125; Service接口实现类12345678910111213141516171819202122232425262728package com.ledao.consumer.service.impl;import com.ledao.common.config.RabbitMQConfig;import com.ledao.consumer.service.RabbitMQConsumerService;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * RabbitMQService消费者接口实现类 * * @author LeDao * @company * @create 2021-09-04 21:57 */@Service(&quot;rabbitMQConsumerService&quot;)public class RabbitMQConsumerServiceImpl implements RabbitMQConsumerService &#123; @Resource private AmqpTemplate amqpTemplate; @Override public String receiveMessage() &#123; return (String) amqpTemplate.receiveAndConvert(RabbitMQConfig.DIRECT_QUEUE); &#125;&#125; IndexController.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ledao.consumer.controller;import com.ledao.consumer.service.RabbitMQConsumerService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.annotation.Resource;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * @author LeDao * @company * @create 2021-09-04 22:04 */@Controllerpublic class IndexController &#123; @Resource private RabbitMQConsumerService rabbitMQConsumerService; /** * 跳转到接收消息页面 * * @return */ @RequestMapping(&quot;/toReceiveMessagePage&quot;) public ModelAndView toReceiveMessagePage() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;receiveMessagePage&quot;); return mav; &#125; /** * 接收消息队列的一条消息 * * @return */ @ResponseBody @RequestMapping(&quot;/receiveMessage&quot;) public Map&lt;String, Object&gt; receiveMessage() &#123; Map&lt;String, Object&gt; resultMap = new HashMap&lt;&gt;(16); String message = rabbitMQConsumerService.receiveMessage(); resultMap.put(&quot;message&quot;, message != null ? message : &quot;消息队列为空!!&quot;+new Date()); return resultMap; &#125;&#125; 测试浏览器地址栏输入：http://localhost:81/toReceiveMessagePage 打开接收消息页面，然后点击接收按钮即可 PS.本博客只是实现了手动接收队列消息，监听队列接收消息查看博客：RabbitMQ实现监听队列接收消息","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ实现生产者发送消息","slug":"342","date":"2021-09-04T06:35:00.000Z","updated":"2022-04-14T02:17:51.757Z","comments":true,"path":"342.html","link":"","permalink":"https://blog.zoutl.cn/342.html","excerpt":"","text":"前提已经搭建好RabbitMQ基本环境，搭建步骤查看博客：搭建RabbitMQ基本环境 项目结构 实现过程application.yml配置添加一个application.yml配置文件，内容如下： 12345678910server: port: 80spring: rabbitmq: host: 192.168.0.145 #虚拟机IP port: 5672 #RabbitMQ默认TCP监听端口 username: admin #登录RabbitMQ管理系统的用户名 password: admin #登录RabbitMQ管理系统的密码 virtual-host: / #默认就是/,可不加 发送消息页面命名为：sendInformationPage.html，内容如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;发送消息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/sendInformation&quot; method=&quot;post&quot;&gt; 消息:&lt;input type=&quot;text&quot; name=&quot;information&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;发送&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; RabbitMQ配置类在rabbitmq-common模块下新建，命名为：RabbitMQConfig，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.ledao.common.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author LeDao * @company * @create 2021-09-04 13:03 */@Configurationpublic class RabbitMQConfig &#123; /** * direct交换机名称 */ public static final String DIRECT_EXCHANGE = &quot;directExchange&quot;; /** * direct队列名称 */ public static final String DIRECT_QUEUE = &quot;directQueue&quot;; /** * direct路由key */ public static final String DIRECT_ROUTINGKEY = &quot;directRoutingKey&quot;; /** * 定义一个direct交换机 * * @return */ @Bean public DirectExchange directExchange() &#123; return new DirectExchange(DIRECT_EXCHANGE); &#125; /** * 定义一个direct队列 * * @return */ @Bean public Queue directQueue() &#123; return new Queue(DIRECT_QUEUE); &#125; /** * 定义一个队列和交换机的绑定 * * @return */ @Bean public Binding directBinding() &#123; return BindingBuilder.bind(directQueue()).to(directExchange()).with(DIRECT_ROUTINGKEY); &#125;&#125; 生产者Service接口123456789101112131415161718package com.ledao.producer.service;/** * RabbitMQService生产者接口 * * @author LeDao * @company * @create 2021-09-04 13:27 */public interface RabbitMQProducerService &#123; /** * 发送消息 * * @param information */ void sendInformation(String information);&#125; Service接口实现类123456789101112131415161718192021222324252627package com.ledao.producer.service.impl;import com.ledao.common.config.RabbitMQConfig;import com.ledao.producer.service.RabbitMQProducerService;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.stereotype.Service;import javax.annotation.Resource;/** * RabbitMQService生产者接口实现类 * * @author LeDao * @company * @create 2021-09-04 13:31 */@Service(&quot;rabbitMQProducerService&quot;)public class RabbitMQProducerServiceImpl implements RabbitMQProducerService &#123; @Resource private AmqpTemplate amqpTemplate; @Override public void sendInformation(String information) &#123; amqpTemplate.convertAndSend(RabbitMQConfig.DIRECT_EXCHANGE, RabbitMQConfig.DIRECT_ROUTINGKEY, information); &#125;&#125; IndexController.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.ledao.producer.controller;import com.ledao.producer.service.RabbitMQProducerService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.servlet.ModelAndView;import javax.annotation.Resource;/** * @author LeDao * @company * @create 2021-09-04 13:48 */@Controllerpublic class IndexController &#123; @Resource private RabbitMQProducerService rabbitMQProducerService; /** * 发送消息页面 * * @return */ @RequestMapping(&quot;/toSendInformationPage&quot;) public ModelAndView sendInformation() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;sendInformationPage&quot;); return mav; &#125; /** * 发送消息 * * @param information * @return */ @ResponseBody @RequestMapping(&quot;/sendInformation&quot;) public String sendInformation(String information) &#123; rabbitMQProducerService.sendInformation(information); return &quot;发送消息到RabbitMQ成功&lt;a href=&#x27;/toSendInformationPage&#x27;&gt;&lt;button&gt;继续发送&lt;/button&gt;&lt;/a&gt;&quot;; &#125;&#125; 测试先启动rabbitmq-consumer模块再启动rabbitmq-producer模块，在浏览器地址栏输入：http://localhost/toSendInformationPage，输入消息后发送即可 查看消息步骤： 在浏览器地址栏输入：http://虚拟机IP:15672，输入用户名和密码后进入RabbitMQ管理系统 点击Queues选项查看所有队列，点击directQueue进入队列内部去查看消息 打开Get messages选项，在Messages文本框中输入查看消息的条数，点击Get Message(s)按钮即可查看消息","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"搭建RabbitMQ基本环境","slug":"341","date":"2021-09-04T06:09:18.000Z","updated":"2022-04-14T02:17:50.219Z","comments":true,"path":"341.html","link":"","permalink":"https://blog.zoutl.cn/341.html","excerpt":"","text":"创建父项目新建一个Maven项目,命名为：rabbitmqtest 完整pom.xml文件如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;rabbitmqtest&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;rabbitmq-producer&lt;/module&gt; &lt;module&gt;rabbitmq-consumer&lt;/module&gt; &lt;module&gt;rabbitmq-common&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;springboot.version&gt;2.5.4&lt;/springboot.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;springboot.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 创建子项目创建三个子项目，分别命名为：rabbitmq-common、rabbitmq-producer、rabbitmq-consumer rabbitmq-commonrabbitmq-common为公共项目，作用：存放一些其他项目公用的东西，比如依赖、实体类，工具类等 完整pom.xml如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;rabbitmqtest&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;rabbitmq-common&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; rabbitmq-producerrabbitmq-producer为消息提供者项目，作用：发送消息到RabbitMQ中 完整pom.xml如下： 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;rabbitmqtest&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;rabbitmq-producer&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建启动类，命名为：ProducerApplication，完整代码如下： 12345678910111213141516171819package com.ledao.producer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 提供者启动类 * * @author LeDao * @company * @create 2021-09-04 12:26 */@SpringBootApplicationpublic class ProducerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProducerApplication.class, args); &#125;&#125; rabbitmq-consumerrabbitmq-consumer为消息消费者项目，作用：消费RabbitMQ的消息 完整pom.xml如下： 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;rabbitmqtest&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;rabbitmq-consumer&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建启动类，命名为：ConsumerApplication，完整代码如下： 1234567891011121314151617181920package com.ledao.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 消费者启动类 * * @author LeDao * @company * @create 2021-09-04 12:28 */@SpringBootApplication@ComponentScan(basePackages = &quot;com.ledao&quot;)public class ConsumerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConsumerApplication.class, args); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"Docker安装RabbitMQ","slug":"340","date":"2021-09-04T02:28:47.000Z","updated":"2022-04-14T02:39:47.317Z","comments":true,"path":"340.html","link":"","permalink":"https://blog.zoutl.cn/340.html","excerpt":"","text":"拉取镜像1docker pull rabbitmq:3-management 创建运行容器1docker run -d --name rabbitmq -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 5672:5672 -p 15672:15672 RabbitMQ镜像id RABBITMQ_DEFAULT_USER设置登录RabbitMQ管理系统的用户名 RABBITMQ_DEFAULT_PASS设置登录RabbitMQ管理系统的密码 5672是RabbitMQ默认TCP监听端口 15672是RabbitMQ的Web管理界面端口 测试在浏览器地址栏输入：http://虚拟机IP:15672/ ，输入用户名和密码，用户名和密码都是admin","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"RabbitMQ简介和使用场景","slug":"339","date":"2021-09-04T01:47:53.000Z","updated":"2022-04-14T02:17:44.468Z","comments":true,"path":"339.html","link":"","permalink":"https://blog.zoutl.cn/339.html","excerpt":"","text":"转载于：RabbitMQ 简介以及使用场景 - 海向 - 博客园 (cnblogs.com) 简介MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求 RabbitMQ是使用Erlang语言开发的开源消息队列系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由(包括点对点和发布/订阅)、可靠性、 安全。AMQP协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次 使用场景使用场景有：解耦、异步提升效率、流量削峰 解耦为面向服务的架构（SOA）提供基本的最终一致性实现 场景说明：用户下单后，订单系统需要通知库存系统 传统的做法是，订单系统调用库存系统的接口 传统模式的缺点：①假如库存系统无法访问，则订单减库存将失败，从而导致订单失败②订单系统与库存系统耦合 引入消息队列 订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功 库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作 假如：在下单时库存系统不能正常使用，也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了，实现了订单系统与库存系统的应用解耦 为了保证库存肯定有，可以将队列大小设置成库存数量，或者采用其他方式解决 基于消息的模型，关心的是“通知”，而非“处理” 短信、邮件通知、缓存刷新等操作使用消息队列进行通知 消息队列和RPC的区别与比较： RPC: 异步调用，及时获得调用结果，具有强一致性结果，关心业务调用处理结果 消息队列：两次异步RPC调用，将调用内容在队列中进行转储，并选择合适的时机进行投递（错峰流控） 异步提升效率场景说明：用户注册后，需要发注册邮件和注册短信 传统的做法有两种：1.串行的方式；2.并行方式 （1）串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端 （2）并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间 引入消息队列，将不是必须的业务逻辑，异步处理。改造后的架构如下： 流量削峰流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛 应用场景：系统其他时间A系统每秒请求量就100个，系统可以稳定运行。系统每天晚间八点有秒杀活动，每秒并发请求量增至1万条，但是系统最大的处理能力只能每秒处理1000个请求，于是系统崩溃，服务器宕机 之前架构：大量用户（100万用户）通过浏览器在晚上八点高峰期同时参与秒杀活动。大量的请求涌入我们的系统中，高峰期达到每秒钟5000个请求，大量的请求打到MySQL上，每秒钟预计执行3000条SQL。但是一般的MySQL每秒钟扛住2000个请求就不错了，如果达到3000个请求的话可能MySQL直接就瘫痪了，从而系统无法被使用。但是高峰期过了之后，就成了低峰期，可能也就1万用户访问系统，每秒的请求数量也就50个左右，整个系统几乎没有任何压力 引入MQ：100万用户在高峰期的时候，每秒请求有5000个请求左右，将这5000请求写入MQ里面，系统A每秒最多只能处理2000请求，因为MySQL每秒只能处理2000个请求。系统A从MQ中慢慢拉取请求，每秒就拉取2000个请求，不要超过自己每秒能处理的请求数量即可。MQ，每秒5000个请求进来，结果只有2000个请求出去，所以在秒杀期间（将近一小时）可能会有几十万或者几百万的请求积压在MQ中。这个短暂的高峰期积压是没问题的，因为高峰期过了之后，每秒就只有50个请求进入MQ了，但是系统还是按照每秒2000个请求的速度在处理，所以说，只要高峰期一过，系统就会快速将积压的消息消费掉。我们在此计算一下，每秒在MQ积压3000条消息，1分钟会积压18万，1小时积压1000万条消息，高峰期过后，1个多小时就可以将积压的1000万消息消费掉 优缺点优点优点就是以上的那些场景应用，就是在特殊场景下有其对应的好处，解耦、异步、削峰 缺点 系统的可用性降低系统引入的外部依赖越多，系统越容易挂掉，本来只是A系统调用BCD三个系统接口就好，ABCD四个系统不报错整个系统会正常运行。引入了MQ之后，虽然ABCD系统没出错，但MQ挂了以后，整个系统也会崩溃 系统的复杂性提高引入了MQ之后，需要考虑的问题也变得多了，如何保证消息没有重复消费？如何保证消息不丢失？怎么保证消息传递的顺序？ 一致性问题A系统发送完消息直接返回成功，但是BCD系统之中若有系统写库失败，则会产生数据不一致的问题 总结所以总结来说，消息队列是一种十分复杂的架构，引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避。引入MQ系统复杂度提升了一个数量级，但是在有些场景下，就是复杂十倍百倍，还是需要使用MQ","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"}]},{"title":"MySQL创建计算字段","slug":"338","date":"2021-09-03T14:47:00.000Z","updated":"2022-04-14T02:33:45.508Z","comments":true,"path":"338.html","link":"","permalink":"https://blog.zoutl.cn/338.html","excerpt":"","text":"介绍如果存储在表中的数据都不是应用程序所需要的，那么我们需要直接从数据库中检索出转换、计算或格式化过的数据，而不是检索出数据，然后再在客户机应用程序或报告程序中重新格式化。 拼接字段介绍所谓拼接，就是将值联结到一起构成单个值，即把两个列拼接起来 在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列 普通拼接拼接姓名和年龄 1SELECT CONCAT(&#x27;姓名：&#x27;,student_name,&#x27;，年龄：&#x27;,age) FROM t_student; 使用别名拼接姓名和年龄，并且设置别名为student_message，第一行数据的上方就是别名 1SELECT CONCAT(&#x27;姓名：&#x27;,student_name,&#x27;，年龄：&#x27;,age) AS student_message FROM t_student; 去除空格 函数 作用 TRIM() 去除两端的空格 LTRIM() 去除左侧的空格 RTRIM() 去除右侧的空格 去除学生姓名两端的空格 1SELECT CONCAT(&#x27;姓名：&#x27;,TRIM(student_name),&#x27;，年龄：&#x27;,age) FROM t_student; 算数计算介绍对检索出的数据进行算术计算 表结构 例子计算学生的总分 1SELECT student_id,chinese_score+math_score+english_score AS score_total FROM t_score2;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL使用正则表达式","slug":"337","date":"2021-09-03T06:09:33.000Z","updated":"2022-04-14T02:34:30.115Z","comments":true,"path":"337.html","link":"","permalink":"https://blog.zoutl.cn/337.html","excerpt":"","text":"简介正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较，在搜索子句中使用正则表达式，必须使用REGEXP操作符 实例基本字符匹配选出学生姓名中包含“赵六”的学生 1SELECT * FROM t_student WHERE student_name REGEXP &quot;赵六&quot;; 选出学生姓名以一个字符+“赵六”开头的学生，一个.匹配一个字符 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;.赵六&#x27;; 区分大小写正则表达式默认是不区分大小写的，要区分大小写就使用BINARY关键字 选出学生姓名中包含“a”的学生，如果不使用BINARY关键字就选出学生姓名中包含“a”或“A”的学生 1SELECT * FROM t_student WHERE student_name REGEXP BINARY &#x27;a&#x27;; OR匹配|为正则表达式的OR操作符，它表示匹配其中之一 选出学生姓名中包含“张三”或“赵六”的学生 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;张三|赵六&#x27;; 匹配几个字符之一只想匹配特定的字符，可通过指定一组用[]括起来的字符来完成 选出学生姓名中包含“1赵六”或“2赵六”的学生 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;[12]赵六&#x27;; 匹配范围[0123456789]可以用[0-9]替换 [abc…xyz]可以用[a-z]替换，MySQL的正则表达式是不区分大小写的，要区分大小写就使用BINARY关键字 选出学生姓名中包含“1赵六”或者“2赵六”或者…或者“9赵六”的学生 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;[0-9]赵六&#x27;; 匹配特殊字符正则表达式语言由具有特定含义的特殊字符构成，常见的正则表达式特殊字符有：.、[]、|和-等，还有一些其它特殊字符，如果需要匹配这些字符，那么就要在这些特殊字符前加\\\\ 选出学生姓名中包含“-”的学生 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;\\\\-&#x27;; 选出学生姓名中包含“\\”的学生，匹配反斜杠\\则需要四个反斜杠 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;\\\\\\\\&#x27;; 匹配字符类 类 说明 [:alnum:] 任意字母和数字（同[a-zA-Z0-9]） [:alpha:] 任意字符（同[a-zA-Z]） [:blank:] 空格和制表（同[\\t]） [:cntrl:] ASCII控制字符（ASCII 0到31和127） [:digit:] 任意数字（同[0-9]） [:graph:] 与[:print:]相同，但不包括空格 [:lower:] 任意小写字母（同[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]） [:upper:] 任意大写字母（同[A-Z]） [:xdigit:] 任意十六进制数字（同[a-fA-F0-9]） 选出学生姓名中包含两个连续数字的学生，[[:digit:]]表示任意数字，{2}表示连续两个 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;[[:digit:]]&#123;2&#125;&#x27;; 定位符^ ：文本的开始 选出学生姓名中以“32”开头的学生 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;^32&#x27;; $ ：文本的结尾 选出学生姓名中以“12”结尾的学生 1SELECT * FROM t_student WHERE student_name REGEXP &#x27;12$&#x27;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL使用通配符过滤数据","slug":"336","date":"2021-09-03T05:18:45.000Z","updated":"2022-04-14T02:34:31.818Z","comments":true,"path":"336.html","link":"","permalink":"https://blog.zoutl.cn/336.html","excerpt":"","text":"简介MySQL通配符有百分号（%）通配符和 下划线（_）通配符，在搜索子句中使用通配符，必须使用LIKE操作符。 百分号通配符最常使用的通配符是百分号（%），在搜索串中，%表示任何字符出现任意次数，不出现也可以。 单个%%在开头 选出学生姓名以 “赵六” 结尾的学生 1SELECT * FROM t_student WHERE student_name LIKE &quot;%赵六&quot;; %在结尾 选出学生姓名以 “赵六” 开头的学生 1SELECT * FROM t_student WHERE student_name LIKE &quot;赵六%&quot;; 两个%一个在开头，一个在结尾，可用于模糊搜索 选出学生姓名中包含 “赵六” 的学生 1SELECT * FROM t_student WHERE student_name LIKE &quot;%赵六%&quot;; 下划线通配符下划线的用途与%一样，但下划线只匹配单个字符而不是多个字符，匹配多少个字符就要多少个下划线，下面例子都只匹配了1个字符 单个__在开头 选出学生姓名以 “赵六” 结尾且前面有一个字符的学生 1SELECT * FROM t_student WHERE student_name LIKE &quot;_赵六&quot;; _在结尾 选出学生姓名以 “赵六” 开头且后面有一个字符的学生 1SELECT * FROM t_student WHERE student_name LIKE &quot;赵六_&quot;; 多个_一个在开头，一个在结尾 选出学生姓名包含 “赵六” 开头且前面和后面各有一个字符的学生 1SELECT * FROM t_student WHERE student_name LIKE &quot;_赵六_&quot;;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"SELECT语句的WHERE子句","slug":"335","date":"2021-09-02T16:57:02.000Z","updated":"2022-04-14T02:34:35.418Z","comments":true,"path":"335.html","link":"","permalink":"https://blog.zoutl.cn/335.html","excerpt":"","text":"介绍在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤，WHERE子句在表名（FROM子句）之后给出 操作符 操 作 符 说 明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 BETWEEN 在指定的两个值之间 实例=选出 年龄为10岁 的学生 1SELECT * FROM t_student WHERE age=10; &lt;&gt;选出 年龄不是10岁 的学生 1SELECT * FROM t_student WHERE age&lt;&gt;10; !=选出 年龄不是10岁 的学生 1SELECT * FROM t_student WHERE age!=10; &lt;选出 年龄小于10岁 的学生 1SELECT * FROM t_student WHERE age&lt;10; &lt;=选出 年龄小于等于10岁 的学生 1SELECT * FROM t_student WHERE age&lt;=10; &gt;选出 年龄大于10岁 的学生 1SELECT * FROM t_student WHERE age&gt;10; &gt;=选出 年龄大于等于10岁 的学生 1SELECT * FROM t_student WHERE age&gt;=10; BETWEEN选出 年龄为10~12岁 的学生，包括10岁和12岁 1SELECT * FROM t_student WHERE age BETWEEN 10 AND 12; 空值检查选出 年龄为空 的学生 1SELECT * FROM t_student WHERE age IS NULL; AND选出 年龄为12岁且班级id为1 的学生 1SELECT * FROM t_student WHERE age=12 AND classId=1; OR选出 年龄为11岁或者12岁 的学生 1SELECT * FROM t_student WHERE age=11 OR age=12; AND和OR搭配SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符，不想优先处理就给OR加括号 年龄为11岁的学生 + 年龄为12岁且班级id为2的学生 1SELECT * FROM t_student WHERE age=11 OR age=12 AND classId=2; 选出年龄为11岁或12岁的学生，再从这些学生中选出班级id为2的学生 1SELECT * FROM t_student WHERE (age=11 OR age=12) AND classId=2; IN选出 年龄为11岁或者12岁 的学生 1SELECT * FROM t_student WHERE age IN (11,12); NOT选出 年龄不是11岁或者12岁 的学生 1SELECT * FROM t_student WHERE age NOT IN (11,12);","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"SELECT语句的ORDER BY子句","slug":"334","date":"2021-09-02T15:43:11.000Z","updated":"2022-04-14T02:33:32.035Z","comments":true,"path":"334.html","link":"","permalink":"https://blog.zoutl.cn/334.html","excerpt":"","text":"学生表数据 实例升序默认就是升序排序，即可以不加ASC关键字 按年龄升序排序 1SELECT * FROM t_student ORDER BY age ASC; 降序使用DESC关键字 按年龄降序排序 1SELECT * FROM t_student ORDER BY age DESC; 多个列排序先根据年龄升序排序，如果有年龄相同的学生，再根据班级id升序排序这些年龄相同的学生 1SELECT * FROM t_student ORDER BY age,classId; 取最大值使用ORDER BY和LIMIT的组合，能够找出一个列中最高或最低的值 选出年龄最大的 1SELECT * FROM t_student ORDER BY age DESC LIMIT 1;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"Nginx+Redis+Tomcat实现负载均衡共享session","slug":"333","date":"2021-09-02T06:24:22.000Z","updated":"2022-04-14T02:38:39.888Z","comments":true,"path":"333.html","link":"","permalink":"https://blog.zoutl.cn/333.html","excerpt":"","text":"说明Nginx、Tomcat和Redis都是Docker创建的容器 下载项目下载将项目拉到idea上，GitHub地址为：a6678696/RedisSessionDemo: Redis存储session例子 (github.com)，，这个项目实现了Redis存储session，实现Redis存储session的博客地址为：Spring Boot 实现 Redis 存储 session | LeDao 的博客 (zoutl.cn) 修改根据Docker的Tomcat容器端口号修改一下application.yml、info.html、login.html、main.html的端口号，方便测试时辨认出访问的是哪个Tomcat的项目 将application.yml的spring.redis.host修改为Docker给Redis分配的IP地址，查看IP地址命令如下： 1docker inspect Redis容器id 打包将项目打包成war包，具体步骤查看：idea将Spring Boot项目打包成war包 ，打包时会报错，跳过Maven打包项目时测试步骤就行了（点击Maven工具栏的取消测试按钮，如下图划红线的按钮） 运行项目使用Docker创建两个Tomcat容器，并运行打包好的项目，具体步骤查看博客：Docker安装和配置Tomcat容器并部署Java项目 配置Nginx修改nginx.conf在 include /etc/nginx/conf.d/*.conf; 上面添加：（IP地址和端口根据自己的实际情况填写，IP地址是Docker给Tomcat分配的，并不是虚拟机的IP） 1234upstream www.123.com&#123; server 172.17.0.4:8888; server 172.17.0.5:9999;&#125; 修改default.conf可以用以下内容覆盖掉原来的 1234567891011server &#123; listen 80; server_name www.123.com; location / &#123; proxy_pass http://www.123.com; index index.html index.htm; &#125;&#125; 添加本机域名找到 C:\\Windows\\System32\\drivers\\etc 打开hosts，底部加配置： 1虚拟机IP www.123.com 测试浏览器地址栏输入：http://www.123.com/ ，测试时可以发现：交替访问两个Tomcat运行的项目，这时候实现了负载均衡。由于这两个项目都是使用Redis的同一个session，也就是共享","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Spring Boot实现Redis存储session","slug":"332","date":"2021-09-02T01:17:10.000Z","updated":"2022-04-14T02:17:36.972Z","comments":true,"path":"332.html","link":"","permalink":"https://blog.zoutl.cn/332.html","excerpt":"","text":"创建项目引入依赖创建一个Spring Boot项目，引入Spring Boot DevTools、Spring Web、Thymeleaf依赖，这里是创建项目时引入，下面是创建后引入，可以创建时引入就尽量创建时引入，比较方便 项目结构 引入依赖在pom文件中添加： 123456789101112131415161718&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.lettuce/lettuce-core --&gt;&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.1.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 完整pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.5.4&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.ledao&lt;/groupId&gt; &lt;artifactId&gt;RedisSessionDemo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;RedisSessionDemo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.session/spring-session-data-redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;2.5.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.lettuce/lettuce-core --&gt; &lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;6.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml配置12345678910111213141516171819202122232425server: port: 8888 servlet: context-path: / tomcat: uri-encoding: utf-8spring: session: store-type: redis #指定redis实现spring session timeout: PT1H # Session 过期时间， PT开头 ‘D’ – 天 ‘H’ – 小时 ‘M’ – 分钟 ‘S’ – 秒 redis: flush-mode: on_save # Sessions 刷新模式 on_save http response为committed才提交 immediate 立即提交 namespace: ledao # session 存储命名空间 redis: host: 192.168.0.106 #Linux服务器IP地址 port: 6379 #Redis端口号,一般默认为6379 password: lettuce: pool: max-active: 8 # 连接池最大连接数（使用负值表示没有限制） max-wait: -1 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-idle: 8 # 连接池中的最大空闲连接 min-idle: 0 # 连接池中的最小空闲连接 shutdown-timeout: 100 # 连接超时时间（毫秒） 启动类添加注解添加注解@EnableRedisHttpSession 1234567891011121314151617181920212223242526package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;/** * @author LeDao */@EnableRedisHttpSession@SpringBootApplicationpublic class RedisSessionDemoApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(RedisSessionDemoApplication.class); &#125; public static void main(String[] args) &#123; SpringApplication.run(RedisSessionDemoApplication.class, args); &#125;&#125; Java代码User.java要实现Serializable序列化，不然会Redis会报错：org.springframework.data.redis.serializer.SerializationException: Cannot serialize 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.ledao.entity;import java.io.Serializable;/** * 用户实体类 * * @author LeDao * @company * @create 2021-09-02 9:49 */public class User implements Serializable &#123; private static final long serialVersionUID = -1; private Integer id; private String userName; private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, userName=&#x27;&quot; + userName + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; IndexController.java12345678910111213141516171819202122232425262728package com.ledao.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;/** * @author LeDao * @company * @create 2021-09-02 9:50 */@Controllerpublic class IndexController &#123; @RequestMapping(&quot;/&quot;) public ModelAndView root() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;login&quot;); return mav; &#125; @RequestMapping(&quot;/getInfo&quot;) public ModelAndView getInfo() &#123; ModelAndView mav = new ModelAndView(); mav.setViewName(&quot;info&quot;); return mav; &#125;&#125; UserController.java1234567891011121314151617181920212223242526272829303132package com.ledao.controller;import com.ledao.entity.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpSession;/** * @author LeDao * @company * @create 2021-09-02 9:50 */@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @RequestMapping(&quot;/login&quot;) public ModelAndView login(HttpSession session, User user) &#123; ModelAndView mav = new ModelAndView(); String password = &quot;123&quot;; if (password.equals(user.getPassword())) &#123; session.setAttribute(&quot;currentUser&quot;, user); mav.setViewName(&quot;main&quot;); &#125; else &#123; mav.addObject(&quot;errorInfo&quot;, &quot;用户名或者密码错误！&quot;); mav.setViewName(&quot;login&quot;); &#125; return mav; &#125;&#125; HTML页面login.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/user/login&quot; method=&quot;post&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;userName&quot;&gt; 密码: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; main.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录成功&lt;/h1&gt;&lt;h2 style=&quot;color: blue&quot;&gt;当前用户:&lt;sapn th:text=&quot;$&#123;session.currentUser.userName&#125;&quot;&gt;&lt;/sapn&gt;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; info.html1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;当前用户信息:&lt;span th:text=&quot;$&#123;&#x27;用户名:&#x27;+session.currentUser.userName+&#x27;,密码:&#x27;+session.currentUser.password&#125;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 测试 浏览器地址栏输入：http://localhost:8888/ ，进入登录页面login.html 输入用户名和密码，只要密码是123就可以登录成功，然后进入主页面main.html 浏览器地址栏输入：http://localhost:8888/getInfo，进入显示当前登录用户信息页面info.html 在Redis可视化工具可以看到有一个用户session 打开另一个浏览器，重复①②③步骤，然后Redis可视化工具可以看到多了一个用户session PS.GitHub地址：a6678696/RedisSessionDemo: Redis存储session例子 (github.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Docker安装Redis","slug":"331","date":"2021-09-02T00:06:24.000Z","updated":"2022-04-14T02:39:43.605Z","comments":true,"path":"331.html","link":"","permalink":"https://blog.zoutl.cn/331.html","excerpt":"","text":"拉取镜像1docker pull redis:5 创建并运行容器只运行不进入，要创建并运行就把 -d 改为 -it ，或者使用下面的进入Redis容器命令 1docker run -d -p 6379:6379 Redis镜像id 进入容器进入容器命令行界面后就可以愉快地玩耍了 1docker exec -it Redis容器id redis-cli Redis可视化工具下载我使用的是AnotherRedisDesktopManager，下载地址：AnotherRedisDesktopManager 发行版 - Gitee.com，Windows下载第一个，像一般软件那般安装接口 使用点击新建连接，地址填Linux服务器IP地址，端口一般都是6379，连接名称根据自己的需求填 连接成功后，就可以管理Redis了","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Keepalived+Nginx+Tomcat负载均衡","slug":"330","date":"2021-09-01T12:41:02.000Z","updated":"2022-04-14T02:38:30.442Z","comments":true,"path":"330.html","link":"","permalink":"https://blog.zoutl.cn/330.html","excerpt":"","text":"启动Tomcat主机和备用机分别使用Docker启动一个Tomcat，版本号最好不同，启动成功后有可能通过外部浏览器无法访问，解决方法查看博客：Docker启动Tomcat成功后外部却无法访问 修改Nginx配置修改主机和备用机的Nginx配置，修改内容一样 修改nginx.conf配置文件（在/etc/nginx目录下），在include /etc/nginx/conf.d/*.conf上方加上： 1234upstream www.123.com&#123; server 192.168.0.106:8080 weight=5; server 192.168.0.107:8080 weight=10;&#125; 修改default.conf配置文件（在/etc/nginx/conf.d目录下），在location /节点加上： 1proxy_pass http://www.123.com; server_name可以修改成 www.123.com ，也可以不修改 重启Nginx1systemctl restart nginx 测试浏览器地址输入：http://192.168.0.106/或者http://192.168.0.107/ 不断刷新页面，访问了主机和备用机的Tomcat，此时Nginx+Tomcat负载均衡完成 如果出现错误：502 Bad Gateway，这是因为Nginx 主机的 SELinux 服务限制了其（即 Nginx）使用 http 访问权限引起的，输入以下命令即可解决此问题，如果不生效再重启Nginx 1setsebool -P httpd_can_network_connect 1 # “1”为开启，“0”为关闭 打开Keepalived服务 1systemctl start keepalived 浏览器地址输入Keepalived配置的virtual_ipaddress，该配置文件在/etc/keepalived目录下，此时已经完成了Keepalived+Nginx+Tomcat负载均衡","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"},{"name":"Keepalived","slug":"Keepalived","permalink":"https://blog.zoutl.cn/tags/Keepalived/"}]},{"title":"通过shell脚本优化Keepalived+Nginx高可用集群","slug":"329","date":"2021-09-01T04:46:56.000Z","updated":"2022-04-14T02:38:41.813Z","comments":true,"path":"329.html","link":"","permalink":"https://blog.zoutl.cn/329.html","excerpt":"","text":"问题描述Keepalived不容易挂掉，容易挂掉的是Nginx，如果Nginx挂掉了依然可以通过Keepalived访问机器，但是访问不到Nginx服务。所以这里需要借助Keepalived的vrrp_script配置来调用自定义shell脚本，来检测Nginx是否挂掉，如果Nginx挂掉了，就启动它，打开失败就关闭Keepalived启用备用机 实现过程编写shell脚本在 / 目录下新建shell目录存放shell脚本文件 1mkdir /shell 新建 .sh文件，命名为：nginx_check.sh，内容如下：（该脚本的功能为通过 ps -ef|grep -w nginx|grep -v grep|wc -l查看当前有多少个Nginx服务在运行，如果返回0说明Nginx服务没有运行，就启动Nginx，过2秒再查看是否启动成功，启动失败就停止Keepalived启用备用机） 1234567891011121314151617181920#!/bin/bashecho &#x27;check Nginx&#x27;count_nginx=`ps -ef|grep -w nginx|grep -v grep|wc -l`echo $count_nginxif [ $count_nginx -eq 0 ];then systemctl start nginx echo &#x27;start Nginx&#x27; sleep 2 if [ `ps -ef|grep -w nginx|grep -v grep|wc -l` -eq 0 ];then echo &#x27;stop keepalived&#x27; systemctl stop keepalived fi fi 修改Keepalived配置配置文件路径为：/etc/keepalived/keepalived.conf 添加节点： 12345vrrp_script check_nginx &#123; script &quot;/shell/nginx_check.sh&quot; nterval 2 weight -20&#125; 在vrrp_instance VI_1节点添加： 123track_script &#123; check_nginx&#125; 完整keepalived.conf如下： 1234567891011121314151617181920212223242526272829303132333435363738394041! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id KEEPALIVED_NGINX_MASTER vrrp_skip_check_adv_addr # vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0&#125;vrrp_script check_nginx &#123; script &quot;/shell/nginx_check.sh&quot; nterval 2 weight -20&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; track_script &#123; check_nginx &#125; virtual_ipaddress &#123; 192.168.1.99 &#125;&#125; 重启Keepalived服务1systemctl restart keepalived 测试关闭Nginx服务 1systemctl stop nginx 等2秒查看Nginx服务状态：Nginx服务正在运行 1systemctl status nginx PS.我在测试时keepalived vrrp_script始终不起作用，通过网上的解决方案也没有解决，所以我就不使用vrrp_script了，转而使用Linux的Crontab定时任务定时执行检测脚本，如何使用Crontab查看博客：CentOS7使用Crontab定时任务 如果你解决了keepalived vrrp_script不起作用，请在评论区留言一下，谢谢(～￣▽￣)～","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"},{"name":"Keepalived","slug":"Keepalived","permalink":"https://blog.zoutl.cn/tags/Keepalived/"},{"name":"shell","slug":"shell","permalink":"https://blog.zoutl.cn/tags/shell/"}]},{"title":"CentOS7使用Crontab定时任务","slug":"328","date":"2021-09-01T04:01:53.000Z","updated":"2022-04-14T02:36:57.496Z","comments":true,"path":"328.html","link":"","permalink":"https://blog.zoutl.cn/328.html","excerpt":"","text":"常用命令启动 1systemctl start crond 停止 1systemctl stop crond 重启 1systemctl restart crond 查看状态 1systemctl status crond 赋予权限Crontab定时任务是没有权限执行shell脚本的，要先赋予脚本777权限 1chmod 777 脚本名称（不在当前目录要加上路径） 执行方式脚本放在目录把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次 编写crontab命令进入当前用户的工作表编辑，是常见的vim界面，每行是一条命令 1crontab -e crontab的命令构成为 时间+动作，下面的* * * * *是时间，shell脚本路径为动作 时间有分、时、日、月、周五种，操作符有： ***** ：取值范围内的所有数字 / ：每过多少个数字 - ：从X到Z , ：散列数字 一些实例： 1234567891011121314151617181920212223242526272829303132333435实例1：每1分钟执行一次myCommand* * * * * myCommand实例2：每小时的第3和第15分钟执行3,15 * * * * myCommand实例3：在上午8点到11点的第3和第15分钟执行3,15 8-11 * * * myCommand实例4：每隔两天的上午8点到11点的第3和第15分钟执行3,15 8-11 */2 * * myCommand实例5：每周一上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1 myCommand实例6：每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart实例7：每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart实例8：每周六、周日的1 : 10重启smb10 1 * * 6,0 /etc/init.d/smb restart实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb0,30 18-23 * * * /etc/init.d/smb restart实例10：每星期六的晚上11 : 00 pm重启smb0 23 * * 6 /etc/init.d/smb restart实例11：每一小时重启smb0 */1 * * * /etc/init.d/smb restart实例12：晚上11点到早上7点之间，每隔一小时重启smb0 23-7/1 * * * /etc/init.d/smb restart","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Crontab","slug":"Crontab","permalink":"https://blog.zoutl.cn/tags/Crontab/"}]},{"title":"PotPlayer安装皮肤","slug":"327","date":"2021-08-30T13:06:23.000Z","updated":"2022-03-26T15:40:44.366Z","comments":true,"path":"327.html","link":"","permalink":"https://blog.zoutl.cn/327.html","excerpt":"","text":"下载皮肤下载地址：PotPlayer皮肤 - PotPlayer中文网 (potplayercn.com) 安装皮肤下载后解压解压时选择提取到xxxxx文件夹，xxxxx就是下载好的压缩包名称 找到皮肤文件夹打开PotPlayer后，在界面上右键点击，选择皮肤–&gt;&gt;皮肤设置 打开皮肤文件夹，找到PotPlayer的皮肤安装目录 使用皮肤然后把上面解压后的文件夹复制到皮肤文件夹中，再重启PotPlayer，在界面上右键点击，选择皮肤再选择对应的皮肤即可","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"Keepalived+Nginx实现高可用集群配置","slug":"326","date":"2021-08-30T04:54:13.000Z","updated":"2022-04-14T02:38:27.786Z","comments":true,"path":"326.html","link":"","permalink":"https://blog.zoutl.cn/326.html","excerpt":"","text":"克隆虚拟机克隆当前虚拟机，查看克隆步骤：VMware克隆虚拟机 ，当前虚拟机为主机，克隆的虚拟机为备用机（主机崩了才会启用备用机） 配置主机配置虚拟机hosts文件路径为：/etc/hosts，在底部添加： 1127.0.0.1 KEEPALIVED_NGINX_MASTER Keepalived配置介绍1234567891011121314151617181920212223242526272829303132333435# 全局配置global_defs &#123; notification_email &#123; # keepalived服务宕机异常出现的时候，发送通知邮件 可以是多个 acassen@firewall.loc # 收件人邮箱1 failover@firewall.loc # 收件人邮箱2 sysadmin@firewall.loc # 收件人邮箱3 &#125; notification_email_from Alexandre.Cassen@firewall.loc #邮件发件人 smtp_server 192.168.200.1 # 邮件服务器地址 smtp_connect_timeout 30 # 超时时间 router_id LVS_DEVEL # 路由id 多个keepalived集群的时候 必须一致 vrrp_skip_check_adv_addr # 默认是不跳过检查。检查收到的VRRP通告中的所有地址可能会比较耗时，设置此命令的意思是，如果通告与接收的上一个通告来自相同的master路由器，则不执行检查(跳过检查)。 vrrp_strict # 这个东西要注释掉，否则要出乱子。严格遵守VRRP协议。下列情况将会阻止启动Keepalived：1. 没有VIP地址。2. 单播邻居。3. 在VRRP版本2中有IPv6地址。 vrrp_garp_interval 0 # 小数类型，单位秒，在一个网卡上每组gratuitous arp消息之间的延迟时间，默认为0，一个发送的消息=n组 arp报文 vrrp_gna_interval 0 # 小数类型，单位秒， 在一个网卡上每组na消息之间的延迟时间，默认为0&#125;# vrrp实例 我们集群设置 多机配置，除了state和priority不一样，其他都一样vrrp_instance VI_1 &#123; state MASTER # 服务器状态 MASTER是主服务器 BACKUP是备份服务器 主服务器的priority要比备份服务器大 interface eth0 # 通信端口 通过ip addr可以看到 根据自己的机器配置 virtual_router_id 51 # vrrp实例id keepalived集群，实例id必须一致 priority 100 # 权重比 主服务器的priority要比备份服务器大 advert_int 1 # 心跳间隔 单位秒 keepalived多机器集群 通过心跳检测，如果发送心跳没反应 就立刻接管； authentication &#123; # 服务器之间通信密码 auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; # 自定义虚拟IP 192.168.200.16 192.168.200.17 192.168.200.18 &#125;&#125; 修改Keepalived配置文件修改 /etc/keepalived 目录下的keepalived.conf配置文件，除了global_defs和vrrp_instance VI_1节点配置外，下面的节点配置都删除 global_defs.router_id修改为：KEEPALIVED_NGINX_MASTER 把global_defs.vrrp_strict注释掉 vrrp_instance VI_1.state修改为：MASTER vrrp_instance VI_1.interface修改为：ens33 vrrp_instance VI_1.priority修改为：100 vrrp_instance VI_1.virtual_ipaddress修改为：192.168.1.99 完整keepalived.conf配置如下： 1234567891011121314151617181920212223242526272829303132! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id KEEPALIVED_NGINX_MASTER vrrp_skip_check_adv_addr # vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0&#125;vrrp_instance VI_1 &#123; state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.99 &#125;&#125; 配置备用机配置虚拟机hosts文件路径为：/etc/hosts，在底部添加： 1127.0.0.1 KEEPALIVED_NGINX_BACKUP 修改Keepalived配置文件修改 /etc/keepalived 目录下的keepalived.conf配置文件，除了global_defs和vrrp_instance VI_1节点配置外，下面的节点配置都删除 global_defs.router_id修改为：KEEPALIVED_NGINX_BACKUP 把global_defs.vrrp_strict注释掉 vrrp_instance VI_1.state修改为：BACKUP vrrp_instance VI_1.interface修改为：ens33 vrrp_instance VI_1.priority修改为：50 vrrp_instance VI_1.virtual_ipaddress修改为：192.168.1.99 完整keepalived.conf配置如下： 1234567891011121314151617181920212223242526272829303132! Configuration File for keepalivedglobal_defs &#123; notification_email &#123; acassen@firewall.loc failover@firewall.loc sysadmin@firewall.loc &#125; notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 router_id KEEPALIVED_NGINX_BACKUP vrrp_skip_check_adv_addr # vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0&#125;vrrp_instance VI_1 &#123; state BACKUP # 服务器状态 MASTER是主服务器 BACKUP是备份服务器 主服务器的priority要比备份服务器大 interface ens33 # 通信端口 通过ip addr可以看到 根据自己的机器配置 virtual_router_id 51 priority 50 # 权重 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; virtual_ipaddress &#123; 192.168.1.99 &#125;&#125; 测试修改Nginx首页分别修改主机和备用机的Nginx运行成功的首页，文件路径为：/usr/share/nginx/html/index.html，在首页代码中添加虚拟机IP以方便辨认访问的是哪个虚拟机 启动Keepalived启动主机和备用机的Keepalived 1systemctl start keepalived.service 访问浏览器地址栏输入：http://192.168.1.99/，此时访问的是主机的Nginx 然后停掉主机的Keepalived 1systemctl stop keepalived.service 刷新一下页面，此时访问的是备用机的Nginx","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"},{"name":"Keepalived","slug":"Keepalived","permalink":"https://blog.zoutl.cn/tags/Keepalived/"}]},{"title":"VMware克隆虚拟机","slug":"325","date":"2021-08-30T04:37:03.000Z","updated":"2022-03-26T15:44:03.672Z","comments":true,"path":"325.html","link":"","permalink":"https://blog.zoutl.cn/325.html","excerpt":"","text":"关闭虚拟机如果要克隆的虚拟机正在运行，就先把它停掉，正在运行的虚拟机是无法克隆的 开始克隆 选中要克隆的虚拟机右键点击，选择 管理–&gt;&gt;克隆 克隆类型选择完整克隆 填写虚拟机名称以及存储路径","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"CentOS7安装Keepalived","slug":"324","date":"2021-08-30T00:54:42.000Z","updated":"2022-04-14T02:37:16.353Z","comments":true,"path":"324.html","link":"","permalink":"https://blog.zoutl.cn/324.html","excerpt":"","text":"安装1yum install keepalived 常用命令启动 1systemctl start keepalived.service 关闭 1systemctl stop keepalived.service 重启 1systemctl restart keepalived.service 查看日志 1tail -f /var/log/messages PS.配置文件在/etc/keepalived目录下，名称为：keepalived.conf 日志文件在/var/log目录下，名称为：messages","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"},{"name":"Keepalived","slug":"Keepalived","permalink":"https://blog.zoutl.cn/tags/Keepalived/"}]},{"title":"CentOS7安装Nginx","slug":"323","date":"2021-08-30T00:15:10.000Z","updated":"2022-04-14T02:36:49.548Z","comments":true,"path":"323.html","link":"","permalink":"https://blog.zoutl.cn/323.html","excerpt":"","text":"添加Nginx源CentOS7默认是没有Nginx源的，Nginx官方提供了添加源的命令： 1rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装Nginx1yum install -y nginx 启动Nginx1systemctl start nginx.service 设置开机自动运行1systemctl enable nginx.service 关闭防火墙关闭 1systemctl stop firewalld 查看状态 1systemctl status firewalld 测试浏览器地址栏输入虚拟机IP，看到 Welcome to nginx! 就说明安装成功 卸载nginx1yum remove nginx PS.CentOS7关闭Nginx命令，nginx.service可简写成nginx 1systemctl stop nginx.service CentOS7启动Nginx命令 1systemctl start nginx.service CentOS7重启Nginx命令 1systemctl restart nginx.service","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx实现虚拟主机","slug":"322","date":"2021-08-29T16:02:51.000Z","updated":"2022-04-14T02:38:24.528Z","comments":true,"path":"322.html","link":"","permalink":"https://blog.zoutl.cn/322.html","excerpt":"","text":"简介虚拟主机概念比较广，可以是虚拟硬件来实现多网站，多应用运行，也可以是通过一些代理服务器来实现单机多网站运行，例如：我们一个服务器上可以部署三个网站，然后通过三个不同的域名访问 Nginx可以通过反向代理来实现虚拟主机 实现过程查看博客：Nginx 实现反向代理 | LeDao 的博客 (zoutl.cn)","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx实现动静分离","slug":"321","date":"2021-08-29T15:15:00.000Z","updated":"2022-04-14T02:38:48.776Z","comments":true,"path":"321.html","link":"","permalink":"https://blog.zoutl.cn/321.html","excerpt":"","text":"简介动静分离是指在web服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务访问性能和可维护性 我们可以把静态html页面，css样式，js文件，以及图片文件这些静态放Nginx服务器中，然后把动态请求显示的文件放类似Tomcat这样的容器服务器 这样方便维护，也可以提高系统性能 前提云服务器安装好Nginx，拥有自己的域名（解析一个二级域名来用于访问静态资源） 实现过程新建静态资源在/home/nginx目录下放静态资源 index.html，放在/home/nginx目录下 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://static.zoutl.cn/static/css/my.css&quot;&gt; &lt;script src=&quot;http://static.zoutl.cn/static/js/my.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Nginx静态资源服务器测试&lt;/h1&gt;&lt;img src=&quot;http://static.zoutl.cn/static/img/2.jpg&quot; style=&quot;width: 666px&quot; alt=&quot;&quot;&gt;&lt;/body&gt;&lt;/html&gt; my.css，放在/home/nginx/static/css目录下 123h1&#123; color:red;&#125; my.js，放在/home/nginx/static/js目录下 1alert(&quot;123456&quot;); 修改配置文件修改Nginx的default.conf配置文件，修改成自己的域名和资源根目录 结果浏览器地址栏输入：http://static.zoutl.cn/，结果如下：","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx负载均衡backup和down配置","slug":"320","date":"2021-08-26T19:17:39.000Z","updated":"2022-04-14T02:38:45.817Z","comments":true,"path":"320.html","link":"","permalink":"https://blog.zoutl.cn/320.html","excerpt":"","text":"概述这两个配置很多时候用于运维，维护某个机器的时候用 backup其他非backup机器挂掉后，才会请求backup机器 实例： 1234upstream www.123.com&#123; server 172.17.0.2:8080; server 172.17.0.3:9090 backup;&#125; down配置down的服务器不参与负载均衡， 1234upstream www.123.com&#123; server 172.17.0.2:8080; server 172.17.0.3:9090 down;&#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx负载均衡策略","slug":"319","date":"2021-08-26T19:11:58.000Z","updated":"2022-04-14T02:38:51.394Z","comments":true,"path":"319.html","link":"","permalink":"https://blog.zoutl.cn/319.html","excerpt":"","text":"概述Nginx负载均衡策略有：轮询（默认）、weight权重、ip_hash、least_conn最少连接 轮询（默认）每个请求轮流分配到不同的后端服务器，如果后端服务器挂掉，则自动被剔除 实例： 1234upstream www.123.com&#123; server 172.17.0.2:8080; server 172.17.0.3:9090;&#125; weight权重根据weight权重，请求会根据权重比例分发给不同后端服务器，weight权重越高，分配的比例越大；实际分配时，根据服务器硬件配置高低，来具体分配weight权重，硬件配置高的，weight就配置高点 实例： 1234upstream www.123.com&#123; server 172.17.0.2:8080 weight=5; server 172.17.0.3:9090 weight=10;&#125; ip_haship_hash策略是根据用户客户端的IP的hash值来分配具体服务器，这样每个访问客户端都会固定访问某一个服务器，这样可以解决session丢失问题，很多网站都采用这种策略来搞负载均衡，主要考虑到session问题 实例： 12345upstream www.123.com&#123; ip_hash; server 172.17.0.2:8080; server 172.17.0.3:9090;&#125; least_connweb请求会被分发到连接数最少的服务器上 实例： 12345upstream www.123.com&#123; least_conn; server 172.17.0.2:8080; server 172.17.0.3:9090;&#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx实现负载均衡","slug":"318","date":"2021-08-26T17:59:31.000Z","updated":"2022-04-14T02:38:53.561Z","comments":true,"path":"318.html","link":"","permalink":"https://blog.zoutl.cn/318.html","excerpt":"","text":"前提在云服务器上运行好两个及以上相同的项目，并且都可以通过IP地址:端口号访问，拥有自己的域名 实现过程在实现反向代理的博客基础上修改upstream（有多少个项目就有多少个server），博客链接为：Nginx 实现反向代理 1234upstream test &#123; server 121.222.34.112:8080; server 121.211.34.112:8080;&#125; 结果通过域名可以访问，即使有一个项目掉线了也可以正常访问","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Nginx实现反向代理","slug":"317","date":"2021-08-26T15:00:29.000Z","updated":"2022-04-14T02:38:21.546Z","comments":true,"path":"317.html","link":"","permalink":"https://blog.zoutl.cn/317.html","excerpt":"","text":"前提在云服务器上运行好项目，并且可以通过IP地址:端口号访问，拥有自己的域名 实现过程添加代码打开/etc/nginx/conf.d目录下的default.conf配置文件，在最下面添加以下代码，upstream和server成对出现 123456789101112131415161718192021222324252627upstream test &#123; server 121.222.34.112:8080;&#125;server &#123; listen 80; #域名 server_name test.ztlztl.cn; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm; proxy_pass http://test; proxy_connect_timeout 30; #连接超时 默认为60秒 proxy_read_timeout 30; #读取超时 默认为60秒 proxy_send_timeout 30; #发送超时 默认为60秒 access_log off; break; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 代码解析upstream test的test填项目的名称即可，server接项目的IP地址以及端口号，server_name后面是域名，proxy_pass后面是之前的项目名称 结果可以通过test.ztlztl.cn域名访问项目","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"Docker安装Nginx","slug":"316","date":"2021-08-26T13:14:31.000Z","updated":"2022-04-14T02:39:56.834Z","comments":true,"path":"316.html","link":"","permalink":"https://blog.zoutl.cn/316.html","excerpt":"","text":"拉取镜像1docker pull nginx 创建并运行容器1docker run -d --name=自定义名称 -v /home/data/nginx:/etc/nginx -p 80:80 nginx镜像id 进入容器1docker exec -it nginx容器id bash 测试浏览器地址栏输入虚拟机IP，看到Welcome to nginx!说明安装成功","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"}]},{"title":"form表单无法提交input disabled内容","slug":"315","date":"2021-08-24T01:06:16.000Z","updated":"2022-03-26T15:59:22.687Z","comments":true,"path":"315.html","link":"","permalink":"https://blog.zoutl.cn/315.html","excerpt":"","text":"问题描述使用了disable属性让文本框无法编辑，但是提交form表单时无法获取该文本框的值，代码如下： 123456&lt;form action=&quot;/student/update&quot; method=&quot;post&quot; style=&quot;text-align: center;margin-top: 10%&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;$&#123;student.id&#125;&quot; name=&quot;id&quot; placeholder=&quot;编号&quot; required=&quot;required&quot; disabled=&quot;disabled&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;$&#123;student.name&#125;&quot; name=&quot;name&quot; placeholder=&quot;姓名&quot; required=&quot;required&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;$&#123;student.age&#125;&quot; name=&quot;age&quot; placeholder=&quot;年龄&quot; required=&quot;required&quot;&gt; &lt;button type=&quot;submit&quot;&gt;修改&lt;/button&gt;&lt;/form&gt; 解决办法disabled=”disabled”修改为readonly=”readonly”即可 readonly和disabled的区别readonly：针对input(text / password)和textarea有效，在设置为true的情况下，用户可以获得焦点，但是不能编辑，在提交表单时，输入项会作为form的内容提交 disabled：针对所有表单元素（select，button，input，textarea等），在设置为disabled为true的情况下，表单输入项不能获得焦点，用户的所有操作无意义，在提交表单时，表单输入项不会被提交","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Windows10释放被占用端口","slug":"314","date":"2021-08-23T20:17:09.000Z","updated":"2022-04-14T02:01:49.929Z","comments":true,"path":"314.html","link":"","permalink":"https://blog.zoutl.cn/314.html","excerpt":"","text":"查看PID打开CMD，输入命令查看端口4000的PID 1netstat -aon|findstr &quot;4000&quot; 看下图的0.0.0.0:4000，LISTENING后的数值：16388就是PID 释放端口CMD方式释放输入以下命令，PID为上图LISTENING后的数值 1taskkill /T /F /PID 16388 任务管理器释放查看指定 PID 的进程（也可以不看，记住PID即可） 1tasklist|findstr &quot;16388&quot; 打开任务管理，选择详细信息选项，根据进程名称或者PID找到进程 右键点击并选择结束任务","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"IntelliJ IDEA创建Spring项目","slug":"313","date":"2021-08-23T18:04:17.000Z","updated":"2022-04-14T02:43:44.471Z","comments":true,"path":"313.html","link":"","permalink":"https://blog.zoutl.cn/313.html","excerpt":"","text":"创建Maven项目查看博客：idea创建Maven项目 引入依赖12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 测试配置文件命名为：applicationContext.xml，完整代码如下： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;student1&quot; class=&quot;com.ledao.entity.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;11&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 学生实体类命名为：Student.java 12345678910111213141516171819202122232425package com.ledao.entity;import lombok.Data;/** * @author LeDao * @company * @create 2021-08-24 1:58 */@Datapublic class Student &#123; /** * 编号 */ private Integer id; /** * 姓名 */ private String name; /** * 年龄 */ private Integer age;&#125; 测试类命名为：Test.java 12345678910111213141516171819package com.ledao;import com.ledao.entity.Student;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * @author LeDao * @company * @create 2021-08-24 1:57 */public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Student student = (Student) context.getBean(&quot;student1&quot;); System.out.println(student.getId()+&quot;,&quot;+student.getName()+&quot;,&quot;+ student.getAge()); &#125;&#125; 结果运行测试类的main方法，结果如下：","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"}]},{"title":"Docker私有仓库删除镜像","slug":"312","date":"2021-08-22T20:04:05.000Z","updated":"2022-04-14T02:39:39.806Z","comments":true,"path":"312.html","link":"","permalink":"https://blog.zoutl.cn/312.html","excerpt":"","text":"问题描述对于私有仓库的镜像，Docker是没有命令对其进行删除的 解决办法进入私有仓库的容器内，找到镜像文件，然后手动删除即可 删除过程进入容器先运行对应私有仓库的容器，然后进入容器 1docker exec -it 私有仓库容器id sh 修改配置文件该配置文件在 /etc/docker/registry 目录下，名称为：config.yml ，在storage节点添加以下代码： 12delete: enabled: true 完整config.yml代码如下： 1234567891011121314151617181920version: 0.1log: fields: service: registrystorage: cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registry delete: enabled: truehttp: addr: :5000 headers: X-Content-Type-Options: [nosniff]health: storagedriver: enabled: true interval: 10s threshold: 3 找到镜像文件1find / -name &quot;*要删除镜像名称*&quot; 删除进入上一步找到的镜像文件的路径，然后开始删除，该镜像文件是文件夹所以删除时追加参数-r 1rm -r 镜像名称 同步配置文件1registry garbage-collect /etc/docker/registry/config.yml 查看结果浏览器地址栏输入：http://虚拟机id:5000/v2/_catalog，可以看到对应的镜像已经没了","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker搭建私有仓库","slug":"311","date":"2021-08-22T18:33:53.000Z","updated":"2022-04-14T02:39:58.413Z","comments":true,"path":"311.html","link":"","permalink":"https://blog.zoutl.cn/311.html","excerpt":"","text":"介绍Docker私有仓库程序本身就是一个镜像，主要是企业内部用来存放镜像的仓库，相对官方仓库以及阿里云仓库，具有更高的保密安全级别 搭建过程拉取私有仓库镜像1docker pull registry 创建并启动容器1docker run -di --name=myRegistry -p 5000:5000 registry 测试浏览器地址栏输入：http://虚拟机id:5000/v2/_catalog，看到下图说明搭建成功 修改daemon.json该文件在 /etc/docker 目录下，添加以下代码让Docker信任私有仓库 1&quot;insecure-registries&quot;: [&quot;虚拟机id:5000&quot;] 重启Docker1systemctl restart docker 测试上传镜像标记要上传到私有仓库的镜像为私有仓库的镜像（标记只是引用，镜像id还是被标记的镜像的id） 1docker tag 镜像id 虚拟机id:5000/自定义名称 推送镜像到私有仓库，推送前先启动私有仓库的容器 1docker push 上图划红线的镜像名称 查看结果 浏览器地址栏输入：http://虚拟机id:5000/v2/_catalog，从下图可以看到镜像上传成功 拉取镜像先删除刚刚上传的本地镜像，然后再从私有仓库拉取镜像 1docker pull 虚拟机id:5000/上图的镜像名称","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"DockerFile的ONBUILD指令","slug":"310","date":"2021-08-22T17:05:56.000Z","updated":"2022-04-14T02:39:37.154Z","comments":true,"path":"310.html","link":"","permalink":"https://blog.zoutl.cn/310.html","excerpt":"","text":"简介父镜像在被子镜像继承后父镜像的ONBUILD被触发，可以把ONBUID理解为一个触发器。编写Dockerfile的时候，其他命令都是为了自身镜像服务的，只有ONBUILD是为了子镜像服务 使用构建父镜像编写父镜像DockerFile，命名为：parent_df，内容如下： 12345FROM centosONBUILD RUN yum -y install vimCMD /bin/bash 构建父镜像 1docker build -f parent_df -t parent . 构建子镜像编写子镜像DockerFile，命名为：son_df，内容如下： 1FROM parent 构建子镜像 1 docker build -f son_df -t son . 结果当构建子镜像的时候，父镜像的ONBUILD会触发，子镜像直接安装vim，父镜像是没有安装vim的。所以使用父镜像创建的容器使用vim命令会报错，而用子镜像创建的容器可以使用vim命令","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"}]},{"title":"DockerFile的CMD, ENTRYPOINT指令","slug":"309","date":"2021-08-22T15:33:20.000Z","updated":"2022-04-14T02:40:01.992Z","comments":true,"path":"309.html","link":"","permalink":"https://blog.zoutl.cn/309.html","excerpt":"","text":"简介CMD，ENTRYPOINT都是容器启动的时候，执行执行命令，都支持exec和shell方式 一般用法有两种：①单独一个CMD②先使用ENTRYPOINT（用于执行命令），然后结合CMD使用（用于追加参数） 有多个CMD时，只有最后一个CMD生效 语法一般开发和Docker官方都建议用 exec格式 CMD第一种用法：运行一个可执行的文件并提供参数 1CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 第二种用法：为ENTRYPOINT指定参数 1CMD [&quot;param1&quot;,&quot;param2&quot;] 第三种用法(shell格式)：是以”/bin/sh -c”的方法执行的命令 1CMD command param1 param2 ENTRYPOINT exec 格式, 推荐 1ENTRYPOINT [“executable”, “param1”, “param2”] shell 格式 1ENTRYPOINT command param1 param2 使用单个CMD编写DockerFile，命名为df1，内容如下： 123FROM centosCMD echo &quot;第一个CMD&quot; 构建镜像 1docker build -f df1 -t a6678696/df:1.1 . 创建和运行该镜像的容器 1docker run 镜像id 结果如下图 多个CMD编写DockerFile，命名为df2，内容如下： 1234FROM centosCMD echo &quot;第一个CMD&quot;CMD echo &quot;第二个CMD&quot; 构建镜像 1docker build -f df2 -t a6678696/df:1.2 . 创建和运行该镜像的容器 1docker run 镜像id 结果如下图，第一个CMD命令没有生效，生效的是最后一个CMD 先ENTRYPOINT后CMD编写DockerFile，命名为df3，内容如下： 12345FROM centosENTRYPOINT [&quot;ls&quot;]CMD [&quot;-l&quot;] 构建镜像 1docker build -f df3 -t a6678696/df:1.3 . 创建和运行该镜像的容器 1docker run 镜像id 结果如下图，以ls -l格式查看文件","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"}]},{"title":"DockerFile通过VOLUME指令创建容器卷来实现容器的目录挂载","slug":"308","date":"2021-08-21T19:46:11.000Z","updated":"2022-04-14T02:39:32.719Z","comments":true,"path":"308.html","link":"","permalink":"https://blog.zoutl.cn/308.html","excerpt":"","text":"介绍DockerFile创建镜像时通过VOLUME指令创建几个容器卷，然后创建这个镜像的容器时，这个容器就有了这几个容器卷目录，并与宿主机自动创建的对应目录实现了挂载 实现过程语法1VOLUME[&#x27;目录1&#x27;,&#x27;目录2&#x27;] 编写DockerFile新建一个文件，命名为：myVolumeDockerFile，没有后缀名，内容如下： 12345FROM centosVOLUME [&quot;/home/v1&quot;,&quot;/home/v2&quot;]CMD /bin/bash 构建镜像1docker build -f myVolumeDockerFile -t a6678696/mycentos:1.2 . 创建容器1docker run -it 9123279cfb4f 找到挂载的目录①找到容器挂载的容器卷v1，v2 ②找到宿主机挂载的容器卷 通过inspect命令获取容器的元数据 1docker inspect 容器id 找到Mounts节点，Source为宿主机的目录，Destination为容器的目录，两个目录是挂载的 PS.docker run -v 命令创建挂载目录更好，可以自定义宿主机目录","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"}]},{"title":"DockerFile创建镜像时报错：file not found in build context or excluded by","slug":"307","date":"2021-08-21T17:25:02.000Z","updated":"2022-04-14T02:40:05.288Z","comments":true,"path":"307.html","link":"","permalink":"https://blog.zoutl.cn/307.html","excerpt":"","text":"问题描述DockerFile创建镜像时使用COPY和ADD指令时，检测到源文件不存在就会报错 解决办法DockerFile文件和源文件放在同一目录下，并且先进入这个目录再执行创建镜像命令 例如我的DockerFile文件和源文件都在/home/dockerfile目录中（如下图所示），那么我就要进入/home/dockerfile目录，然后执行DockerFile创建镜像的命令","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"}]},{"title":"DockerFile构建自定义Tomcat","slug":"306","date":"2021-08-21T16:45:16.000Z","updated":"2022-04-14T02:39:29.682Z","comments":true,"path":"306.html","link":"","permalink":"https://blog.zoutl.cn/306.html","excerpt":"","text":"编写DockerFile新建一个文件，命名为：mytomcatdockerfile，没有后缀名，内容如下： 12345678910111213141516171819202122FROM centosMAINTAINER LeDao&lt;f1203007469@gmail.com&gt; LABEL name=&quot;LeDao Tomcat Image&quot; \\ build-date=&quot;2021-08-22 00:16:53&quot; COPY copyright.txt /home/copyright.txtADD server-jre-8u151-linux-x64.tar.gz /home/ADD apache-tomcat-8.5.37.tar.gz /home/ ENV WORKPATH /home/apache-tomcat-8.5.37/WORKDIR $WORKPATH ENV JAVA_HOME /home/jdk1.8.0_151ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINA_HOME /home/apache-tomcat-8.5.37/ENV CATALINA_BASE /home/apache-tomcat-8.5.37/ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin EXPOSE 8080CMD [&quot;/home/apache-tomcat-8.5.37/bin/catalina.sh&quot;,&quot;run&quot;] 复制文件创建/home/dockerfile目录，把mytomcatdockerfile、copyright.txt、server-jre-8u151-linux-x64.tar.gz、apache-tomcat-8.5.37.tar.gz复制到该目录下，并进入该目录 四个文件的百度网盘链接： 链接：https://pan.baidu.com/s/1ldCQGNay95IvVlOzeMQdXg 提取码：62h2 创建镜像命令的最后面有个英文句号.（少了句号不行） 1docker build -f mytomcatdockerfile -t a6678696/mytomcat:1.2 . 查看镜像构造历史","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"}]},{"title":"DockerFile构建自定义CentOS","slug":"305","date":"2021-08-21T15:06:20.000Z","updated":"2022-04-14T02:40:07.730Z","comments":true,"path":"305.html","link":"","permalink":"https://blog.zoutl.cn/305.html","excerpt":"","text":"编写DockerFile新建一个文件，命名为：mycentosDockerFile，没有后缀名，内容如下： 1234567891011121314FROM centosMAINTAINER ledao&lt;f1203007469@gmail.com&gt;LABEL name=&quot;LeDao CentOS Image&quot; \\ build-date=&quot;2021-08-21&quot;ENV WORKPATH /home/WORKDIR $WORKPATHRUN yum -y install net-toolsRUN yum -y install vimEXPOSE 80CMD /bin/bash 创建镜像命令的最后面有个英文句号.（少了句号不行） 1docker build -f /home/dockerfile/mycentosDockerFile -t a6678696/mycentos:1.1 . 查看镜像构建历史1docker history 镜像id","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"}]},{"title":"DockerFile常用指令","slug":"304","date":"2021-08-21T13:38:01.000Z","updated":"2022-04-14T02:39:26.452Z","comments":true,"path":"304.html","link":"","permalink":"https://blog.zoutl.cn/304.html","excerpt":"","text":"DockerFile简介dockerfile用于快速有序且直观地完成对镜像的定制 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建 指令FROMFROM指令是整个Dockerfile的入口，必须是第一条指令。其代表新制作镜像的基础镜像。基础镜像可以自己制作，也可以从开源的仓库pull，例如dockerhub或是国内阿里云的免费仓库。 Docker中存在一种特殊的情况，就是不以任何基础镜像为基准，此时可以第一句话使用： 1FROM scratch 来表示以空白镜像为基础，也就是直接将可执行文件复制进镜像。例如swarm、coreos/etcd等。 RUN指令是dockerfile中最常用的指令之一。用来执行命令行上的命令。RUN的格式分为两种： 第一种：shell格式：RUN&lt;命令&gt;，类似于直接在终端输入命令。例如： 1RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/tomcat/welcome.html 第二种：exec格式：RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]。RUN既然可以像在命令行那样工作，那么就也可以实现传参来运行指令： 123456789FROM ubuntu:14.04RUN apt-get updateRUN apt-get install -y gcc libc6-dev makeRUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install RUN一次就代表Dockerfile中的一层。而docker镜像的构建就是不断去完善每一层需要做的事情。而dockerfi对一个file中层数是有限制的，最大不超过127层。因此，RUN提供命令的串联功能，也就是允许每一层可包含多种操作，他们会按照书写顺序来依次执行。那么上面的例子可以变为： 12345678910111213FROM ubuntu:14.04RUN buildDeps=&#x27;gcc libc6-dev make&#x27; \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y $buildDeps \\ &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot; \\ &amp;&amp; mkdir -p /usr/src/redis \\ &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ &amp;&amp; make -C /usr/src/redis \\ &amp;&amp; make -C /usr/src/redis install \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm redis.tar.gz \\ &amp;&amp; rm -r /usr/src/redis \\ &amp;&amp; apt-get purge -y --auto-remove $buildDeps 换行用 \\ ，注释用 # ，平时书写注意缩进来保证文件的可读性。上述例子中的最后一句还进行了无关文件的清理，进一步保证每一层的最优和最小 注意事项：镜像的初衷是进行功能的模块化，也是尽可能让每个容器干最少的事情，那么我们在书写dockerfile的时候要注意这个问题，每一层的东西确保是必须的，否则就不要进行安装或是拷贝。 MAINTAINER指定作者句法： 1MAINTAINER &lt;name&gt; LABEL该指令是为镜像添加标签句法： 1LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ... 一个Dockerfile种可以有多个LABEL，如下： 123LABEL multi.label1=&quot;value1&quot; \\multi.label2=&quot;value2&quot; \\other=&quot;value3&quot; 说明：LABEL会继承基础镜像种的LABEL，如遇到key相同，则值覆盖 COPY指令该指令用于将宿主机文件拷贝至镜像内的指定路径格式： 123COPY &lt;源路径&gt;... &lt;目标路径&gt;或COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;] 也就是说，原路径可以有多个，而目标路径唯一注意事项： 1、可以使用符合GO规范的通配符，例如：COPY hom* /mydir/2、目的路径可以是镜像内的绝对路径，也可以是相对于当前工作目录的相对路径3、COPY过来的文件权限与原始权限相同。如需更改，请用传统Liunx的chmod命令进行修改即可 ADD高级复制ADD的本质作用类似于COPY，但是其更复杂： 1、ADD过来的压缩包可以自动在目标路径下进行解压2、原始路径可以是一个连接，ADD过程会尝试从该链接下载所需的文件到目的路径3、一般情况下，建议使用COPY而不是ADD，因为COPY过来的文件可以配合使用RUN来进行解压或是其他操作，搭配使用更灵活，且单条语句所负担的功能唯一 WORKDIR该指令用于指定Dockerfile中该指令下面的操作所在的工作目录类似于 cd 命令 CMD 服务启动指令Docker不是虚拟机而是一个进程，作为进程，当然可以制定启动镜像时的具体参数。说白了就是制定一些你想自动启动的服务格式： 123shell 格式：CMD &lt;命令&gt;exec 格式：CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]参数列表格式：CMD [&quot;参数1&quot;, &quot;参数2&quot;...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 注意事项： 1、CMD中的启动参数可以被更新覆盖。例如：Dockerfile中若是用CMD指定启动镜像时执行/bin/bash，那么在启动镜像时输入docker run -it ubuntu ./test.sh 则会用./test.sh命令来覆盖/bin/bash命令2、推荐使用exec格式的CMD书写。这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号3、如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：CMD echo /java在实际执行中，会将其变更为：CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo /java&quot; ] ENV设置环境变量说是环境变量还不说是一个全局变量。在前面定义，后面可以通过 $ 取值进行使用格式： 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;... 例如可以指定一些包的版本号，这样更新镜像很方便，或是保存一些密码（该功能慎用，自己玩还是可以的） ARG 构建参数语法形式: ARG &lt;name&gt;[=&lt;default value&gt;]ARG和ENV效果类似，都是用来设置观景变量的。唯一 不同的是dockerfile中的ARG编译好后是不会出现在打开的容器内的 ARG在dockerfile中创建一个全局参数，参数可以给定一个默认值，在编译时可以传参对其进行覆盖。如果ARG指令有默认值并且在构建期间没有接收到参数、则使用默认值。一个dockerfile中可以包含多个ARG参数 1docker build --build-arg &lt;varname&gt;=&lt;value&gt; 可以使用ARG或ENV指令来指定RUN指令可用的变量，如果ARG和ENV同时指定了一个相同名称的变量、则ENV设置的变量会覆盖ARG设置的变量。如下: 12341 FROM ubuntu2 ARG CONT_IMG_VER3 ENV CONT_IMG_VER v1.0.04 RUN echo $CONT_IMG_VER 使用 docker build --build-arg CONT_IMG_VER=v2.0.1 . 最终输出v1.0.0 一个ARG指令的有效范围在其定义的构建阶段内、如果要在多个阶段中都有效、则必须在每个阶段都使用ARG指令；与ARG不同 ENV设置参数的有效期为整个构建期内 VOLUME 挂在共享卷格式为： 12VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]VOLUME &lt;路径&gt; Docker的使用原则除了每个容器干尽量少的事情外，还尽可能要求容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，也就是将本地磁盘的某一个目录挂载至容器内。同时这样的共享目录可以被多个不同的容器所使用 除了可以在dockerfile中指定这一参数外，在运行启动容器时也可以附带这一参数来指定共享卷： 1docker run -it --name container-test -h CONTAINER -v /data debian /bin/bash 上述命令也可以覆盖dockerfile中的目录设定。 USER指定用户在书写dockerfile时，某些层的操作若想切换用户名，可以使用该参数指定某些层的用户，并且是存在的用户名。 格式：USER &lt;用户名&gt; 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu 12345678# 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \\ &amp;&amp; chmod +x /usr/local/bin/gosu \\ &amp;&amp; gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ] EXPOSE暴漏端口句法： 1EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...] EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射 PS.来源：https://www.jianshu.com/p/2a90fc6ee383","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"}]},{"title":"Docker备份和恢复镜像","slug":"303","date":"2021-08-21T13:01:27.000Z","updated":"2022-04-14T02:40:10.781Z","comments":true,"path":"303.html","link":"","permalink":"https://blog.zoutl.cn/303.html","excerpt":"","text":"备份镜像1docker save -o 备份镜像的名称 源镜像名称:tag版本 恢复镜像1docker load -i 镜像文件","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker安装和配置MySQL容器","slug":"302","date":"2021-08-21T02:38:08.000Z","updated":"2022-04-14T02:39:23.978Z","comments":true,"path":"302.html","link":"","permalink":"https://blog.zoutl.cn/302.html","excerpt":"","text":"创建MySQL容器创建的这个容器只是用来获取文件路径 1docker run --name 自定义名称 -di -p 3305:3306 -e MYSQL_ROOT_PASSWORD=123456 MySQL镜像id 获取文件路径进入容器的文件夹中 1docker exec -it 容器id /bin/bash 获取conf.d、log、mysql的文件路径，分别如下： 123/etc/mysql/conf.d/var/log/var/lib/mysql 复制文件到宿主机在宿主机的 home 目录下新建 mysql 目录 1mkdir /home/mysql 复制容器里的 /etc/mysql/conf.d、/var/log、/var/lib/mysql到宿主机/home/mysql 复制/etc/mysql/conf.d 1docker cp 容器id:/etc/mysql/conf.d /home/mysql/ 复制/var/log 1docker cp 容器id:/var/log /home/mysql/ 复制/var/lib/mysql 1docker cp 容器id:/var/lib/mysql /home/mysql/ 创建新的MySQL容器创建时挂载 /etc/mysql/conf.d、/var/log、/var/lib/mysql 1docker run -di --name 自定义名称 -p 3303:3306 -v /etc/mysql/conf.d:/home/mysql/conf -v /var/log:/home/mysql/log -v /var/lib/mysql:/home/mysql/mysql -e MYSQL_ROOT_PASSWORD=123456 MySQL镜像id 重启新的MySQL容器 1docker restart 容器id SQLyog连接数据库连接数据库，主机地址填虚拟机IP，端口和密码填创建容器时设置的，用户名是root 执行sql脚本导入数据 然后就可以操作mysql容器的数据库了，Java项目连接数据库的基本信息也是填上面的","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker安装和配置Tomcat容器并部署Java项目","slug":"301","date":"2021-08-21T01:31:21.000Z","updated":"2022-04-14T02:40:13.743Z","comments":true,"path":"301.html","link":"","permalink":"https://blog.zoutl.cn/301.html","excerpt":"","text":"创建Tomcat容器创建的这个容器只是用来获取文件路径 1docker run --name 自定义名称 -di -p 8080:8080 Tomcat镜像id 获取文件路径进入容器的文件夹中 1docker exec -it Tomcat容器id /bin/bash 获取三个文件夹conf、webapps、logs的文件路径 复制文件到宿主机在宿主机的 home 目录下新建 tomcat 目录 1mkdir /home/tomcat 复制容器里的 /usr/local/tomcat/conf、/usr/local/tomcat/webapps 到宿主机/home/tomcat/ 复制 /usr/local/tomcat/conf 1docker cp 容器id:/usr/local/tomcat/conf /home/tomcat/ 复制 /usr/local/tomcat/webapps 1docker cp 容器id:/usr/local/tomcat/webapps /home/tomcat/ 创建新的Tomcat容器这个容器是用来部署Java项目的，创建时挂载 /home/tomcat/conf、/home/tomcat/webapps、home/tomcat/logs 创建容器并挂载目录 1docker run --name 自定义名称 -di -p 80:8080 -v /home/tomcat/conf:/usr/local/tomcat/conf -v /home/tomcat/webapps:/usr/local/tomcat/webapps -v /home/tomcat/logs:/usr/local/tomcat/logs Tomcat镜像id 上传Java项目上传到 /home/tomcat/webapps 目录下，我上传的文件名为：WebTest.war，Docker 的 Tomcat 是热部署的所以会自动部署Java项目，过了一会儿就可以访问这个项目了，访问路径为：http://虚拟机的ip/WebTest 修改配置文件修改宿主机的 /home/tomcat/conf 目录下的 server.xml，添加以下代码： 1&lt;Context path=&quot;&quot; docBase=&quot;/usr/local/tomcat/webapps/WebTest&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; /&gt; 添加位置如下图： 重启新创建的Tomcat容器，即部署Java项目的容器 1docker restart 容器id 然后访问项目可以不加项目名了，访问路径为：http://虚拟机的ip","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker修改已创建容器的挂载目录","slug":"300","date":"2021-08-20T18:31:21.000Z","updated":"2022-04-14T02:39:21.415Z","comments":true,"path":"300.html","link":"","permalink":"https://blog.zoutl.cn/300.html","excerpt":"","text":"问题描述一般来说，都是创建容器时进行目录挂载，对于已经创建好的容器如果忘了挂载目录但是又想挂载目录 解决办法 提交这个容器为新的镜像，然后创建这个新镜像的容器同时进行目录挂载（此方式较简单） 修改这个容器的配置文件 实现过程提交新镜像再创建容器查看下面两篇博客即可实现修改已创建容器的挂载目录 Docker提交运行时容器为镜像 ，将要挂载目录的已创建容器提交为本地新镜像 Docker创建容器时目录挂载 ，创建容器时使用新镜像的镜像id顺便挂载目录 修改配置文件停止Docker 1systemctl stop docker 配置文件路径 /var/lib/docker/containers/[容器id] 修改配置文件hostconfig.json，在”Binds”节点中增加挂载目录的关系，前面的/home/hData/是宿主机目录，后面的/cData是容器目录，如果是多个用英文逗号隔开 单个目录例子： 1&quot;Binds&quot;:[&quot;/home/hData/:/cData&quot;] 多个目录例子： 1&quot;Binds&quot;:[&quot;/home/hData:/cData&quot;,&quot;/home/hData2:/cData2&quot;] 修改配置文件config.v2.json，在”MountPoints” 节点中增加挂载目录 单个目录例子：（第一段代码是原始的，第二段代码是格式化过的，格式化后更好修改） 1&quot;MountPoints&quot;:&#123;&quot;/cData&quot;:&#123;&quot;Source&quot;:&quot;/home/hData&quot;,&quot;Destination&quot;:&quot;/cData&quot;,&quot;RW&quot;:true,&quot;Name&quot;:&quot;&quot;,&quot;Driver&quot;:&quot;&quot;,&quot;Type&quot;:&quot;bind&quot;,&quot;Propagation&quot;:&quot;rprivate&quot;,&quot;Spec&quot;:&#123;&quot;Type&quot;:&quot;bind&quot;,&quot;Source&quot;:&quot;/home/hData/&quot;,&quot;Target&quot;:&quot;/cData&quot;&#125;,&quot;SkipMountpointCreation&quot;:false&#125;&#125; 1234567891011121314151617&quot;MountPoints&quot;: &#123; &quot;/cData&quot;: &#123; &quot;Source&quot;: &quot;/home/hData&quot;, &quot;Destination&quot;: &quot;/cData&quot;, &quot;RW&quot;: true, &quot;Name&quot;: &quot;&quot;, &quot;Driver&quot;: &quot;&quot;, &quot;Type&quot;: &quot;bind&quot;, &quot;Propagation&quot;: &quot;rprivate&quot;, &quot;Spec&quot;: &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/hData/&quot;, &quot;Target&quot;: &quot;/cData&quot; &#125;, &quot;SkipMountpointCreation&quot;: false &#125;&#125; 多个目录例子：（第一段代码是原始的，第二段代码是格式化过的，格式化后更好修改） 1&quot;MountPoints&quot;:&#123;&quot;/cData&quot;:&#123;&quot;Source&quot;:&quot;/home/hData&quot;,&quot;Destination&quot;:&quot;/cData&quot;,&quot;RW&quot;:true,&quot;Name&quot;:&quot;&quot;,&quot;Driver&quot;:&quot;&quot;,&quot;Type&quot;:&quot;bind&quot;,&quot;Propagation&quot;:&quot;rprivate&quot;,&quot;Spec&quot;:&#123;&quot;Type&quot;:&quot;bind&quot;,&quot;Source&quot;:&quot;/home/hData&quot;,&quot;Target&quot;:&quot;/cData&quot;&#125;,&quot;SkipMountpointCreation&quot;:false&#125;,&quot;/cData2&quot;:&#123;&quot;Source&quot;:&quot;/home/hData2&quot;,&quot;Destination&quot;:&quot;/cData2&quot;,&quot;RW&quot;:true,&quot;Name&quot;:&quot;&quot;,&quot;Driver&quot;:&quot;&quot;,&quot;Type&quot;:&quot;bind&quot;,&quot;Propagation&quot;:&quot;rprivate&quot;,&quot;Spec&quot;:&#123;&quot;Type&quot;:&quot;bind&quot;,&quot;Source&quot;:&quot;/home/hData2&quot;,&quot;Target&quot;:&quot;/cData2&quot;&#125;,&quot;SkipMountpointCreation&quot;:false&#125;&#125; 1234567891011121314151617181920212223242526272829303132&quot;MountPoints&quot;: &#123; &quot;/cData&quot;: &#123; &quot;Source&quot;: &quot;/home/hData&quot;, &quot;Destination&quot;: &quot;/cData&quot;, &quot;RW&quot;: true, &quot;Name&quot;: &quot;&quot;, &quot;Driver&quot;: &quot;&quot;, &quot;Type&quot;: &quot;bind&quot;, &quot;Propagation&quot;: &quot;rprivate&quot;, &quot;Spec&quot;: &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/hData&quot;, &quot;Target&quot;: &quot;/cData&quot; &#125;, &quot;SkipMountpointCreation&quot;: false &#125;, &quot;/cData2&quot;: &#123; &quot;Source&quot;: &quot;/home/hData2&quot;, &quot;Destination&quot;: &quot;/cData2&quot;, &quot;RW&quot;: true, &quot;Name&quot;: &quot;&quot;, &quot;Driver&quot;: &quot;&quot;, &quot;Type&quot;: &quot;bind&quot;, &quot;Propagation&quot;: &quot;rprivate&quot;, &quot;Spec&quot;: &#123; &quot;Type&quot;: &quot;bind&quot;, &quot;Source&quot;: &quot;/home/hData2&quot;, &quot;Target&quot;: &quot;/cData2&quot; &#125;, &quot;SkipMountpointCreation&quot;: false &#125;&#125; 启动Docker 1systemctl start docker 启动刚刚修改的容器 1docker start 容器id","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker创建容器时目录挂载","slug":"299","date":"2021-08-20T17:21:08.000Z","updated":"2022-04-14T02:39:19.601Z","comments":true,"path":"299.html","link":"","permalink":"https://blog.zoutl.cn/299.html","excerpt":"","text":"简介在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以实现宿主机和容器目录的双向自动同步 作用Docker可以使用cp命令来实现数据传递，这种方式非常麻烦，通过容器目录挂载，能够轻松实现代码上传，配置修改，日志同步等需求 命令单个目录拥有全部权限 1docker run -it -v /宿主机目录:/容器目录 镜像名 挂载目录只读 1docker run -it -v /宿主机目录:/容器目录:ro 镜像名 多个目录拥有全部权限 1docker run -it -v /宿主机目录:/容器目录 -v /宿主机目录2:/容器目录2 镜像名 挂载目录只读 1docker run -it -v /宿主机目录:/容器目录:ro -v /宿主机目录2:/容器目录2:ro 镜像名 注意同步的是多级目录，可能会出现权限不足的提示，这是因为Centos7中的安全模块selinux把权限禁掉了，我们需要在命令的后面添加--privileged=true来解决挂载的目录没有权限的问题 PS.一般来说，都是创建容器时进行目录挂载，对于已经创建好的容器如果忘了挂载目录但是又想挂载目录，方法有两种：①提交这个容器为新的镜像，然后创建这个新镜像的容器同时进行目录挂载（此方式较简单）②修改这个容器的配置文件 具体步骤查看博客：Docker修改已创建容器的挂载目录","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker推送镜像到阿里云","slug":"298","date":"2021-08-20T15:26:34.000Z","updated":"2022-04-14T02:40:16.536Z","comments":true,"path":"298.html","link":"","permalink":"https://blog.zoutl.cn/298.html","excerpt":"","text":"进入阿里云镜像控制台控制台地址：https://cr.console.aliyun.com ，登录 创建命令空间 创建镜像仓库创建仓库 填写仓库信息 选择本地仓库 阿里云提供的命令 推送镜像登录 1docker login --username=用户名 registry.cn-hangzhou.aliyuncs.com 创建一个阿里云专用镜像 1docker tag 要推送的镜像id registry.cn-hangzhou.aliyuncs.com/ledao/tomcat:[镜像版本号] 下图中版本号为1.1的就是刚刚创建的 推送 1docker push registry.cn-hangzhou.aliyuncs.com/ledao/tomcat:[镜像版本号] 查看阿里云的镜像仓库中成功推送的镜像 拉取镜像1docker pull registry.cn-hangzhou.aliyuncs.com/ledao/tomcat:[阿里云的镜像版本号]","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker推送镜像到hub服务器","slug":"297","date":"2021-08-20T12:56:12.000Z","updated":"2022-04-14T02:39:16.924Z","comments":true,"path":"297.html","link":"","permalink":"https://blog.zoutl.cn/297.html","excerpt":"","text":"注册Docker账号在Docker的hub官网注册，官网地址为：https://hub.docker.com/ ，注册后记住用户名和密码 登录输入登录命令，在输入自己的用户名和密码即可 1docker login 推送镜像推送命令： 1docker push Docker用户名/新镜像名称:版本号 查看在Docker的hub官网登录后即可看到刚刚推送的镜像 拉取镜像查看镜像时有个拉取命令,如下图所示","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker提交运行时容器为镜像","slug":"296","date":"2021-08-20T07:06:21.000Z","updated":"2022-04-14T02:39:14.259Z","comments":true,"path":"296.html","link":"","permalink":"https://blog.zoutl.cn/296.html","excerpt":"","text":"命令： 1docker commit -a=&#x27;作者&#x27; -m=&#x27;备注&#x27; 运行时容器ID Docker用户名/新镜像名称:版本号 下图中划红线的镜像就是刚刚提交的镜像","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker映射端口6666时无法访问","slug":"295","date":"2021-08-20T04:36:03.000Z","updated":"2022-04-14T02:40:19.244Z","comments":true,"path":"295.html","link":"","permalink":"https://blog.zoutl.cn/295.html","excerpt":"","text":"问题描述在创建Docker的Tomcat容器时使用了端口映射，我映射的端口号是6666，外部使用谷歌浏览器却无法访问 原因6666端口使用谷歌浏览器、火狐浏览器、新版Edge浏览器是无法访问的，被我们遗忘的IE浏览器却可以访问！！ 上述浏览器我都亲自验证过，其它浏览器不清楚情况 更多无法访问的端口号如下： 端口 原因 1 tcpmux 7 echo 9 discard 11 systat 13 daytime 15 netstat 17 qotd 19 chargen 20 ftp data 21 ftp access 22 ssh 23 telnet 25 smtp 37 time 42 name 43 nicname 53 domain 77 priv-rjs 79 finger 87 ttylink 95 supdup 101 hostriame 102 iso-tsap 103 gppitnp 104 acr-nema 109 pop2 110 pop3 111 sunrpc 113 auth 115 sftp 117 uucp-path 119 nntp 123 NTP 135 loc-srv /epmap 139 netbios 143 imap2 179 BGP 389 ldap 465 smtp+ssl 512 print / exec 513 login 514 shell 515 printer 526 tempo 530 courier 531 chat 532 netnews 540 uucp 556 remotefs 563 nntp+ssl 587 stmp? 601 ?? 636 ldap+ssl 993 ldap+ssl 995 pop3+ssl 2049 nfs 3659 apple-sasl / PasswordServer 4045 lockd 6000 X11 6665 Alternate IRC [Apple addition] 6666 Alternate IRC [Apple addition] 6667 Standard IRC [Apple addition] 6668 Alternate IRC [Apple addition] 6669 Alternate IRC [Apple addition] 解决办法修改端口号，避免使用上表的端口号","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker启动Tomcat成功后外部却无法访问","slug":"294","date":"2021-08-19T20:48:29.000Z","updated":"2022-04-14T02:39:12.097Z","comments":true,"path":"294.html","link":"","permalink":"https://blog.zoutl.cn/294.html","excerpt":"","text":"问题描述在创建Docker的Tomcat容器时使用了端口映射，外部无法通过 http://虚拟机IP:映射的端口号 来访问 原因Docker某些Tomcat版本的webapps是空的，直接访问是访问不到的，但是这些Tomcat有一个webapps.dist目录，这个目录就是原来的webapps目录 解决办法第一种办法使用webapps目录不为空的Tomcat版本，webapps目录不为空的Tomcat版本有：8.0.52、8.5.28，直接使用这两个版本即可 第二种办法使用webapps目录为空的Tomcat版本，删除掉webapps空目录，再将webapps.dist目录命名为webapps","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker常用命令","slug":"293","date":"2021-08-19T12:52:43.000Z","updated":"2022-04-14T02:40:21.165Z","comments":true,"path":"293.html","link":"","permalink":"https://blog.zoutl.cn/293.html","excerpt":"","text":"Docker命令启动Docker1systemctl start docker 停止Docker1systemctl stop docker 重启Docker1systemctl restart docker 设置开机启动1systemctl enable docker 查看Docker概要信息1docker info 查看Docker帮助文档1docker --help 查看Docker版本信息1docker version 镜像命令查看所有镜像1docker images 目录名称 含义 REPOSITORY 镜像的仓库源 TAG 镜像的标签（版本）同一个仓库有多个TAG的镜像，多个版本；我们用REPOSITORY:TAG来定义不同的镜像； IMAGE ID 镜像ID，镜像的唯一标识 CREATE 镜像创建时间 SIZE 镜像大小 搜索镜像1docker search 镜像名称 下载镜像下载最新版 1docker pull 镜像名称 下载指定版本 1docker pull 镜像名称:版本号 删除镜像不加版本号就删除最新版 普通删除，如果镜像正在运行就无法删除 1docker rmi 镜像名称:版本号 强制删除，即使镜像正在运行也可以删除 1docker rmi -f 镜像名称:版本号 查看元数据1docker inspect 镜像id 容器命令创建容器普通方式创建容器：创建容器（容器为停止状态） 1docker run --name 自定义名称 镜像id 交互式创建容器：创建并进入该容器（容器为运行状态） 1docker run -it --name 自定义名称 镜像id 守护方式创建容器：创建容器但是不进入（容器为运行状态） 1docker run -di --name 自定义名称 镜像id 端口映射，可以通过：http://192.168.0.140:8888/ 访问 1docker run --name 自定义名称 -d -p 8888:8080 镜像id 参数： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d: 后台运行容器，并返回容器ID； -i: 以交互模式运行容器，通常与 -t 同时使用； -P: 随机端口映射，容器内部端口随机映射到主机的端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； –name=”nginx-lb”: 为容器指定一个名称； –dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致； –dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致； -h “mars”: 指定容器的hostname； -e username=”ritchie”: 设置环境变量； –env-file=[]: 从指定文件读入环境变量； –cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行； **-m:**设置容器使用内存最大值； –net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型； –link=[]: 添加链接到另一个容器； –expose=[]: 开放一个端口或一组端口； –volume , -v: 绑定一个卷 退出容器容器停止并退出，命令为： 1exit 容器不停止退出，按键组合为： 1CTRL+P+Q 列出容器查看正在运行的容器 1docker ps 查看所有容器，包括已经停止的 1docker ps -a 显示最近创建的2个容器 1docker ps -n 2 查看停止的容器 1docker ps -f status=exited 所有选项说明： -a ：显示所有的容器，包括未运行的 -f ：根据条件过滤显示的内容 –format ：指定返回值的模板文件 -l ：显示最近创建的容器 -n ：列出最近创建的n个容器 –no-trunc ：不截断输出 -q ：静默模式，只显示容器编号 -s ：显示总的文件大小 进入容器进入正在运行的容器，参数可以是容器id也可以是容器名称，建议使用容器id 1docker attach 容器id或者容器名称 启动容器启动已经停止的容器，参数可以是容器id也可以是容器名称，建议使用容器id 1docker start 容器id或者容器名称 重启容器重启正在运行的容器，参数可以是容器id也可以是容器名称，建议使用容器id 1docker restart 容器id或者容器名称 停止容器停止正在运行的容器，参数可以是容器id也可以是容器名称，建议使用容器id 1docker stop 容器id或者容器名称 暴力删除，直接杀掉进程，参数可以是容器id也可以是容器名称，建议使用容器id，不推荐此方法 1docker kill 容器id或者容器名称 删除容器删除已经停止的容器，正在运行的容器要先停止再删除 1docker rm 容器id 强制删除正在运行的容器 1docker rm -f 容器id 删除多个容器，多个容器id用空格隔开 1docker rm -f 容器id1 容器id2 删除所有容器 1docker rm -f $(docker ps -qa) 参数： -f：通过 SIGKILL 信号强制删除一个运行中的容器。 -l：移除容器间的网络连接，而非容器本身。 -v：删除与容器关联的卷。 执行容器命令不进入容器并执行容器的命令，例子：docker exec 0f4c269bb2cf ls -l /sys/，本例子的容器为CentOS系统 1docker exec -it 容器id 容器的可执行命令 查看容器日志1docker logs 容器id 某容器的日志文件位置为：在/var/lib/docker/containers下找到对应容器的文件夹，打开文件夹后后一个.log后缀的文件，这就是日志文件了,如果时间久了日志文件变得很大，就直接操作该文件即可 查看容器进程1docker top 容器id 文件拷贝宿主机（当前系统：VM虚拟机正在运行的系统）文件或者目录拷贝到容器内 1docker cp 需要拷贝的文件或者目录 容器名称或r:容器目录 容器文件或者目录拷贝到宿主机内 1docker cp 容器名称:容器文件或者目录 宿主机目录 查看元数据1docker inspect 容器id 重命名容器1docker rename 原容器名 新容器名","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker使用pull命令时报错","slug":"292","date":"2021-08-19T12:29:55.000Z","updated":"2022-04-14T02:40:24.143Z","comments":true,"path":"292.html","link":"","permalink":"https://blog.zoutl.cn/292.html","excerpt":"","text":"问题描述使用pull命令安装容器时报错：Error response from daemon: Get “https://registry-1.docker.io/v2/&quot;: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 解决办法配置国内镜像查看博客：Docker配置阿里云镜像仓库 添加DNS地址如果配置了国内镜像地址还是报错，就添加DNS地址，在/etc/resolv.conf中添加两行代码： 12nameserver 8.8.8.8nameserver 8.8.4.4 重启一下Docker 1systemctl restart docker","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Docker配置阿里云镜像仓库","slug":"291","date":"2021-08-19T11:59:43.000Z","updated":"2022-04-14T02:39:09.505Z","comments":true,"path":"291.html","link":"","permalink":"https://blog.zoutl.cn/291.html","excerpt":"","text":"问题描述Docker默认远程仓库是 https://hub.docker.com/ ，下载速度会很慢，所以要配置一下国内镜像 配置过程获取镜像地址进入阿里云容器镜像服务地址：点这里快速进入，登录后复制镜像仓库地址 新建配置文件在/etc/docker文件夹下新建一个名为 daemon.json 的配置文件，内容如下：（链接填自己的） 123&#123; &quot;registry-mirrors&quot;: [&quot;https://*********.mirror.aliyuncs.com&quot;]&#125; 重启daemon1systemctl daemon-reload 重启docker服务1systemctl restart docker 测试下载一个tomcat，命令为： 1docker pull tomcat 发现速度快了很多","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"CentOS7安装Docker","slug":"290","date":"2021-08-19T10:33:56.000Z","updated":"2022-04-14T02:37:21.831Z","comments":true,"path":"290.html","link":"","permalink":"https://blog.zoutl.cn/290.html","excerpt":"","text":"登录身份使用root身份登录，一般默认都是用root身份 查看系统内核Docker要求CentOS系统的内核版本高于3.10，安装前先查看自己的CentOS系统能否安装Docker 1uname -r 更新yum包1yum update 卸载旧版本如果安装过旧版本的话，没有就跳过此步骤 1yum remove docker docker-common docker-selinux docker-engine 安装软件包安装需要的软件包，yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1yum install -y yum-utils device-mapper-persistent-data lvm2 设置yum源1yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装新版本1yum install docker-ce docker-ce-cli containerd.io 启动1systemctl start docker 设置开机启动1systemctl enable docker 验证看到版本号说明安装成功 1docker version 测试安装hello-world镜像1docker pull hello-world 创建hello-world的一个容器并启动1docker run hello-world 看到Hello from Docker!，说明容器启动成功","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"}]},{"title":"Config配置搜索路径","slug":"289","date":"2021-08-18T16:42:23.000Z","updated":"2022-04-14T02:16:40.574Z","comments":true,"path":"289.html","link":"","permalink":"https://blog.zoutl.cn/289.html","excerpt":"","text":"问题描述当配置文件一多，如果配置文件只放在根目录下，后期会不好管理，所以根据项目分类配置文件是很有必要的 配置过程在microservice-config-server-4001项目的application.yml文件中配置search-paths 完整application.yml如下： 123456789101112131415server: port: 4001 context-path: /spring: application: name: microservice-config cloud: config: server: git: uri: https://github.com/a6678696/microservice-config search-paths: #后面接文件夹名称,没有配置的文件夹里的配置文件是访问不到的 - aa #文件夹名称 - bb 测试新建三个文件夹：aa、bb、cc，文件夹中分别放3个配置文件 nns.yml，nns2.yml，nns3.yml，上传这三个配置文件到GitHub的microservice-config库中，文件内容如下： nns.yml 123456789101112spring: profiles: active: - dev---spring: profiles: devname: aaadev---spring: profiles: testname: aaatest nns2.yml 123456789101112spring: profiles: active: - dev---spring: profiles: devname: bbbdev---spring: profiles: testname: bbbtest nns3.yml 123456789101112spring: profiles: active: - dev---spring: profiles: devname: cccdev---spring: profiles: testname: ccctest 地址栏输入：http://configserver.ledao.com:4001/nns-dev.yml ，访问到了，有name属性 地址栏输入：http://configserver.ledao.com:4001/nns3-dev.yml ，没有访问到了，没有name属性","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"}]},{"title":"Spring Cloud Config整合Eureka","slug":"248","date":"2021-08-18T15:06:19.000Z","updated":"2022-04-14T02:14:22.190Z","comments":true,"path":"248.html","link":"","permalink":"https://blog.zoutl.cn/248.html","excerpt":"","text":"上传配置文件到GitHub配置文件名为：eureka_config.yml，上传到GitHub的microservice-config库中，内容如下： 1234567891011121314151617181920212223242526272829303132spring: profiles: active: - dev #当前使用的是dev配置---server: port: 2004 context-path: /spring: profiles: deveureka: instance: hostname: localhost client: register-with-eureka: false #false 由于该应用为注册中心，所以设置为false,代表不向注册中心注册自己。 fetch-registry: false #false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务，所以也设置为false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka注册中心交互的地址，查询服务和注册服务用到 #设置与Eureka注册中心交互的地址，查询服务和注册服务用到---server: port: 2004 context-path: /spring: profiles: test eureka: instance: hostname: localhost client: register-with-eureka: false #false 由于该应用为注册中心，所以设置为false,代表不向注册中心注册自己。 fetch-registry: false #false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务，所以也设置为false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka注册中心交互的地址，查询服务和注册服务用到 #设置与Eureka注册中心交互的地址，查询服务和注册服务用到 整合过程引入依赖12345678910111213141516171819&lt;!--Spring Cloud Client--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Eureka服务--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 修改后立即生效，热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置123spring: application: name: microservice-eureka-server-config bootstrap.yml配置123456789spring: application: name: microservice-eureka-server-config cloud: config: name: eureka_config uri: http://configserver.ledao.com:4001 # 配置configserver地址 profile: dev # 级别 label: master # 分支git中 默认master 启动类123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * Config整合Eureka启动类 * * @author LeDao * @company * @create 2021-08-18 23:46 */@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication_2004 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication_2004.class, args); &#125;&#125; 添加本地域名映射找到 C:\\Windows\\System32\\drivers\\etc 打开hosts，底部加配置： 1127.0.0.1 eureka2004.ledao.com 测试启动项目：microservice-config-server-4001和microservice-eureka-server-config-2004 地址栏输入：http://eureka2004.ledao.com:2004/ ，如果配置成功会看到Eureka界面 PS.整合提供者服务和消费者服务的过程也基本相似","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://blog.zoutl.cn/tags/Eureka/"}]},{"title":"使用Config Client","slug":"288","date":"2021-08-18T12:58:15.000Z","updated":"2022-04-14T02:16:37.491Z","comments":true,"path":"288.html","link":"","permalink":"https://blog.zoutl.cn/288.html","excerpt":"","text":"上传文件到GitHub把之前上传到GitHub的microservice-config库中的文件都删除掉，再新建三个文件：application.yml、crm-dev.yml、crm-test.yml，然后上传到GitHub的microservice-config库中 application.yml内容为： 123456789101112spring: profiles: active: - dev---spring: profiles: devport: 111---spring: profiles: testport: 222 crm-dev.yml内容为： 1port: 7777 crm-test.yml 1port: 88888 使用步骤新建Module在idea中新建一个Module，为Maven项目，命名为：microservice-config-client-5001 加入依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置123server: port: 5001 context-path: / bootstrap.yml配置新建一个配置文件，命名为：bootstrap.yml，优先级比application.yml高 12345678910spring: application: name: application-dev cloud: config: name: crm uri: http://configserver.ledao.com:4001 # 配置configserver地址 profile: dev #级别 label: master #分支git中,默认master fail-fast: true 添加启动类123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;/** * Config Server启动类 * * @author LeDao * @company * @create 2021-08-18 21:22 */@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class ConfigClientApplication_5001 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigClientApplication_5001.class, args); &#125;&#125; 添加ConfigClientController类主要用于提供测试接口 12345678910111213141516171819202122232425262728package com.ledao.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * 测试Controller * * @author LeDao * @company * @create 2021-08-18 21:25 */@RestControllerpublic class ConfigClientController &#123; @Value(&quot;$&#123;port&#125;&quot;) private String port; @RequestMapping(&quot;/getPort&quot;) public String getPort() &#123; return port; &#125; public void setPort(String port) &#123; this.port = port; &#125;&#125; 添加本地域名映射找到 C:\\Windows\\System32\\drivers\\etc 打开hosts，底部加配置： 1127.0.0.1 client-config.ledao.com 测试地址栏输入：http://client-config.ledao.com:5001/getPort ，根据bootstrap.yml的配置获取不同文件的port 当spring.cloud.config.name=application，spring.cloud.config.profile=dev时 返回111，此时返回的是application.yml的dev端口 当spring.cloud.config.name=application，spring.cloud.config.profile=test时 返回222，此时返回的是application.yml的test端口 当spring.cloud.config.name=crm，spring.cloud.config.profile=dev时 返回7777，此时返回的是crm-dev.yml的端口 当spring.cloud.config.name=crm，spring.cloud.config.profile=test时 返回88888，此时返回的是crm-test.yml的端口","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"}]},{"title":"Spring Boot启动报错：Cannot determine embedded database driver class for database type NONE的解决办法","slug":"287","date":"2021-08-18T12:12:41.000Z","updated":"2022-04-14T02:16:35.401Z","comments":true,"path":"287.html","link":"","permalink":"https://blog.zoutl.cn/287.html","excerpt":"","text":"问题描述Spring Boot项目启动时报错：Cannot determine embedded database driver class for database type NONE 报错原因这是因为spring boot默认会加载org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration类，DataSourceAutoConfiguration类使用了@Configuration注解向spring注入了dataSource bean。因为工程中没有关于dataSource相关的配置信息，所以当spring创建dataSource bean因缺少相关的信息就会报错 解决办法解决办法有两种：一种是修改启动类注解，另一种是配置数据源 修改注解在启动类中修改注解@SpringBootApplication为： 1@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;) 配置数据源在application.yml中配置： 1234567891011121314# 数据源配置spring: application: name: microservice-student datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: true PS.来源：springboot常见问题之启动报错Cannot determine embedded database","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"}]},{"title":"使用Config Server","slug":"286","date":"2021-08-18T11:33:41.000Z","updated":"2022-04-14T02:16:32.304Z","comments":true,"path":"286.html","link":"","permalink":"https://blog.zoutl.cn/286.html","excerpt":"","text":"GitHub新建仓库GitHub新建一个仓库，命名为：microservice-config 在本地新建一个文件夹，也命名为：microservice-config，在文件夹内新建三个文件：application.yml、application-v1.yml和application-v2.yml，主要用于访问 application.yml内容为： 1profile: hello application-v1.yml内容为： 1profile: hello111 application-v2.yml内容为： 1profile: hello222 把文件夹内的所有文件都上传到刚刚新建的GitHub仓库中 使用步骤新建Module在idea中新建一个Module，为Maven项目，命名为：microservice-config-server-4001 引入依赖引入依赖config server依赖，我的完整pom.xml如下： 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--继承microservice依赖版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;artifactId&gt;microservice-config-server-4001&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入microservice-common依赖,引入后可以使用microservice-common的实体类,工具类等--&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置uri为GitHub仓库的http地址，但是去掉了后缀.git 1234567891011server: port: 4001spring: application: name: microservice-config cloud: config: server: git: uri: https://github.com/a6678696/microservice-config 添加启动类1234567891011121314151617181920212223package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;import org.springframework.cloud.config.server.EnableConfigServer;/** * 配置服务启动类 * * @author LeDao * @company * @create 2021-08-18 18:51 */@EnableConfigServer@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class ConfigServerApplication_4001 &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApplication_4001.class, args); &#125;&#125; 添加本地域名映射找到 C:\\Windows\\System32\\drivers\\etc 打开hosts，底部加配置： 1127.0.0.1 configserver.ledao.com 测试启动microservice-config-server-4001项目 地址栏输入：http://configserver.ledao.com:4001/application-v1.yml 可以返回application-v1.yml的内容 地址栏输入：http://configserver.ledao.com:4001/application-v2.yml 可以返回application-v2.yml的内容 地址栏输入：http://configserver.ledao.com:4001/application-v3.yml 会返回application.yml的内容，其实GitHub仓库中并没有application-v3.yml这个文件，但是却访问了它，最终会返回根文件application.yml的内容 PS.请求路径匹配规则如下： 12345/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]/&#123;application&#125;-&#123;profile&#125;.yml/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml/&#123;application&#125;-&#123;profile&#125;.properties/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"}]},{"title":"Git查看远程库地址","slug":"285","date":"2021-08-18T10:25:40.000Z","updated":"2022-04-14T01:52:16.236Z","comments":true,"path":"285.html","link":"","permalink":"https://blog.zoutl.cn/285.html","excerpt":"","text":"命令： 1git remote -v 结果：","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"Zuul请求过滤配置","slug":"284","date":"2021-08-17T17:21:10.000Z","updated":"2022-04-14T02:16:27.725Z","comments":true,"path":"284.html","link":"","permalink":"https://blog.zoutl.cn/284.html","excerpt":"","text":"问题描述有时候系统的功能并不对外开放，所以在请求服务时可以过滤掉非法请求。Zuul通过ZuulFilter过滤器实现，每次经过Zuul服务网关，我们都对带来的token进行有效性验证，验证不通过就无法请求成功 配置过程定义过滤类命名为：AccessFilter.java，继承ZuulFilter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.ledao.filter;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import com.netflix.zuul.exception.ZuulException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.http.HttpServletRequest;/** * @author LeDao * @company * @create 2021-08-18 0:57 */public class AccessFilter extends ZuulFilter &#123; Logger logger = LoggerFactory.getLogger(AccessFilter.class); /** * 过滤器的类型 这里用pre，代表会再请求被路由之前执行 * * @return */ @Override public String filterType() &#123; return &quot;pre&quot;; &#125; /** * 过滤器的执行顺序 * * @return */ @Override public int filterOrder() &#123; return 0; &#125; /** * 判断该过滤器是否要被执行,返回true则执行过滤器 * * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; /** * 过滤器的具体执行逻辑 * * @return * @throws ZuulException */ @Override public Object run() throws ZuulException &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletRequest request = requestContext.getRequest(); String parameter = request.getParameter(&quot;accessToken&quot;); logger.info(request.getRequestURI() + &quot;请求访问&quot;); if (parameter == null) &#123; logger.error(&quot;accessToken为空!&quot;); requestContext.setSendZuulResponse(false); requestContext.setResponseStatusCode(401); requestContext.setResponseBody(&quot;&#123;\\&quot;result\\&quot;:\\&quot;accessToken is empty!\\&quot;&#125;&quot;); return null; &#125; logger.info(request.getRequestURI() + &quot;请求成功&quot;); return null; &#125;&#125; 开启Filter配置新建一个类，命名为：ZuulConfig.java 123456789101112131415161718192021package com.ledao.config;import com.ledao.filter.AccessFilter;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Zuul配置 * * @author LeDao * @company * @create 2021-08-18 0:59 */@Configurationpublic class ZuulConfig &#123; @Bean public AccessFilter accessFilter() &#123; return new AccessFilter(); &#125;&#125; 结果直接输入：http://zuul.ledao.com:3001/ledao/studentServer/student/list ，请求失败，返回错误信息：{“result”: “accessToken is empty!”} 加上?accessToken=111，即：http://zuul.ledao.com:3001/ledao/studentServer/student/list?accessToken=111 ，请求成功，返回正确的数据 本文主要是实现过滤配置，上面只是模拟了有accessToken","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Zuul","slug":"Zuul","permalink":"https://blog.zoutl.cn/tags/Zuul/"}]},{"title":"Zuul路由映射规则配置","slug":"283","date":"2021-08-17T16:26:01.000Z","updated":"2022-04-14T02:16:25.716Z","comments":true,"path":"283.html","link":"","permalink":"https://blog.zoutl.cn/283.html","excerpt":"","text":"问题描述默认路由请求地址，很容易暴露接口细节，可以通过配置映射规则来提高服务的安全性 配置过程在application.yml中添加以下配置 1234zuul: routes: studentServer.serviceId: microservice-student #服务名称 studentServer.path: /studentServer/** #替代服务的路径 现在可以通过 http://zuul.ledao.com:3001/studentServer/student/list 访问了 但是也可以通过 http://zuul.ledao.com:3001/microservice-student/student/list 访问，这样是不安全的，如果要忽略microservice-student服务就添加配置：ignored-services: “microservice-student”，如果要忽略所有的服务名称则修改为：ignored-services: “*”，完整配置如下： 12345zuul: routes: studentServer.serviceId: microservice-student #服务名称 studentServer.path: /studentServer/** #替代服务的路径 ignored-services: &quot;*&quot; 如果添加请求前缀，就添加配置：prefix: /ledao，最终配置如下： 1234567#Zuul路由配置zuul: routes: studentServer.serviceId: microservice-student #服务名称 studentServer.path: /studentServer/** #替代服务的路径 ignored-services: &quot;*&quot; #忽略的服务 prefix: /ledao #前缀 现在只能通过 http://zuul.ledao.com:3001/ledao/studentServer/student/list 访问，其它请求方式的结果都是404","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Zuul","slug":"Zuul","permalink":"https://blog.zoutl.cn/tags/Zuul/"}]},{"title":"Zuul路由配置","slug":"282","date":"2021-08-17T14:02:36.000Z","updated":"2022-04-14T02:16:23.213Z","comments":true,"path":"282.html","link":"","permalink":"https://blog.zoutl.cn/282.html","excerpt":"","text":"简介 上图的API路由网关服务由Zuul实现，主要就是对外提供服务接口的时候，起到了请求的路由和过滤作用，也因此能够隐藏内部服务的接口细节，从来有利于保护系统的安全性 配置过程新建Module该Module为Maven项目，命名为：microservice-zuul-3001 引入依赖引入zuul路由网关依赖 12345&lt;!-- zuul路由网关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 完整pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--继承microservice依赖版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservice-zuul-3001&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- zuul路由网关 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入microservice-common依赖,引入后可以使用microservice-common的实体类,工具类等--&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- actuator监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- hystrix容错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置12345678910111213141516171819202122server: port: 3001 context-path: /spring: application: name: microservice-zuuleureka: instance: instance-id: microservice-zuul:3001 #客户端实例名称 prefer-ip-address: true #显示IP client: service-url: defaultZone: http://eureka2001.ledao.com:2001/eureka/,http://eureka2002.ledao.com:2002/eureka/,http://eureka2003.ledao.com:2003/eureka/ # 集群info: groupId: @project.groupId@ artifactId: @project.artifactId@ version: @project.version@ 负责人: 王五 联系电话: 110 修改hosts找到 C:\\Windows\\System32\\drivers\\etc 打开hosts，底部加配置： 1127.0.0.1 zuul.ledao.com 添加启动类123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;/** * @author LeDao * @company * @create 2021-08-17 22:59 */@EnableZuulProxy@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class ZuulApplication_3001 &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication_3001.class, args); &#125;&#125; 测试启动启动以下项目： microservice-eureka-server-2001 microservice-eureka-server-2002 microservice-eureka-server-2003 microservice-student-provider-hystrix-1004 microservice-zuul-3001 microservice-student-consumer-feign-80 eureka注册中心有两个服务： 访问①直接访问 直接通过 http://localhost/student/list 访问 ②通过zuul路由 通过 http://zuul.ledao.com:3001/microservice-student/student/list 访问","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Zuul","slug":"Zuul","permalink":"https://blog.zoutl.cn/tags/Zuul/"}]},{"title":"Feign和Hystrix整合后配置超时时间","slug":"281","date":"2021-08-17T13:05:39.000Z","updated":"2022-04-14T02:16:21.094Z","comments":true,"path":"281.html","link":"","permalink":"https://blog.zoutl.cn/281.html","excerpt":"","text":"Feign和Hystrix整合后,原来服务提供者的Hystrix超时时间配置没用了 把microservice-student-provider-hystrix-1004和microservice-student-provider-hystrix-1005的超时时间配置删除，添加到带Feign的服务消费项目的application.yml中（项目名为：microservice-student-consumer-feign-80） 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 3000 虽然添加了超时时间配置，但是还是无效，无效原因为：feign 也有一个超时时间的设置，feign底层是ribbon的封装，所以直接配置ribbon，ribbon默认超时也是1秒。所以这里都是强制要求，ribbon的超时时间要大于hystrix的超时时间，否则 hystrix自定义的超时时间毫无意义 所以还得加个 ribbon超时时间设置 123ribbon: ReadTimeout: 10000 ConnectTimeout: 9000 到此，超时时间配置完成，新的超时时间已经生效","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.zoutl.cn/tags/Hystrix/"},{"name":"Feign","slug":"Feign","permalink":"https://blog.zoutl.cn/tags/Feign/"}]},{"title":"Windows10输入法获取当前时间","slug":"280","date":"2021-08-16T20:44:49.000Z","updated":"2022-04-14T02:01:58.874Z","comments":true,"path":"280.html","link":"","permalink":"https://blog.zoutl.cn/280.html","excerpt":"","text":"打开输入法设置右击单击右下角的输入法选项，选择设置 选择词库和自学习 点击添加或编辑自定义短语 添加短语添加短语：%yyyy%-%MM%-%dd% %HH%:%mm%:%ss% 使用在中文模式下输入sj即可获取当前时间","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"Git恢复之前的版本","slug":"279","date":"2021-08-16T20:01:26.000Z","updated":"2022-04-14T01:52:26.414Z","comments":true,"path":"279.html","link":"","permalink":"https://blog.zoutl.cn/279.html","excerpt":"","text":"解决方法回退（reset）、反做（revert） 回退（reset）原理git reset的作用是修改HEAD的位置，即将HEAD指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一 适用场景如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法 具体操作先查看当前库有哪些版本号，查看方法有两种： ①Git命令 1git log commit后的黄色字符串就是版本号 ②在GitHub中查看 点击下图的提交数 点击下图的复制按钮即可复制完整版本号 使用下面命令将版本回退 1git reset --hard 目标版本号 使用下面命令提交更改，-f代表强制 1git push -f 反做（revert）原理git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。比如，我们commit了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西 适用场景如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法 具体操作查看版本号，上面有具体操作 使用下面命令反做，这里可能会出现冲突，那么需要手动修改冲突的文件，而且要git add 文件名 1git revert -n 版本号 使用下面命令提交 1git commit -m &quot;提交备注信息&quot; 使用下面命令提交更改到远程库 1git push PS.来源：https://blog.csdn.net/yxlshk/article/details/79944535","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"整合Feign和Hystrix实现服务熔断服务降级彻底解耦","slug":"278","date":"2021-08-16T19:23:55.000Z","updated":"2022-04-14T02:16:16.380Z","comments":true,"path":"278.html","link":"","permalink":"https://blog.zoutl.cn/278.html","excerpt":"","text":"解耦原因下面代码使用@HystrixCommand(fallbackMethod = “getInfoFallback”)业务代码耦合度太高，不利于维护，所以需要整合Feign和Hystrix进行解耦 123456789101112131415161718192021222324252627/** * 获取信息 * * @return * @throws InterruptedException */@RequestMapping(&quot;/getInfo&quot;)@HystrixCommand(fallbackMethod = &quot;getInfoFallback&quot;)public Map&lt;String, Object&gt; getInfo() throws InterruptedException &#123; Thread.sleep(100); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;code&quot;, 200); map.put(&quot;info&quot;, &quot;业务数据1004&quot;); return map;&#125;/** * 请求超时就请求我 * * @return */public Map&lt;String, Object&gt; getInfoFallback() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;code&quot;, 500); map.put(&quot;info&quot;, &quot;系统出错，稍后重试&quot;); return map;&#125; 实现过程修改Hystrix服务提供者项目项目名为：microservice-student-provider-hystrix-1004和microservice-student-provider-hystrix-1005 在StudentService.java中添加新的接口： 12345/** * 获取信息 * @return */Map&lt;String,Object&gt; getInfo(); 在StudentServiceImpl.java中实现上面的接口 1234567@Overridepublic Map&lt;String, Object&gt; getInfo() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;code&quot;, 200); map.put(&quot;info&quot;, &quot;业务数据1004&quot;); return map;&#125; 在StudentProviderController.java中调用 1234567891011/** * 获取信息 * * @return * @throws InterruptedException */@RequestMapping(&quot;/getInfo&quot;)public Map&lt;String, Object&gt; getInfo() throws InterruptedException &#123; Thread.sleep(500); return studentService.getInfo();&#125; 修改公共项目项目名为：microservice-common 在StudentClientService.java中添加getInfo接口方法，并修改@FeignClient注解为：@FeignClient(value = “MICROSERVICE-STUDENT”, fallbackFactory = StudentClientFallbackFactory.class) 1234567/** * 获取信息 * * @return */@RequestMapping(&quot;/student/getInfo&quot;)Map&lt;String, Object&gt; getInfo(); 新建StudentClientFallbackFactory.java，实现FallbackFactory&lt;StudentClientService&gt;接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.ledao.service;import com.ledao.entity.Student;import feign.hystrix.FallbackFactory;import org.springframework.stereotype.Component;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @author LeDao * @company * @create 2021-08-16 2:18 */@Componentpublic class StudentClientFallbackFactory implements FallbackFactory&lt;StudentClientService&gt; &#123; @Override public StudentClientService create(Throwable throwable) &#123; return new StudentClientService() &#123; @Override public Student get(Integer id) &#123; return null; &#125; @Override public List&lt;Student&gt; list() &#123; return null; &#125; @Override public boolean save(Student student) &#123; return false; &#125; @Override public boolean delete(Integer id) &#123; return false; &#125; @Override public Map&lt;String, Object&gt; getInfo() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;code&quot;, 500); map.put(&quot;info&quot;, &quot;系统出错，稍后重试&quot;); return map; &#125; &#125;; &#125;&#125; 修改Feign消费者项目项目名为：microservice-student-consumer-feign-80 在StudentConsumerFeignController.java中添加调用方法 123456789/** * 获取信息 * * @return */@RequestMapping(&quot;/getInfo&quot;)public Map&lt;String, Object&gt; getInfo() &#123; return studentClientService.getInfo();&#125; application.yml加上hystrix支持 123feign: hystrix: enabled: true 配置超时时间因为整合了Feign和Hystrix，原来服务提供者的Hystrix超时时间配置没用了，如何配置查看：Feign和Hystrix整合后配置超时时间 测试启动以下项目： microservice-eureka-server-2001 microservice-eureka-server-2002 microservice-eureka-server-2003 microservice-student-provider-hystrix-1004 microservice-student-provider-hystrix-1005 microservice-student-consumer-feign-80 如果超时的情况返回错误信息（500 系统出错，稍后重试），说明配置成功","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.zoutl.cn/tags/Hystrix/"},{"name":"Feign","slug":"Feign","permalink":"https://blog.zoutl.cn/tags/Feign/"}]},{"title":"Hystrix集群监控turbine","slug":"277","date":"2021-08-16T19:18:59.000Z","updated":"2022-04-14T02:16:12.127Z","comments":true,"path":"277.html","link":"","permalink":"https://blog.zoutl.cn/277.html","excerpt":"","text":"简介Hystrix集群监控使用的是turbine，而turbine是基于Dashboard的 组建Hystrix集群新建一个Module，该Module为Maven项目，命名为：microservice-student-provider-hystrix-1005，把microservice-student-provider-hystrix-1004的所有文件都复制一份过来，修改几个地方： 修改application.ymlserver.port修改为：1005，eureka.instance.instance-id: microservice-student-hystrix修改为：1005 修改启动类如果启动类是复制过来的，重命名为：StudentProviderHystrixApplication_1005 新建集群监控项目新建一个Module，命名为：microservice-student-consumer-hystrix-turbine-91 添加依赖12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 继承父项目的依赖版本 123456&lt;!--继承microservice依赖版本--&gt;&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; application.yml配置12345678910111213141516server: port: 91 context-path: /eureka: client: service-url: defaultZone: http://eureka2001.ledao.com:2001/eureka/,http://eureka2002.ledao.com:2002/eureka/,http://eureka2003.ledao.com:2003/eureka/turbine: app-config: microservice-student # 指定要监控的应用名称 clusterNameExpression: &quot;&#x27;default&#x27;&quot; #表示集群的名字为defaultspring: application: name: turbine 新建启动类1234567891011121314151617181920212223package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;import org.springframework.cloud.netflix.turbine.EnableTurbine;/** * Hystrix集群监控启动类 * * @author LeDao * @company * @create 2021-08-16 1:03 */@EnableTurbine@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class StudentConsumerTurbineApplication_91 &#123; public static void main(String[] args) &#123; SpringApplication.run(StudentConsumerTurbineApplication_91.class, args); &#125;&#125; 测试启动以下项目microservice-eureka-server-2001 microservice-eureka-server-2002 microservice-eureka-server-2003 microservice-student-provider-hystrix-1004 microservice-student-provider-hystrix-1005 microservice-student-consumer-80 microservice-student-consumer-hystrix-dashboard-90 microservice-student-consumer-hystrix-turbine-91 调用服务集群浏览器地址栏输入：http://localhost/student/getInfo 监控数据浏览器地址栏输入：http://localhost:91/turbine.stream 如果使用图形界面监控，则先输入：http://localhost:90/hystrix 打开图形监控界面，在第一个输入框输入：http://localhost:91/turbine.stream ，再点击按钮即可","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.zoutl.cn/tags/Hystrix/"}]},{"title":"Hystrix使用服务监控","slug":"276","date":"2021-08-16T19:16:53.000Z","updated":"2022-04-14T02:16:08.278Z","comments":true,"path":"276.html","link":"","permalink":"https://blog.zoutl.cn/276.html","excerpt":"","text":"简介Hystrix提供了 准实时的服务调用监控项目Dashboard，能够实时记录通过Hystrix发起的请求执行情况，可以通过图表的形式展现给用户看。 配置新建Module该Module为Maven项目，命名为：microservice-student-consumer-hystrix-dashboard-90 添加依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 记得先继承父项目的依赖版本 123456&lt;!--继承microservice依赖版本--&gt;&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; application.yml配置123server: port: 90 context-path: / 启动类1234567891011121314151617181920212223package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;/** * Hystrix服务监控90启动类 * * @author LeDao * @company * @create 2021-08-15 17:46 */@EnableHystrixDashboard@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class StudentConsumerDashBoardApplication_90 &#123; public static void main(String[] args) &#123; SpringApplication.run(StudentConsumerDashBoardApplication_90.class, args); &#125;&#125; 查看结果在浏览器地址栏输入：http://localhost:90/hystrix ，出现下面界面说明配置成功 使用先启动三个eureka，然后再启动microservice-student-provider-hystrix-1004 开始监控输入：http://localhost:1004/hystrix.stream ，一直是ping，然后data返回数据 如果要使用图形界面监控，浏览器地址栏输入：http://localhost:90/hystrix ，出现上图，在第一个输入框输入：http://localhost:1004/hystrix.stream ，然后点击Monitor Stream按钮即可，会出现下面界面 指标含义 各种情况","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.zoutl.cn/tags/Hystrix/"}]},{"title":"Hystrix修改默认超时时间","slug":"275","date":"2021-08-16T19:13:49.000Z","updated":"2022-04-14T02:16:06.243Z","comments":true,"path":"275.html","link":"","permalink":"https://blog.zoutl.cn/275.html","excerpt":"","text":"概述Hystrix的默认超时时间是1秒，有时候正常请求响应的时间就超过了1秒，所以1秒钟并不能满足日常的开发需求，需要根据实际情况设置超时时间 源码位置1private static final Integer default_executionTimeoutInMilliseconds = 1000; 修改在application.yml中添加下面配置： 1234567hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 3000 数值的单位为毫秒，1000毫秒==1秒 测试先启动三个eureka，再启动带hystrix的provider，最后启动普通的consumer 浏览器地址输入：http://localhost/student/getInfo 上面配置已经将Hystrix的默认超时时间修改为3秒，使用Thread.sleep(2000)让程序睡眠两秒也不会超时","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.zoutl.cn/tags/Hystrix/"}]},{"title":"使用Hystrix断路器","slug":"274","date":"2021-08-16T19:07:29.000Z","updated":"2022-04-14T02:16:03.246Z","comments":true,"path":"274.html","link":"","permalink":"https://blog.zoutl.cn/274.html","excerpt":"","text":"简介hystrix对应的中文名字是“豪猪”，豪猪周身长满了刺，能保护自己不受天敌的伤害，代表了一种防御机制，这与hystrix本身的功能不谋而合，因此Netflix团队将该框架命名为Hystrix，并使用了对应的卡通形象做作为logo。 在一个分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，这个就是Hystrix需要做的事情。Hystrix提供了熔断、隔离、Fallback、cache、监控等功能，能够在一个、或多个依赖同时出现问题时保证系统依然可用。 服务雪崩效应当一个请求依赖多个服务的时候： 正常情况下的访问 但是，当请求的服务中出现无法访问、异常、超时等问题时（图中的I），那么用户的请求将会被阻塞 如果多个用户的请求中，都存在无法访问的服务，那么他们都将陷入阻塞的状态中 作用Hystrix断路器可以通过服务熔断和服务降级来解决上述的服务雪崩效应 使用熔断机制是应对雪崩效应的一种微服务链路保护机制，当某个服务不可用或者响应时间超时，会进行服务降级，进而熔断该节点的服务调用，快速返回自定义的错误影响页面信息 新建Module命名为microservice-student-provider-hystrix-1004，把microservice-student-provider-1001的配置和代码都复制一份到新建的Module中 修改pom.xml引入Hystrix断路器依赖 12345&lt;!--Hystrix断路器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 修改application.yml修改server.port为1004，eureka.instance.instance-id为microservice-student-hystrix:1004 修改启动类如果是复制过来的，重命名为StudentProviderHystrixApplication_1004，并添加@EnableCircuitBreaker注解支持Hystrix断路器 修改消费者ControllerStudentConsumerController.java在microservice-student-consumer-80项目中 添加getInfo方法，用于调用服务的getInfo方法 12345678910/** * 获取信息 * * @return */@RequestMapping(&quot;/getInfo&quot;)@SuppressWarnings(&quot;unchecked&quot;)public Map&lt;String, Object&gt; getInfo() &#123; return restTemplate.getForObject(PRE_HOST + &quot;/student/getInfo&quot;, Map.class);&#125; 修改提供者ControllerStudentProviderController.java在microservice-student-provider-hystrix-1004项目中 添加两个方法：getInfo方法和getInfoFallback方法 在hystrix中默认1秒算超时，使用Thread.sleep(2000)模拟请求超时（@HystrixCommand注解定义了请求超时的时候就请求getInfoFallback方法，返回500 系统出错，稍后重试），不使用就不会超时（执行完getInfo方法，返回200 业务数据）。由于请求超时的时候进行服务降级，进而熔断该节点的服务调用，快速返回自定义的错误影响页面信息，所以可以有效地解决雪崩效应 123456789101112131415161718192021222324252627/** * 获取信息 * * @return * @throws InterruptedException */@RequestMapping(&quot;/getInfo&quot;)@HystrixCommand(fallbackMethod = &quot;getInfoFallback&quot;)public Map&lt;String, Object&gt; getInfo() throws InterruptedException &#123; Thread.sleep(2000); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;code&quot;, 200); map.put(&quot;info&quot;, &quot;业务数据&quot;); return map;&#125;/** * 请求超时就请求我 * * @return */public Map&lt;String, Object&gt; getInfoFallback() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;code&quot;, 500); map.put(&quot;info&quot;, &quot;系统出错，稍后重试&quot;); return map;&#125; 测试先启动三个eureka，再启动带hystrix的provider，最后启动普通的consumer 浏览器地址输入：http://localhost/student/getInfo 使用Thread.sleep(2000)时会超时，返回500 系统出错，稍后重试，如下图： 注释掉Thread.sleep(2000)时不会超时，返回200 业务数据，如下图：","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.zoutl.cn/tags/Hystrix/"}]},{"title":"Markdown代码块编程语言清单","slug":"273","date":"2021-08-13T13:10:56.000Z","updated":"2022-04-10T15:18:49.285Z","comments":true,"path":"273.html","link":"","permalink":"https://blog.zoutl.cn/273.html","excerpt":"","text":"我的常用 语言名称 Markdown 语言声明 HTML html CSS css JavaScript javascript Java java Linux和Windows命令、Bash、文件路径 bash XML xml .yml yaml SQL sql 所有 语言名称 Markdown 语言声明 常见文件名 1C Enterprise 1c-enterprise *.bsl 4D 4d *.4dm ABAP abap *.abap ABNF abnf *.abnf AGS Script ags-script, ags *.asc AMPL ampl *.ampl ANTLR antlr *.g4 API Blueprint api-blueprint *.apib APL apl *.apl ASN.1 asn.1 *.asn ASP asp, aspx, aspx-vb *.asp ATS ats, ats2 *.dats ActionScript actionscript, actionscript3, as3 *.as Ada ada, ada95, ada2005 *.adb Adobe Font Metrics adobe-font-metrics, acfm, amfm *.afm Agda agda *.agda Alloy alloy *.als Alpine Abuild alpine-abuild, abuild, apkbuild APKBUILD Altium Designer altium-designer, altium *.OutJob AngelScript angelscript *.as Ant Build System ant-build-system ant.xml ApacheConf apacheconf, aconf, apache *.apacheconf, .htaccess Apex apex *.cls Apollo Guidance Computer apollo-guidance-computer *.agc AppleScript applescript, osascript *.applescript Arc arc *.arc AsciiDoc asciidoc *.asciidoc AspectJ aspectj *.aj Assembly assembly, asm, nasm *.asm Asymptote asymptote *.asy Augeas augeas *.aug AutoHotkey autohotkey, ahk *.ahk AutoIt autoit, au3, AutoIt3, AutoItScript *.au3 Awk awk *.awk Ballerina ballerina *.bal Batchfile batchfile, bat, batch, dosbatch, winbatch *.bat Befunge befunge *.befunge BibTeX bibtex *.bib Bison bison *.bison BitBake bitbake *.bb Blade blade *.blade BlitzBasic blitzbasic, b3d, blitz3d, blitzplus, bplus *.bb BlitzMax blitzmax, bmax *.bmx Bluespec bluespec *.bsv Boo boo *.boo Brainfuck brainfuck *.b Brightscript brightscript *.brs C c *.c C# c#, csharp *.cs C++ c++, cpp *.cpp C-ObjDump c-objdump *.c-objdump C2hs Haskell c2hs-haskell, c2hs *.chs CLIPS clips *.clp CMake cmake *.cmake, CMakeLists.txt COBOL cobol *.cob COLLADA collada *.dae CSON cson *.cson CSS css *.css CSV csv *.csv CWeb cweb *.w Cabal Config cabal-config, Cabal *.cabal, cabal.config Cap’n Proto cap’n-proto *.capnp CartoCSS cartocss, Carto *.mss Ceylon ceylon *.ceylon Chapel chapel, chpl *.chpl Charity charity *.ch ChucK chuck *.ck Cirru cirru *.cirru Clarion clarion *.clw Clean clean *.icl Click click *.click Clojure clojure *.clj, riemann.config Closure Templates closure-templates, soy *.soy Cloud Firestore Security Rules cloud-firestore-security-rules firestore.rules CoNLL-U conll-u, CoNLL, CoNLL-X *.conllu CodeQL codeql, ql *.ql CoffeeScript coffeescript, coffee, coffee-script *.coffee, Cakefile ColdFusion coldfusion, cfm, cfml *.cfm ColdFusion CFC coldfusion-cfc, cfc *.cfc Common Lisp common-lisp, lisp *.lisp Common Workflow Language common-workflow-language, cwl *.cwl Component Pascal component-pascal, delphi, objectpascal *.cp Cool cool *.cl Coq coq *.coq Cpp-ObjDump cpp-objdump, c++-objdump *.cppobjdump Creole creole *.creole Crystal crystal *.cr Csound csound, csound-orc *.orc Csound Document csound-document, csound-csd *.csd Csound Score csound-score, csound-sco *.sco Cuda cuda *.cu Cycript cycript *.cy Cython cython, pyrex *.pyx D d *.d D-ObjDump d-objdump *.d-objdump DIGITAL Command Language digital-command-language, dcl *.com DM dm, byond *.dm DNS Zone dns-zone *.zone DTrace dtrace, dtrace-script *.d Dafny dafny *.dfy Darcs Patch darcs-patch, dpatch *.darcspatch Dart dart *.dart DataWeave dataweave *.dwl Dhall dhall *.dhall Diff diff, udiff *.diff DirectX 3D File directx-3d-file *.x Dockerfile dockerfile *.dockerfile, Dockerfile Dogescript dogescript *.djs Dylan dylan *.dylan E e *.E EBNF ebnf *.ebnf ECL ecl *.ecl ECLiPSe eclipse *.ecl EJS ejs *.ejs EML eml *.eml EQ eq *.eq Eagle eagle *.sch Easybuild easybuild *.eb Ecere Projects ecere-projects *.epj EditorConfig editorconfig, editor-config .editorconfig Edje Data Collection edje-data-collection *.edc Eiffel eiffel *.e Elixir elixir *.ex, mix.lock Elm elm *.elm Emacs Lisp emacs-lisp, elisp, emacs *.el, .abbrev_defs EmberScript emberscript *.em Erlang erlang *.erl, Emakefile F# f#, fsharp *.fs F* f*, fstar *.fst FIGlet Font figlet-font, FIGfont *.flf FLUX flux *.fx Factor factor *.factor, .factor-boot-rc Fancy fancy *.fy, Fakefile Fantom fantom *.fan Faust faust *.dsp Filebench WML filebench-wml *.f Filterscript filterscript *.fs Formatted formatted *.for Forth forth *.fth Fortran fortran *.f Fortran Free Form fortran-free-form *.f90 FreeMarker freemarker, ftl *.ftl Frege frege *.fr Futhark futhark *.fut G-code g-code *.g GAML gaml *.gaml GAMS gams *.gms GAP gap *.g GCC Machine Description gcc-machine-description *.md GDB gdb *.gdb GDScript gdscript *.gd GEDCOM gedcom *.ged GLSL glsl *.glsl GN gn *.gn, .gn Game Maker Language game-maker-language *.gml Genie genie *.gs Genshi genshi, xml+genshi, xml+kid *.kid Gentoo Ebuild gentoo-ebuild *.ebuild Gentoo Eclass gentoo-eclass *.eclass Gerber Image gerber-image, rs-274x *.gbr Gettext Catalog gettext-catalog, pot *.po Gherkin gherkin, cucumber *.feature Git Attributes git-attributes, gitattributes .gitattributes Git Config git-config, gitconfig, gitmodules *.gitconfig, .gitconfig Glyph glyph *.glf Glyph Bitmap Distribution Format glyph-bitmap-distribution-format *.bdf Gnuplot gnuplot *.gp Go go, golang *.go Golo golo *.golo Gosu gosu *.gs Grace grace *.grace Gradle gradle *.gradle Grammatical Framework grammatical-framework, gf *.gf Graph Modeling Language graph-modeling-language *.gml GraphQL graphql *.graphql Graphviz (DOT) dot *.dot Groovy groovy *.groovy, Jenkinsfile Groovy Server Pages groovy-server-pages, gsp *.gsp HAProxy haproxy *.cfg, haproxy.cfg HCL hcl, terraform *.hcl HLSL hlsl *.hlsl HTML html, xhtml *.html HTML+Django html+django, django, html+jinja, htmldjango *.jinja HTML+ECR html+ecr, ecr *.ecr HTML+EEX html+eex, eex *.eex HTML+ERB html+erb, erb *.erb HTML+PHP html+php *.phtml HTML+Razor html+razor, razor *.cshtml HTTP http *.http HXML hxml *.hxml Hack hack *.hack Haml haml *.haml Handlebars handlebars, hbs, htmlbars *.handlebars Harbour harbour *.hb Haskell haskell *.hs Haxe haxe *.hx HiveQL hiveql *.q HolyC holyc *.hc Hy hy, hylang *.hy HyPhy hyphy *.bf IDL idl *.pro IGOR Pro igor-pro, igor, igorpro *.ipf INI ini, dosini *.ini, buildozer.spec IRC log irc-log, irc *.irclog Idris idris *.idr Ignore List ignore-list, ignore, gitignore, git-ignore *.gitignore, .atomignore Inform 7 inform-7, i7, inform7 *.ni Inno Setup inno-setup *.iss Io io *.io Ioke ioke *.ik Isabelle isabelle *.thy Isabelle ROOT isabelle-root ROOT J j *.ijs JFlex jflex *.flex JSON json *.json, .arcconfig JSON with Comments json-with-comments, jsonc *.jsonc, .babelrc JSON5 json5 *.json5 JSONLD jsonld *.jsonld JSONiq jsoniq *.jq JSX jsx *.jsx Jasmin jasmin *.j Java java *.java Java Properties java-properties *.properties Java Server Pages java-server-pages, jsp *.jsp JavaScript javascript, js, node *.js, Jakefile JavaScript+ERB javascript+erb *.js.erb Jison jison *.jison Jison Lex jison-lex *.jisonlex Jolie jolie *.ol Jsonnet jsonnet *.jsonnet Julia julia *.jl Jupyter Notebook jupyter-notebook *.ipynb, Notebook KRL krl *.krl KiCad Layout kicad-layout, pcbnew *.kicad_pcb, fp-lib-table KiCad Legacy Layout kicad-legacy-layout *.brd KiCad Schematic kicad-schematic *.sch Kit kit *.kit Kotlin kotlin *.kt LFE lfe *.lfe LLVM llvm *.ll LOLCODE lolcode *.lol LSL lsl *.lsl LTspice Symbol ltspice-symbol *.asy LabVIEW labview *.lvproj Lasso lasso, lassoscript *.lasso Latte latte *.latte Lean lean *.lean Less less *.less Lex lex, flex *.l LilyPond lilypond *.ly Limbo limbo *.b Linker Script linker-script *.ld, ld.script Linux Kernel Module linux-kernel-module *.mod Liquid liquid *.liquid Literate Agda literate-agda *.lagda Literate CoffeeScript literate-coffeescript, litcoffee *.litcoffee Literate Haskell literate-haskell, lhaskell, lhs *.lhs LiveScript livescript, live-script, ls *.ls, Slakefile Logos logos *.xm Logtalk logtalk *.lgt LookML lookml *.lookml LoomScript loomscript *.ls Lua lua *.lua, .luacheckrc M m, mumps *.mumps M4 m4 *.m4 M4Sugar m4sugar, autoconf *.m4, configure.ac MATLAB matlab, octave *.matlab MAXScript maxscript *.ms MLIR mlir *.mlir MQL4 mql4 *.mq4 MQL5 mql5 *.mq5 MTML mtml *.mtml MUF muf *.muf Macaulay2 macaulay2, m2 *.m2 Makefile makefile, bsdmake, make, mf *.mak, BSDmakefile Mako mako *.mako Markdown markdown, pandoc *.md, contents.lr Marko marko, markojs *.marko Mask mask *.mask Mathematica mathematica, mma *.mathematica Maven POM maven-pom pom.xml Max max, max/msp, maxmsp *.maxpat MediaWiki mediawiki *.mediawiki Mercury mercury *.m Meson meson meson.build Metal metal *.metal Microsoft Developer Studio Project microsoft-developer-studio-project *.dsp MiniD minid *.minid Mirah mirah *.druby Modelica modelica *.mo Modula-2 modula-2 *.mod Modula-3 modula-3 *.i3 Module Management System module-management-system *.mms, descrip.mmk Monkey monkey *.monkey Moocode moocode *.moo MoonScript moonscript *.moon Motorola 68K Assembly motorola-68k-assembly, m68k *.asm Muse muse, amusewiki *.muse Myghty myghty *.myt NASL nasl *.nasl NCL ncl *.ncl NEON neon, ne-on *.neon NL nl *.nl NPM Config npm-config, npmrc .npmrc NSIS nsis *.nsi Nearley nearley *.ne Nemerle nemerle *.n NetLinx netlinx *.axs NetLinx+ERB netlinx+erb *.axs.erb NetLogo netlogo *.nlogo NewLisp newlisp *.nl Nextflow nextflow *.nf, nextflow.config Nginx nginx *.nginxconf, nginx.conf Nim nim *.nim, nim.cfg Ninja ninja *.ninja Nit nit *.nit Nix nix, nixos *.nix Nu nu, nush *.nu, Nukefile NumPy numpy *.numpy OCaml ocaml *.ml ObjDump objdump *.objdump Object Data Instance Notation object-data-instance-notation *.odin ObjectScript objectscript *.cls Objective-C objective-c, obj-c, objc, objectivec *.m Objective-C++ objective-c++, obj-c++, objc++, objectivec++ *.mm Objective-J objective-j, obj-j, objectivej, objj *.j Odin odin, odinlang, odin-lang *.odin Omgrofl omgrofl *.omgrofl Opa opa *.opa Opal opal *.opal Open Policy Agent open-policy-agent *.rego OpenCL opencl *.cl OpenEdge ABL openedge-abl, progress, openedge, abl *.p OpenQASM openqasm *.qasm OpenRC runscript openrc-runscript, openrc OpenSCAD openscad *.scad OpenStep Property List openstep-property-list *.plist OpenType Feature File opentype-feature-file, AFDKO *.fea Org org *.org Ox ox *.ox Oxygene oxygene *.oxygene Oz oz *.oz P4 p4 *.p4 PHP php, inc *.php, .php PLSQL plsql *.pls PLpgSQL plpgsql *.pgsql POV-Ray SDL pov-ray-sdl, pov-ray, povray *.pov Pan pan *.pan Papyrus papyrus *.psc Parrot parrot *.parrot Parrot Assembly parrot-assembly, pasm *.pasm Parrot Internal Representation parrot-internal-representation, pir *.pir Pascal pascal *.pas Pawn pawn *.pwn Pep8 pep8 *.pep Perl perl, cperl *.pl, Makefile.PL Pic pic *.pic Pickle pickle *.pkl PicoLisp picolisp *.l PigLatin piglatin *.pig Pike pike *.pike PlantUML plantuml *.puml Pod pod *.pod Pod 6 pod-6 *.pod PogoScript pogoscript *.pogo Pony pony *.pony PostCSS postcss *.pcss PostScript postscript, postscr *.ps PowerBuilder powerbuilder *.pbt PowerShell powershell, posh, pwsh *.ps1 Prisma prisma *.prisma Processing processing *.pde Proguard proguard *.pro Prolog prolog *.pl Propeller Spin propeller-spin *.spin Protocol Buffer protocol-buffer, protobuf *.proto Public Key public-key *.asc Pug pug *.jade Puppet puppet *.pp, Modulefile Pure Data pure-data *.pd PureBasic purebasic *.pb PureScript purescript *.purs Python python, python3, rusthon *.py, .gclient Python console python-console, pycon Python traceback python-traceback *.pytb QML qml *.qml QMake qmake *.pro Quake quake m3makefile R r, R, Rscript, splus *.r, .Rprofile RAML raml *.raml RDoc rdoc *.rdoc REALbasic realbasic *.rbbas REXX rexx, arexx *.rexx RHTML rhtml, html+ruby *.rhtml RMarkdown rmarkdown *.rmd RPC rpc, rpcgen, oncrpc, xdr *.x RPM Spec rpm-spec, specfile *.spec RUNOFF runoff *.rnh Racket racket *.rkt Ragel ragel, ragel-rb, ragel-ruby *.rl Raku raku, perl6, perl-6 *.6pl Rascal rascal *.rsc Raw token data raw-token-data, raw *.raw Readline Config readline-config, inputrc, readline .inputrc Reason reason *.re Rebol rebol *.reb Red red, red/system *.red Redcode redcode *.cw Regular Expression regular-expression, regexp, regex *.regexp Ren’Py ren’py, renpy *.rpy RenderScript renderscript *.rs Rich Text Format rich-text-format *.rtf Ring ring *.ring Riot riot *.riot RobotFramework robotframework *.robot Roff roff, groff, mdoc, nroff, troff *.roff, eqnrc Roff Manpage roff-manpage *.1 Rouge rouge *.rg Ruby ruby, jruby, macruby, rake, rb, rbx *.rb, .irbrc Rust rust *.rs SAS sas *.sas SCSS scss *.scss SMT smt *.smt2 SPARQL sparql *.sparql SQF sqf *.sqf SQL sql *.sql SQLPL sqlpl *.sql SRecode Template srecode-template *.srt SSH Config ssh-config ssh-config STON ston *.ston SVG svg *.svg SWIG swig *.i Sage sage *.sage SaltStack saltstack, saltstate, salt *.sls Sass sass *.sass Scala scala *.scala Scaml scaml *.scaml Scheme scheme *.scm Scilab scilab *.sci Self self *.self ShaderLab shaderlab *.shader Shell shell, sh, shell-script, bash, zsh *.sh, .bash_aliases ShellSession shellsession, console *.sh-session Shen shen *.shen Sieve sieve *.sieve Slash slash *.sl Slice slice *.ice Slim slim *.slim SmPL smpl, coccinelle *.cocci Smali smali *.smali Smalltalk smalltalk, squeak *.st Smarty smarty *.tpl Solidity solidity SourcePawn sourcepawn, sourcemod *.sp Spline Font Database spline-font-database *.sfd Squirrel squirrel *.nut Stan stan *.stan Standard ML standard-ml, sml *.ML Starlark starlark, bazel, bzl *.bzl, BUCK Stata stata *.do Stylus stylus *.styl SubRip Text subrip-text *.srt SugarSS sugarss *.sss SuperCollider supercollider *.sc Svelte svelte *.svelte Swift swift *.swift SystemVerilog systemverilog *.sv TI Program ti-program *.8xp TLA tla *.tla TOML toml *.toml, Cargo.lock TSQL tsql *.sql TSX tsx *.tsx TXL txl *.txl Tcl tcl *.tcl, owh Tcsh tcsh *.tcsh TeX tex, latex *.tex Tea tea *.tea Terra terra *.t Texinfo texinfo *.texinfo Text text, fundamental *.txt, COPYING Textile textile *.textile Thrift thrift *.thrift Turing turing *.t Turtle turtle *.ttl Twig twig *.twig Type Language type-language, tl *.tl TypeScript typescript, ts *.ts Unified Parallel C unified-parallel-c *.upc Unity3D Asset unity3d-asset *.anim Unix Assembly unix-assembly *.s Uno uno *.uno UnrealScript unrealscript *.uc UrWeb urweb, Ur/Web, Ur *.ur V v, vlang *.v VBA vba, vb6 *.bas VBScript vbscript *.vbs VCL vcl *.vcl VHDL vhdl *.vhdl Vala vala *.vala Verilog verilog *.v Vim Snippet vim-snippet, SnipMate, UltiSnip, NeoSnippet *.snip Vim script vim-script, vim, viml, nvim *.vim, .gvimrc Visual Basic .NET vbnet, vb.net *.vb Volt volt *.volt Vue vue *.vue Wavefront Material wavefront-material *.mtl Wavefront Object wavefront-object *.obj Web Ontology Language web-ontology-language *.owl WebAssembly webassembly, wast, wasm *.wast WebIDL webidl *.webidl WebVTT webvtt *.vtt Wget Config wget-config, wgetrc .wgetrc Windows Registry Entries windows-registry-entries *.reg Wollok wollok *.wlk World of Warcraft Addon Data world-of-warcraft-addon-data *.toc X BitMap x-bitmap, xbm *.xbm X Font Directory Index x-font-directory-index encodings.dir X PixMap x-pixmap, xpm *.xpm X10 x10, xten *.x10 XC xc *.xc XCompose xcompose .XCompose XML xml, rss, xsd, wsdl *.xml, .classpath XML Property List xml-property-list *.plist XPages xpages *.xsp-config XProc xproc *.xpl XQuery xquery *.xquery XS xs *.xs XSLT xslt, xsl *.xslt Xojo xojo *.xojo_code Xtend xtend *.xtend YAML yaml, yml *.yml, .clang-format YANG yang *.yang YARA yara *.yar YASnippet yasnippet, snippet, yas *.yasnippet Yacc yacc *.y ZAP zap *.zap ZIL zil *.zil Zeek zeek, bro *.zeek ZenScript zenscript *.zs Zephir zephir *.zep Zig zig *.zig Zimpl zimpl *.zimpl cURL Config curl-config, curlrc .curlrc desktop desktop *.desktop dircolors dircolors *.dircolors, .dir_colors eC ec *.ec edn edn *.edn fish fish *.fish mIRC Script mirc-script *.mrc mcfunction mcfunction *.mcfunction mupad mupad *.mu nanorc nanorc *.nanorc, .nanorc nesC nesc *.nc ooc ooc *.ooc q q *.q reStructuredText restructuredtext, rst *.rst sed sed *.sed wdl wdl *.wdl wisp wisp *.wisp xBase xbase, advpl, clipper, foxpro *.prg","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.zoutl.cn/tags/Markdown/"}]},{"title":"使用Feign","slug":"272","date":"2021-08-12T18:56:09.000Z","updated":"2022-04-14T02:15:58.458Z","comments":true,"path":"272.html","link":"","permalink":"https://blog.zoutl.cn/272.html","excerpt":"","text":"Feign简介Feign是一个声明式的Web Service客户端，它使得编写Web Serivce客户端变得更加简单。我们只需要使用Feign来创建一个接口并用注解来配置它既可完成。它具备可插拔的注解支持，包括Feign注解和JAX-RS注解。Feign也支持可插拔的编码器和解码器。Spring Cloud为Feign增加了对Spring MVC注解的支持，还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。 使用修改公共模块项目公共模块项目名称为： microservice-common pom.xml引入Feign依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 新建StudentClientService接口（新建一个service包并存放在里面），加入@FeignClient(value = “MICROSERVICE-STUDENT”)注解定义FeignClient并指定调用的服务名称MICROSERVICE-STUDENT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.ledao.service;import com.ledao.entity.Student;import org.springframework.cloud.netflix.feign.FeignClient;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import java.util.List;/** * Student Feign接口客户端 * * @author LeDao * @company * @create 2021-08-13 3:13 */@FeignClient(value = &quot;MICROSERVICE-STUDENT&quot;)public interface StudentClientService &#123; /** * 根据id查询学生信息 * * @param id * @return */ @RequestMapping(&quot;/student/get/&#123;id&#125;&quot;) Student get(@PathVariable(&quot;id&quot;) Integer id); /** * 查询学生信息 * * @return */ @RequestMapping(&quot;/student/list&quot;) List&lt;Student&gt; list(); /** * 添加或者修改学生信息 * * @param student * @return */ @RequestMapping(&quot;/student/save&quot;) boolean save(Student student); /** * 根据id删除学生信息 * * @param id * @return */ @RequestMapping(&quot;/student/delete/&#123;id&#125;&quot;) boolean delete(@PathVariable(&quot;id&quot;) Integer id);&#125; 新建Feign消费者项目新建一个Module，命名为：microservice-student-consumer-feign-80 将microservice-student-consumer-80消费者项目的文件都复制到新建的Feign消费者项目，将pom.xml引入的依赖也全部复制过去并引入feign依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 修改启动类 启动类如果也复制了过来，就重命名为：StudentConsumerFeignApplication_80，并添加注解：@EnableFeignClients 修改Controller 因为现在用Fiegn，所以把restTemplate去掉，改成注入service，调用service方法来实现服务的调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.ledao.controller;import com.ledao.entity.Student;import com.ledao.service.StudentClientService;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestClientException;import javax.annotation.Resource;import java.util.List;/** * Feign服务消费者-学生信息控制器 * * @author LeDao * @company * @create 2021-08-11 14:48 */@RestController@RequestMapping(&quot;/student&quot;)public class StudentConsumerFeignController &#123; @Resource private StudentClientService studentClientService; /** * 添加或者修改学生信息 * * @param student * @return */ @RequestMapping(&quot;save&quot;) public boolean save(Student student) &#123; return studentClientService.save(student); &#125; /** * 查询所有学生信息 * * @return */ @SuppressWarnings(&quot;unchecked&quot;) @RequestMapping(&quot;/list&quot;) public List&lt;Student&gt; list() &#123; return studentClientService.list(); &#125; /** * 根据id查询学生信息 * * @param id * @return */ @RequestMapping(&quot;/get/&#123;id&#125;&quot;) public Student get(@PathVariable(&quot;id&quot;) Integer id) &#123; return studentClientService.get(id); &#125; /** * 根据id删除学生信息 * * @param id * @return */ @RequestMapping(&quot;/delete/&#123;id&#125;&quot;) public boolean delete(@PathVariable(&quot;id&quot;) Integer id) &#123; try &#123; studentClientService.delete(id); return true; &#125; catch (RestClientException e) &#123; return false; &#125; &#125;&#125; 运行启动三个Eureka服务注册中心和三个提供者服务，再启动上面新建的Feign消费者项目，然后浏览器地址栏输入：http://localhost/student/list ，如果看到返回的学生列表说明Feign配置成功","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Feign","slug":"Feign","permalink":"https://blog.zoutl.cn/tags/Feign/"}]},{"title":"Ribbon策略","slug":"271","date":"2021-08-11T17:53:57.000Z","updated":"2022-04-14T02:15:54.949Z","comments":true,"path":"271.html","link":"","permalink":"https://blog.zoutl.cn/271.html","excerpt":"","text":"说明Ribbon默认的策略是轮询策略，这种默认的轮询策略肯定是不能满足实际需求的，比如有3个服务提供者，突然挂了一个，这样的话，默认轮询 ，总有1/3的概率访问失败，会出现下面的错误，所以需要选择合适的策略 策略大全 策略名 策略声明 策略描述 实现说明 BestAvailableRule public class BestAvailableRule extends ClientConfigEnabledRoundRobinRule 选择一个最小的并发请求的server 逐个考察Server，如果Server被tripped了，则忽略，在选择其中ActiveRequestsCount最小的server AvailabilityFilteringRule public class AvailabilityFilteringRule extends PredicateBasedRule 过滤掉那些因为一直连接失败的被标记为circuit tripped的后端server，并过滤掉那些高并发的的后端server（active connections 超过配置的阈值） 使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个server的运行状态 WeightedResponseTimeRule public class WeightedResponseTimeRule extends RoundRobinRule 根据响应时间分配一个weight，响应时间越长，weight越小，被选中的可能性越低。 一个后台线程定期的从status里面读取评价响应时间，为每个server计算一个weight。Weight的计算也比较简单responsetime 减去每个server自己平均的responsetime是server的权重。当刚开始运行，没有形成status时，使用roubine策略选择server。 RetryRule public class RetryRule extends AbstractLoadBalancerRule 对选定的负载均衡策略机上重试机制。 在一个配置时间段内当选择server不成功，则一直尝试使用subRule的方式选择一个可用的server RoundRobinRule public class RoundRobinRule extends AbstractLoadBalancerRule roundRobin方式轮询选择server 轮询index，选择index对应位置的server RandomRule public class RandomRule extends AbstractLoadBalancerRule 随机选择一个server 在index上随机，选择index对应位置的server ZoneAvoidanceRule public class ZoneAvoidanceRule extends PredicateBasedRule 复合判断server所在区域的性能和server的可用性选择server 使用ZoneAvoidancePredicate和AvailabilityPredicate来判断是否选择某个server，前一个判断判定一个zone的运行性能是否可用，剔除不可用的zone（的所有server），AvailabilityPredicate用于过滤掉连接数过多的Server。 使用策略在服务消费端 SpringCloudConfig 配置类自定义策略，用IRule实现，以实现RetryRule策略为例： 123456789/** * 自定义轮询算法 * * @return */@Beanpublic IRule myRule() &#123; return new RetryRule();&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://blog.zoutl.cn/tags/Ribbon/"}]},{"title":"Ribbon负载均衡","slug":"270","date":"2021-08-11T16:12:50.000Z","updated":"2022-04-14T02:15:52.925Z","comments":true,"path":"270.html","link":"","permalink":"https://blog.zoutl.cn/270.html","excerpt":"","text":"新建Module新建两个Module，一个名称为：microservice-student-provider-1002，另一个名称为：microservice-student-provider-1003，通过三个服务提供者实现集群，然后才能演示负载均衡，以及负载均衡策略 复制文件pom.xml，application.yml，以及java类都复制一份，启动类名称对应Module的名称的数字进行修改 yml配置文件有两处要修改：port端口和服务实例名称对应Module的名称的数字进行修改 修改代码为了方便查看具体执行了哪个服务提供者，在三个服务提供者的StudentProviderController的list方法中添加一条打印语句，打印语句的数字对应Module的名称的数字进行修改 测试先启动三个eureka集群，再启动三个服务提供者集群 测试服务提供者： http://localhost:1001/student/list http://localhost:1002/student/list http://localhost:1003/student/list 测试下Eureka： http://eureka2001.ledao.com:2001/ http://eureka2002.ledao.com:2002/ http://eureka2003.ledao.com:2003/ 启动服务消费者： http://localhost/student/list 每刷新一次页面，就消费一次服务，消费了哪个服务就在该服务的控制台打印下面语句","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://blog.zoutl.cn/tags/Ribbon/"}]},{"title":"Ribbon调用服务","slug":"269","date":"2021-08-11T15:00:14.000Z","updated":"2022-04-14T02:15:49.992Z","comments":true,"path":"269.html","link":"","permalink":"https://blog.zoutl.cn/269.html","excerpt":"","text":"Ribbon简介Ribbon是Netflix发布的负载均衡器，它有助于控制HTTP和TCP的客户端的行为。为Ribbon配置服务提供者地址后，Ribbon就可基于某种负载均衡算法，自动地帮助服务消费者去请求。Ribbon默认为我们提供了很多负载均衡算法，例如轮询、随机等。当然，我们也可为Ribbon实现自定义的负载均衡算法。 在Spring Cloud中，当Ribbon与Eureka配合使用时，Ribbon可自动从Eureka Server获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例。下图展示了Ribbon与Eureka配合使用时的架构。 实现过程我们修改microservice-student-consumer-80子模块项目 引入依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 修改application.yml添加下面内容： 12345eureka: client: register-with-eureka: false #false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务，所以也设置为false service-url: defaultZone: http://eureka2001.ledao.com:2001/eureka/,http://eureka2002.ledao.com:2002/eureka/,http://eureka2003.ledao.com:2003/eureka/ 添加@LoadBalanced注解SpringCloudConfig.java的getRestTemplate()方法上添加@LoadBalanced注解（负载均衡配置） 12345678910111213141516171819202122232425262728package com.ledao.config;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * SpringCloud相关配置 * * @author LeDao * @company * @create 2021-08-11 14:46 */@Configurationpublic class SpringCloudConfig &#123; /** * 调用服务模版 * * @return */ @Bean @LoadBalanced public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 添加注解@EnableEurekaClient因为和eureka整合，所以启动类StudentConsumerApplication_80 加个注解 @EnableEurekaClient 指定应用名称在服务提供者microservice-student-provider-1001的application.yml以下配置（microservice-student为微服务应用名称） 12application: name: microservice-student 在spring配置下添加，完整spring配置如下： 1234567891011121314# 数据源配置spring: application: name: microservice-student datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: true 修改PRE_HOST修改服务消费者子模块项目的StudentConsumerController.java中的PRE_HOST为 http://MICROSERVICE-STUDENT 1private static final String PRE_HOST = &quot;http://MICROSERVICE-STUDENT&quot;; 测试依次运行microservice-eureka-server-2001、microservice-eureka-server-2002、microservice-eureka-server-2003、microservice-student-provider-1001、microservice-student-consumer-80子模块项目 浏览器地址栏输入：http://localhost/student/list ，出现下面结果说明调用服务成功（下面是格式化过的JSON串）","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://blog.zoutl.cn/tags/Eureka/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://blog.zoutl.cn/tags/Ribbon/"}]},{"title":"Eureka注册中心高可用集群配置","slug":"268","date":"2021-08-11T13:28:51.000Z","updated":"2022-04-14T02:15:47.409Z","comments":true,"path":"268.html","link":"","permalink":"https://blog.zoutl.cn/268.html","excerpt":"","text":"作用当注册中心扛不住高并发时，就需要集群了 新建Module新建两个Module，一个名称为：microservice-eureka-server-2002，另一个名称为：microservice-eureka-server-2003 继承依赖在新建的两个Module的pom.xml中添加： 123456&lt;!--继承microservice依赖版本--&gt;&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 添加依赖在新建的两个Module的pom.xml中添加： 1234567891011121314&lt;!--Eureka服务--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 修改后立即生效，热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 添加启动类在新建的两个Module都添加启动类，名称分别为：EurekaServerApplication_2002和EurekaServerApplication_2003，可以直接复制EurekaServerApplication_2001.java的内容然后修改名称即可 123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * Eureka服务启动类 * * @author LeDao * @company * @create 2021-08-11 16:29 */@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication_2001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication_2001.class, args); &#125;&#125; 配置本机host前面单机的时候 eureka注册中心实例名称 是localhost，现在是集群，不能三个实例都是localhost，这里复杂的办法是搞三个虚拟机，比较麻烦，这里有简单办法，直接配置本机hosts，来实现本机域名映射； 找到 C:\\Windows\\System32\\drivers\\etc 打开hosts，加配置： 123127.0.0.1 eureka2001.ledao.com127.0.0.1 eureka2002.ledao.com127.0.0.1 eureka2003.ledao.com 修改application.yml修改三个项目的application.yml文件，主要是修改 hostname和defaultZone microservice-eureka-server-2001的application.yml 1234567891011121314server: port: 2001 context-path: /eureka: instance: # hostname: localhost #eureka注册中心实例名称 单机 hostname: eureka2001.ledao.com # 集群 client: register-with-eureka: false #false 由于该应用为注册中心，所以设置为false,代表不向注册中心注册自己。 fetch-registry: false #false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务，所以也设置为false service-url: defaultZone: http://eureka2002.ledao.com:2002/eureka/,http://eureka2003.ledao.com:2003/eureka/ # 集群 #单机defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka注册中心交互的地址，查询服务和注册服务用到 microservice-eureka-server-2002的application.yml 1234567891011121314server: port: 2002 context-path: /eureka: instance: # hostname: localhost #eureka注册中心实例名称 单机 hostname: eureka2002.ledao.com # 集群 client: register-with-eureka: false #false 由于该应用为注册中心，所以设置为false,代表不向注册中心注册自己。 fetch-registry: false #false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务，所以也设置为false service-url: defaultZone: http://eureka2001.ledao.com:2001/eureka/,http://eureka2003.ledao.com:2003/eureka/ # 集群 #单机defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka注册中心交互的地址，查询服务和注册服务用到 microservice-eureka-server-2003的application.yml 1234567891011121314server: port: 2003 context-path: /eureka: instance: # hostname: localhost #eureka注册中心实例名称 单机 hostname: eureka2003.ledao.com # 集群 client: register-with-eureka: false #false 由于该应用为注册中心，所以设置为false,代表不向注册中心注册自己。 fetch-registry: false #false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务，所以也设置为false service-url: defaultZone: http://eureka2002.ledao.com:2002/eureka/,http://eureka2003.ledao.com:2003/eureka/ # 集群 #单机defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka注册中心交互的地址，查询服务和注册服务用到 服务提供者项目microservice-student-provider-1001的application.yml，主要修改eureka.client.service-url.defaultZone 12345678910111213141516171819202122232425262728293031323334server: port: 1001 context-path: /# 数据源配置spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: trueeureka: instance: hostname: localhost #eureka客户端主机实例名称 appname: microservice-student #客户端服务名 instance-id: microservice-student:1001 #客户端实例名称 prefer-ip-address: true #显示IP client: service-url: # defaultZone: http://localhost:2001/eureka #把服务注册到eureka注册中心 #单机 defaultZone: http://eureka2001.ledao.com:2001/eureka/,http://eureka2002.ledao.com:2002/eureka/,http://eureka2003.ledao.com:2003/eureka/ # 集群info: current.groupId: @project.groupId@ current.artifactId: @project.artifactId@ current.version: @project.version@ parent.artifactId: @project.parent.artifactId@ 负责人: 张三 联系电话: 110 测试运行microservice-eureka-server-2001、microservice-eureka-server-2002、microservice-eureka-server-2003和microservice-student-provider-1001四个项目后开始测试 下面三个链接都可以测试 http://eureka2001.ledao.com:2001/ http://eureka2002.ledao.com:2002/ http://eureka2003.ledao.com:2003/ 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://blog.zoutl.cn/tags/Eureka/"}]},{"title":"服务提供者注册到Eureka","slug":"267","date":"2021-08-11T11:49:22.000Z","updated":"2022-04-14T02:15:45.362Z","comments":true,"path":"267.html","link":"","permalink":"https://blog.zoutl.cn/267.html","excerpt":"","text":"在microservice-student-provider-1001子模块项目的基础上修改 修改pom.xml加上eureka客户端依赖 123456789&lt;!--eureka客户端依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 修改application.yml直接添加下面代码 123456789eureka: instance: hostname: localhost #eureka客户端主机实例名称 appname: microservice-student #客户端服务名 instance-id: microservice-student:1001 #客户端实例名称 prefer-ip-address: true #显示IP client: service-url: defaultZone: http://localhost:2001/eureka #把服务注册到eureka注册中心 在启动类加上@EnableEurekaClient注解 1234567891011121314151617181920212223package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.domain.EntityScan;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * 服务提供者启动类 * * @author LeDao * @company * @create 2021-08-11 14:01 */@EnableEurekaClient@SpringBootApplication@EntityScan(&quot;com/ledao/entity&quot;)public class StudentProviderApplication_1001 &#123; public static void main(String[] args) &#123; SpringApplication.run(StudentProviderApplication_1001.class, args); &#125;&#125; 测试分别启动microservice-student-provider-1001和microservice-eureka-server-2001子模块项目 浏览器地址栏输入 http://localhost:2001/ ，Eureka服务注册中心出现了划红线处的服务 配置info信息作用点击上图的划红线处的链接可以查看一些信息，比如：该服务的groupId、artifactId、version，继承的artifactId、该服务的负责人和电话 配置过程在服务提供者项目pom.xml里加入actuator监控依赖： 12345&lt;!-- actuator监控引入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 在父项目pom.xml里的build节点加入： 123456&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt; 在服务提供者项目application.yml加上info配置： 1234567info: current.groupId: @project.groupId@ current.artifactId: @project.artifactId@ current.version: @project.version@ parent.artifactId: @project.parent.artifactId@ 负责人: 张三 联系电话: 110 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://blog.zoutl.cn/tags/Eureka/"}]},{"title":"搭建Eureka服务注册中心","slug":"266","date":"2021-08-11T09:57:41.000Z","updated":"2022-04-14T02:15:42.612Z","comments":true,"path":"266.html","link":"","permalink":"https://blog.zoutl.cn/266.html","excerpt":"","text":"新建Module该Module为Maven项目，命名为microservice-eureka-server-2001 修改pom.xml1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!--继承microservice依赖版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;name&gt;microservice-eureka-server-2001&lt;/name&gt; &lt;artifactId&gt;microservice-eureka-server-2001&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--Eureka服务--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置在resources中新建application.yml 123456789101112server: port: 2001 context-path: /eureka: instance: hostname: localhost #eureka注册中心实例名称 client: register-with-eureka: false #false 由于该应用为注册中心，所以设置为false,代表不向注册中心注册自己。 fetch-registry: false #false 由于注册中心的职责就是维护服务实例，它并不需要去检索服务，所以也设置为false service-url: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ #设置与Eureka注册中心交互的地址，查询服务和注册服务用到 Eureka服务启动类123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * Eureka服务启动类 * * @author LeDao * @company * @create 2021-08-11 16:29 */@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication_2001 &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication_2001.class, args); &#125;&#125; 运行运行Eureka服务启动类后，在浏览器地址栏输入：http://localhost:2001/","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://blog.zoutl.cn/tags/Eureka/"}]},{"title":"Spring Cloud搭建服务消费者项目","slug":"265","date":"2021-08-11T09:41:13.000Z","updated":"2022-04-14T02:15:39.032Z","comments":true,"path":"265.html","link":"","permalink":"https://blog.zoutl.cn/265.html","excerpt":"","text":"作用用于消费服务 新建Module该Module为Maven项目，命名为microservice-student-consumer-80 修改pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--继承microservice依赖版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservice-student-consumer-80&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;microservice-student-consumer-80 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入microservice-common依赖,引入后可以使用microservice-common的实体类,工具类等--&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置在resources中新建application.yml 123server: port: 80 context-path: / SpringCloud相关配置1234567891011121314151617181920212223242526package com.ledao.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.client.RestTemplate;/** * SpringCloud相关配置 * * @author LeDao * @company * @create 2021-08-11 14:46 */@Configurationpublic class SpringCloudConfig &#123; /** * 调用服务模版 * * @return */ @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125; 服务消费者-学生信息控制器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.ledao.controller;import com.ledao.entity.Student;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestClientException;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;import java.util.List;/** * 服务消费者-学生信息控制器 * * @author LeDao * @company * @create 2021-08-11 14:48 */@RestController@RequestMapping(&quot;/student&quot;)public class StudentConsumerController &#123; @Resource private RestTemplate restTemplate; private static final String PRE_HOST = &quot;http://localhost:1001&quot;; /** * 添加或者修改学生信息 * * @param student * @return */ @RequestMapping(&quot;save&quot;) public boolean save(Student student) &#123; return restTemplate.postForObject(PRE_HOST + &quot;/student/save&quot;, student, Boolean.class); &#125; /** * 查询所有学生信息 * * @return */ @SuppressWarnings(&quot;unchecked&quot;) @RequestMapping(&quot;/list&quot;) public List&lt;Student&gt; list() &#123; return restTemplate.getForObject(PRE_HOST + &quot;/student/list&quot;, List.class); &#125; /** * 根据id查询学生信息 * * @param id * @return */ @RequestMapping(&quot;/get/&#123;id&#125;&quot;) public Student get(@PathVariable(&quot;id&quot;) Integer id) &#123; return restTemplate.getForObject(PRE_HOST + &quot;/student/get/&quot; + id, Student.class); &#125; /** * 根据id删除学生信息 * * @param id * @return */ @RequestMapping(&quot;/delete/&#123;id&#125;&quot;) public boolean delete(@PathVariable(&quot;id&quot;) Integer id) &#123; try &#123; restTemplate.getForObject(PRE_HOST + &quot;/student/delete/&quot; + id, Boolean.class); return true; &#125; catch (RestClientException e) &#123; return false; &#125; &#125;&#125; 服务消费者启动类123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;import org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration;/** * 服务消费者启动类 * * @author LeDao * @company * @create 2021-08-11 15:01 */@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class&#125;)public class StudentConsumerApplication_80 &#123; public static void main(String[] args) &#123; SpringApplication.run(StudentConsumerApplication_80.class, args); &#125;&#125; 结果运行服务消费者启动类后，在浏览器地址栏输入对应URL可以进行增删查改操作，端口为80，通过端口80调用端口1001的方法","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"}]},{"title":"Spring Cloud搭建服务提供者项目","slug":"264","date":"2021-08-11T09:21:28.000Z","updated":"2022-04-14T02:15:35.889Z","comments":true,"path":"264.html","link":"","permalink":"https://blog.zoutl.cn/264.html","excerpt":"","text":"作用用于提供服务 新建Module该Module为Maven项目，命名为microservice-student-provider-1001 修改pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--继承microservice依赖版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;artifactId&gt;microservice-student-provider-1001&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;microservice-student-provider-1001 Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--引入microservice-common依赖,引入后可以使用microservice-common的实体类,工具类等--&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 修改后立即生效，热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml配置在resources中新建application.yml 12345678910111213141516server: port: 1001 context-path: /# 数据源配置spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/db_springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC username: root password: 123456 jpa: hibernate: ddl-auto: update show-sql: true 学生Repository接口123456789101112131415package com.ledao.repository;import com.ledao.entity.Student;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;/** * 学生Repository接口 * * @author LeDao * @company * @create 2021-08-11 13:48 */public interface StudentRepository extends JpaRepository&lt;Student, Integer&gt;, JpaSpecificationExecutor&lt;Student&gt; &#123;&#125; 学生信息Service接口1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.ledao.service;import com.ledao.entity.Student;import java.util.List;/** * 学生信息Service接口 * * @author LeDao * @company * @create 2021-08-11 13:50 */public interface StudentService &#123; /** * 添加或者修改学生信息 * * @param student */ void save(Student student); /** * 根据id查找学生信息 * * @param id * @return */ Student findById(Integer id); /** * 查询所有学生信息 * * @return */ List&lt;Student&gt; list(); /** * 根据id删除学生信息 * * @param id */ void delete(Integer id);&#125; 学生信息Service实现类12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ledao.service.impl;import com.ledao.repository.StudentRepository;import com.ledao.service.StudentService;import com.ledao.entity.Student;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;/** * 学生信息Service实现类 * * @author LeDao * @company * @create 2021-08-11 13:52 */@Service(&quot;studentService&quot;)public class StudentServiceImpl implements StudentService &#123; @Resource private StudentRepository studentRepository; @Override public void save(Student student) &#123; studentRepository.save(student); &#125; @Override public Student findById(Integer id) &#123; return studentRepository.findOne(id); &#125; @Override public List&lt;Student&gt; list() &#123; return studentRepository.findAll(); &#125; @Override public void delete(Integer id) &#123; studentRepository.delete(id); &#125;&#125; 服务提供者-学生信息控制器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package com.ledao.controller;import com.ledao.service.StudentService;import com.ledao.entity.Student;import org.springframework.web.bind.annotation.*;import javax.annotation.Resource;import java.util.List;/** * 服务提供者-学生信息控制器 * * @author LeDao * @company * @create 2021-08-11 13:54 */@RestController@RequestMapping(&quot;/student&quot;)public class StudentProviderController &#123; @Resource private StudentService studentService; /** * 添加或者修改学生信息 * * @param student * @return */ @RequestMapping(value = &quot;/save&quot;) public boolean save(@RequestBody Student student) &#123; try &#123; studentService.save(student); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125; /** * 查询所有学生信息 * * @return */ @RequestMapping(&quot;/list&quot;) public List&lt;Student&gt; list() &#123; return studentService.list(); &#125; /** * 根据id查询学生信息 * * @param id * @return */ @RequestMapping(&quot;/get/&#123;id&#125;&quot;) public Student get(@PathVariable(&quot;id&quot;) Integer id) &#123; return studentService.findById(id); &#125; /** * 根据id删除学生信息 * * @param id * @return */ @RequestMapping(&quot;/delete/&#123;id&#125;&quot;) public boolean delete(@PathVariable(&quot;id&quot;) Integer id) &#123; try &#123; studentService.delete(id); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 服务提供者启动类123456789101112131415161718192021package com.ledao;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.domain.EntityScan;/** * 服务提供者启动类 * * @author LeDao * @company * @create 2021-08-11 14:01 */@SpringBootApplication@EntityScan(&quot;com/ledao/entity&quot;)public class StudentProviderApplication_1001 &#123; public static void main(String[] args) &#123; SpringApplication.run(StudentProviderApplication_1001.class, args); &#125;&#125; 结果运行服务提供者启动类后，在浏览器地址栏输入对应URL可以进行增删查改操作，端口为1001","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"}]},{"title":"Spring Cloud搭建公共模块项目","slug":"263","date":"2021-08-11T08:49:24.000Z","updated":"2022-04-14T02:15:32.538Z","comments":true,"path":"263.html","link":"","permalink":"https://blog.zoutl.cn/263.html","excerpt":"","text":"作用存放一些其他项目公用的东西，比如实体类，工具类等 新建Module该Module为Maven项目，命名为microservice-common 继承依赖在pom.xml文件中加入： 12345&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/parent&gt; 引入依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 修改pom.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;microservice-common&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;microservice-common Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 新建Student实体类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.ledao.entity;import javax.persistence.*;import java.io.Serializable;/** * 学生实体类 * * @author LeDao * @company * @create 2021-08-11 13:27 */@Entity@Table(name = &quot;t_student&quot;)public class Student implements Serializable &#123; private static final long serialVersionUID = 1L; /** * 编号 */ @Id @GeneratedValue private Integer id; /** * 名字 */ @Column(length = 50) private String name; /** * 年纪 */ @Column(length = 50) private String grade; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getGrade() &#123; return grade; &#125; public void setGrade(String grade) &#123; this.grade = grade; &#125;&#125; 新建数据库新建一个名为db_springcloud的数据库，不需要添加表，jpa会根据实体类自动生成","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"}]},{"title":"Spring Cloud搭建父项目","slug":"262","date":"2021-08-11T08:31:22.000Z","updated":"2022-04-14T02:15:29.224Z","comments":true,"path":"262.html","link":"","permalink":"https://blog.zoutl.cn/262.html","excerpt":"","text":"新建项目新建一个名称为SpringCloud普通项目，删除src文件夹 新建ModuleModule 概述在SpringCloud下新建一个Module Maven项目，名称为microservice，删除src文件夹，用于管理依赖版本，pom.xml文件的packaging节点修改为pom 1&lt;packaging&gt;pom&lt;/packaging&gt; 修改pom.xml引入Spring Cloud、Spring Boot、连接池依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;microservice&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;microservice Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;druid.version&gt;1.1.10&lt;/druid.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--Spring Cloud--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Edgware.SR4&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--Spring Boot--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.13.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!--连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"}]},{"title":"Dubbo服务集群实现负载均衡","slug":"261","date":"2021-08-10T12:38:33.000Z","updated":"2022-04-14T02:15:25.692Z","comments":true,"path":"261.html","link":"","permalink":"https://blog.zoutl.cn/261.html","excerpt":"","text":"作用当某个服务并发量特别大的时候，一个服务延迟太高，我们就需要进行服务集群，例如某个项目一天注册量10万，这个注册功能就必须要进行集群了，否则一个服务无法应付这么大的并发量 企业级项目多个服务集群，每个服务都放不同机器，不仅能实现负载均衡，也能进行容错；就算一个机器挂了，其他机器可以继续服务 多个服务也提供权重设置，来动态设置请求分发量 实现方法dubbo的服务集群很简单，只需要配置文件里改个端口即可，其他代码不需要动 代码实现在之前Provider子模块项目的基础上，直接修改dubbo-demo-provider.xml的端口号即可（端口号只要不被占用即可，不需要和本文章的端口号一样） 12&lt;!--使用dubbo协议在20880端口暴露服务--&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; 修改后： 12&lt;!--使用dubbo协议在20881端口暴露服务--&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt; 上面的教程已经实现了服务集群，下面的教程只是为了可以更直观看到结果 为了可以更直观看到结果，我不直接修改dubbo-demo-provider.xml的端口号，而是新建三个文件：DemoProviderServiceImpl2.java、dubbo-demo-provider2.xml、ProviderTest2.java（路径和原来的文件一样），执行ProviderTest.java和ProviderTest2.java会分别发布两个Dubbo服务：一个端口为20880，另一个端口为20881，三个文件的代码如下： dubbo-demo-provider2.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--提供方应用名称, 用于计算依赖关系--&gt; &lt;dubbo:application name=&quot;demo-provider&quot;/&gt; &lt;!--使用zookeeper注册中心暴露服务地址--&gt; &lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt; &lt;!--使用dubbo协议在20881端口暴露服务--&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt; &lt;!--service实现类作为本地的一个bean--&gt; &lt;bean id=&quot;demoProviderService&quot; class=&quot;service.impl.DemoProviderServiceImpl2&quot;/&gt; &lt;!--声明需要暴露的服务接口--&gt; &lt;dubbo:service interface=&quot;service.DemoProviderService&quot; ref=&quot;demoProviderService&quot;/&gt;&lt;/beans&gt; DemoProviderServiceImpl2.java 123456789101112131415161718package service.impl;import service.DemoProviderService;/** * 服务提供者接口实现类 * * @author LeDao * @company * @create 2021-08-10 2:54 */public class DemoProviderServiceImpl2 implements DemoProviderService &#123; @Override public String sayHello(String name) &#123; return &quot;服务员（端口：20881）&quot; + name; &#125;&#125; ProviderTest2.java 1234567891011121314151617181920212223import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * @author LeDao * @company * @create 2021-08-10 2:55 */public class ProviderTest2 &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;dubbo-demo-provider2.xml&quot;); context.start(); System.out.println(&quot;服务提供者注册成功（端口：20881）&quot;); try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; context.close(); &#125;&#125; 结果分别执行ProviderTest.java和ProviderTest2.java后 执行Consumer子模块的ConsumerTest.java后，会有两个结果（因为有两个提供者的服务，消费某个服务的概率为该服务的权重/所有服务的总权重，所以要提高某个服务被消费的概率就提高该服务的权重即可）","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://blog.zoutl.cn/tags/Dubbo/"}]},{"title":"Dubbo抽取服务提供者和消费者的共同接口","slug":"260","date":"2021-08-10T06:25:12.000Z","updated":"2022-04-14T02:15:23.899Z","comments":true,"path":"260.html","link":"","permalink":"https://blog.zoutl.cn/260.html","excerpt":"","text":"抽取原因抽取前需要在服务提供者以及消费者模块中分别定义一次接口，抽取后只需要定义一次即可，可以提高开发的效率 新建模块新建一个子模块项目存放接口，我命令为Api 创建接口在java文件夹中新建service文件夹，再创建一个接口，该接口和服务提供者以及消费者的接口路径、名称要一样 删除接口然后删除掉服务提供者和消费者的接口，删除后服务提供者以及消费者会报错 引入存放接口模块的依赖引入的依赖路径在Api模块的pom.xml，如下图： 在服务提供者以及消费者pom.xml的dependencies节点中引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 至此，共同接口抽取完成","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"https://blog.zoutl.cn/tags/Dubbo/"}]},{"title":"Maven出现错误：\"Parent, please verify your project structure\"的解决办法","slug":"259","date":"2021-08-10T06:12:30.000Z","updated":"2022-04-14T02:15:20.560Z","comments":true,"path":"259.html","link":"","permalink":"https://blog.zoutl.cn/259.html","excerpt":"","text":"问题该错误出现在使用parent节点继承其它模块的依赖版本号时 解决方法在parent节点加入&lt;relativePath/&gt;，完整parent节点如下： 123456&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"}]},{"title":"Maven使用parent统一管理依赖版本","slug":"258","date":"2021-08-10T04:43:04.000Z","updated":"2022-04-14T02:15:18.659Z","comments":true,"path":"258.html","link":"","permalink":"https://blog.zoutl.cn/258.html","excerpt":"","text":"新建子模块新建一个Maven子模块并命名为Parent，不需要勾选Create from archetype，删除src文件夹 添加节点添加一个dependencyManagement节点，在dependencyManagement节点内添加dependencies节点，并在dependencies节点内添加依赖 123456&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; pom.xml如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Parent Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.0.35.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 统一管理版本在properties节点内管理依赖版本，修改后的pom.xml如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;Parent Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;!--依赖版本管理--&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;Api.version&gt;1.0-SNAPSHOT&lt;/Api.version&gt; &lt;dubbo.version&gt;2.6.0&lt;/dubbo.version&gt; &lt;zkclient.version&gt;0.10&lt;/zkclient.version&gt; &lt;curator-framework.version&gt;4.0.1&lt;/curator-framework.version&gt; &lt;fastjson.version&gt;1.2.46&lt;/fastjson.version&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;slf4j-api.version&gt;1.7.25&lt;/slf4j-api.version&gt; &lt;commons-lang3.version&gt;3.4&lt;/commons-lang3.version&gt; &lt;netty-all.version&gt;4.0.35.Final&lt;/netty-all.version&gt; &lt;/properties&gt; &lt;!--依赖管理--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Api&lt;/artifactId&gt; &lt;version&gt;$&#123;Api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;$&#123;curator-framework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j-api.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang3.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;$&#123;netty-all.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 其它模块继承使用parent节点继承，节点内填要继承的模块依赖引用路径，Parent模块的引用路径如下： 123&lt;groupId&gt;org.example&lt;/groupId&gt;&lt;artifactId&gt;Parent&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 完整parent节点及其代码 123456&lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt; 继承的模块也需要引入依赖，但是不需要引入版本号，版本号由继承得到，完整pom.xml如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Parent&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;artifactId&gt;Provider&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;Provider Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project&#x27;s website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;Api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"}]},{"title":"IntelliJ IDEA创建Maven多模块项目","slug":"257","date":"2021-08-10T04:17:04.000Z","updated":"2022-04-14T02:44:59.320Z","comments":true,"path":"257.html","link":"","permalink":"https://blog.zoutl.cn/257.html","excerpt":"","text":"前提已经创建好一个Maven项目（在创建这个项目时不需要勾选Create from archetype），可以直接删除它的src文件夹，我们把该项目称为父模块 创建鼠标右击该父模块，选择New &gt;&gt; Module，然后像新建项目那样操作即可 结果","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"消费Dubbo服务","slug":"256","date":"2021-08-09T18:11:15.000Z","updated":"2022-04-14T02:15:05.736Z","comments":true,"path":"256.html","link":"","permalink":"https://blog.zoutl.cn/256.html","excerpt":"","text":"新建一个子模块项目名称为Consumer 引入依赖12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.0.35.Final&lt;/version&gt;&lt;/dependency&gt; 新建dubbo-demo-consumer.xml12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=&quot;demo-consumer&quot;/&gt; &lt;!--使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt; &lt;!--生成远程服务代理，可以和本地bean一样使用demoProviderService check属性，启动的时候是否检查 一般设置为false 启动的时候不检查--&gt; &lt;dubbo:reference id=&quot;demoProviderService&quot; check=&quot;false&quot; interface=&quot;service.DemoProviderService&quot;/&gt;&lt;/beans&gt; Java代码DemoProviderService.java12345678910111213141516171819package service;/** * 服务提供者接口 * * @author LeDao * @company * @create 2021-08-10 2:02 */public interface DemoProviderService &#123; /** * 测试接口 * * @param name * @return */ String sayHello(String name);&#125; 测试代码1234567891011121314151617181920212223242526import org.springframework.context.support.ClassPathXmlApplicationContext;import service.DemoProviderService;import java.io.IOException;/** * @author LeDao * @company * @create 2021-08-10 2:03 */public class Test &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;dubbo-demo-consumer.xml&quot;); context.start(); DemoProviderService demoProviderService = (DemoProviderService) context.getBean(&quot;demoProviderService&quot;); String result = demoProviderService.sayHello(&quot;小米&quot;); System.out.println(&quot;远程调用的结果：&quot; + result); try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; context.close(); &#125;&#125; 运行结果Consumer子模块项目没有服务提供者接口的实现类，但是调用了Provider子模块项目的服务提供者接口的实现类，从而实现消费Dubbo服务","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://blog.zoutl.cn/tags/Dubbo/"}]},{"title":"发布Dubbo服务","slug":"255","date":"2021-08-09T16:04:50.000Z","updated":"2022-04-14T02:15:03.459Z","comments":true,"path":"255.html","link":"","permalink":"https://blog.zoutl.cn/255.html","excerpt":"","text":"新建项目新建一个Maven项目名称为DubboDemo，在该项目下新建一个子模块项目名称为Provider 创建java和resources文件夹 引入依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.0.35.Final&lt;/version&gt;&lt;/dependency&gt; Java代码服务提供者接口DemoProviderService.java 1234567891011121314151617package service;/** * 服务提供者接口 * * @author LeDao * @company * @create 2021-08-09 22:20 */public interface DemoProviderService &#123; /** * @param name * @return */ String sayHello(String name);&#125; 服务提供者接口实现类DemoProviderServiceImpl.java 123456789101112131415161718package service.impl;import service.DemoProviderService;/** * 服务提供者接口实现类 * * @author LeDao * @company * @create 2021-08-10 2:54 */public class DemoProviderServiceImpl implements DemoProviderService &#123; @Override public String sayHello(String name) &#123; return &quot;服务员（端口：20880）&quot; + name; &#125;&#125; 新建配置文件在resources文件夹中新建，命名为dubbo-demo-provider.xml，代码如下： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!--提供方应用名称, 用于计算依赖关系--&gt; &lt;dubbo:application name=&quot;demo-provider&quot;/&gt; &lt;!--使用zookeeper注册中心暴露服务地址--&gt; &lt;dubbo:registry address=&quot;zookeeper://localhost:2181&quot;/&gt; &lt;!--使用dubbo协议在20880端口暴露服务--&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;!--service实现类作为本地的一个bean--&gt; &lt;bean id=&quot;demoProviderService&quot; class=&quot;service.impl.DemoProviderServiceImpl&quot;/&gt; &lt;!--声明需要暴露的服务接口--&gt; &lt;dubbo:service interface=&quot;service.DemoProviderService&quot; ref=&quot;demoProviderService&quot;/&gt;&lt;/beans&gt; 测试1234567891011121314151617181920212223import org.springframework.context.support.ClassPathXmlApplicationContext;import java.io.IOException;/** * @author LeDao * @company * @create 2021-08-10 2:55 */public class ProviderTest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;dubbo-demo-provider.xml&quot;); context.start(); System.out.println(&quot;服务提供者注册成功（端口：20880）&quot;); try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; context.close(); &#125;&#125; 运行结果在Dubbo Admin控制台中查看服务，如何使用Dubbo Admin控制台查看博客：使用Dubbo Admin控制台","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://blog.zoutl.cn/tags/Dubbo/"}]},{"title":"使用Dubbo Admin控制台","slug":"254","date":"2021-08-09T15:29:59.000Z","updated":"2022-04-14T02:15:01.636Z","comments":true,"path":"254.html","link":"","permalink":"https://blog.zoutl.cn/254.html","excerpt":"","text":"下载阿里云盘链接：https://www.aliyundrive.com/s/nZaiPAfGKnq 安装安装一个Tomcat7，平时不使用，专门用来运行Dubbo Admin控制台，安装步骤 ：安装 Tomcat | LeDao 的博客 (zoutl.cn) 删除Tomcat7的安装目录webapp/ROOT文件夹中的全部文件（该ROOT文件夹为直接输入端口号时显示的Tomcat主页） 解压下载的dubbo-admin-2.6.0.war，复制解压后的所有文件到webapp/ROOT文件夹中 启动必须先启动Zookeeper，如何启动查看：Windows10 安装 ZooKeeper | LeDao 的博客 (zoutl.cn) 双击Tomcat7的安装目录bin文件夹中的startup.bat运行Tomcat7，在浏览器地址栏输入localhost:8080，输入用户名和密码，默认用户名和密码都是root 如果输入localhost:8080后出现下面图片所示的界面，说明8080端口被占用了，那么直接修改Tomcat7的默认端口，去修改Tomcat7的配置文件server.xml（在conf文件夹中） 修改前： 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改后：（我修改为8888） 123&lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 在地址栏中输入localhost:8888，输入用户名和密码，即可进入Dubbo Admin控制台","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://blog.zoutl.cn/tags/ZooKeeper/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://blog.zoutl.cn/tags/Dubbo/"}]},{"title":"IntelliJ IDEA创建Maven项目","slug":"253","date":"2021-08-09T13:59:39.000Z","updated":"2022-04-14T02:45:04.571Z","comments":true,"path":"253.html","link":"","permalink":"https://blog.zoutl.cn/253.html","excerpt":"","text":"新建 选择Maven项目、JDK版本、Maven Archetype（选maven-archetype-webapp，可以不创建后面再加入） 取名 取名以及选择项目路径 填写配置 选择本机的Maven安装路径、配置文件、仓库路径","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"CentOS7安装ZooKeeper","slug":"252","date":"2021-08-09T11:52:20.000Z","updated":"2022-04-14T02:37:25.847Z","comments":true,"path":"252.html","link":"","permalink":"https://blog.zoutl.cn/252.html","excerpt":"","text":"下载创建一个文件夹存放ZooKeeper，进入该文件夹后使用swet命令下载apache-zookeeper-3.7.0-bin.tar.gz（我的阿里云CentOS7服务器中使用wge命令） 1wget https://downloads.apache.org/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz 解压1tar -zxvf apache-zookeeper-3.7.0-bin.tar.gz 配置进入conf文件夹 1cd /root/zookeeper/apache-zookeeper-3.7.0-bin/conf/ 复制zoo_sample.cfg到当前目录，并命令为zoo.cfg 1cp zoo_sample.cfg zoo.cfg 运行进入解压后的文件夹apache-zookeeper-3.7.0-bin 启动1./bin/zkServer.sh start 查看状态查看当前状态，看到下图说明启动成功 1./bin/zkServer.sh status 也进入客户端查看运行状态，看到 Welcome to Zookeeper!说明启动成功 1./bin/zkCli.sh -server localhost:2181 停止1./bin/zkServer.sh stop","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://blog.zoutl.cn/tags/ZooKeeper/"}]},{"title":"Windows10安装ZooKeeper","slug":"251","date":"2021-08-09T09:47:15.000Z","updated":"2022-04-14T02:14:53.145Z","comments":true,"path":"251.html","link":"","permalink":"https://blog.zoutl.cn/251.html","excerpt":"","text":"下载进入ZooKeeper主页：https://zookeeper.apache.org/index.html ，点击Download进入下载页面 根据自己的需求下载对应的版本，下载第一个 点击HTTP下的下载链接 下载完的文件名中包含bin字段（从版本3.5.5开始，带有bin名称的包才是我们想要的下载可以直接使用的里面有编译后的二进制的包，而之前的普通的tar.gz的包里面是只是源码的包无法直接使用） 安装将下载好的文件解压，再解压，如果出现替换文件提示，选择全否 运行点击bin文件夹中的zkServer.cmd运行，如果出现一个cmd窗口马上就关闭，说明启动失败自动关闭窗口，这时我们需要查看错误信息，修改zkServer.cmd（在文件的最后新建一行，加上pause） 再次运行查看错误信息，从下图可以看到conf文件夹中没有zoo.cfg这个文件 将conf文件夹的zoo_sample.cfg这个文件重命名为zoo.cfg 再次启动，如果看到端口号：2181，说明启动成功","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://blog.zoutl.cn/tags/ZooKeeper/"}]},{"title":"Hexo加密文章","slug":"250","date":"2021-08-06T02:27:14.000Z","updated":"2022-04-15T16:35:40.504Z","comments":true,"path":"250.html","link":"","permalink":"https://blog.zoutl.cn/250.html","excerpt":"","text":"安装插件安装命令如下： 1npm install --save hexo-blog-encrypt 快速使用将 “password” 字段添加到文章信息头 12345---title: Hello Worlddate: 2016-03-30 21:18:02password: hello--- 执行命令：hexo clean，hexo g，hexo s 然后可以在本地预览加密的文章 高级配置可以中文化提示信息以及更多配置（也可以不配置） 在站点根目录的_config.yml文件中添加下面内容： 1234567# 加密文章encrypt: # hexo-blog-encrypt abstract: 有东西被加密了, 请输入密码查看. message: 您好, 这里需要密码. theme: xray wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试. wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容. PS.来源：https://github.com/D0n9X1n/hexo-blog-encrypt/blob/master/ReadMe.zh.md","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo隐藏文章","slug":"249","date":"2021-08-06T02:15:05.000Z","updated":"2022-04-15T16:35:48.044Z","comments":true,"path":"249.html","link":"","permalink":"https://blog.zoutl.cn/249.html","excerpt":"","text":"安装插件安装命令如下 1npm install hexo-hide-posts --save 配置插件12345678910# hexo-hide-postshide_posts: # 可以改成其他你喜欢的名字 filter: hidden # 指定你想要传递隐藏文章的位置，比如让所有隐藏文章在存档页面可见 # 常见的位置有：index, tag, category, archive, sitemap, feed, etc. # 留空则默认全部隐藏 public_generators: [] # 为隐藏的文章添加 noindex meta 标签，阻止搜索引擎收录 noindex: true 隐藏文章在文章属性Front-matter中添加hidden: true，如下： 12345678---title: hexo隐藏文章tags: hexocategories: hexoabbrlink: 49410date: 2021-08-06 10:15:05hidden: true--- PS.隐藏后可通过该文章的链接访问，可以通过 hexo hidden:list 查看已隐藏的文章 如果不想让人通过该文章的链接访问，那么我们可以加密文章，如何加密文章查看：hexo加密文章","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"修改Hexo新建博客的模板","slug":"247","date":"2021-08-05T11:46:43.000Z","updated":"2022-04-15T16:35:44.075Z","comments":true,"path":"247.html","link":"","permalink":"https://blog.zoutl.cn/247.html","excerpt":"","text":"概述通过hexo new “博客名称”命令新建博客时，默认使用的模板是post.md，该文件在站点根目录的scaffolds文件夹中，修改hexo新建博客的模板一共有两种方法： 直接修改post.md 新建自己的模板 下面以添加categories（分类）为例 直接修改post.md在文章属性Front-matter中添加categories 添加前（markdown源码） 12345---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:--- 添加后（markdown源码） 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:--- 新建自己的模板新建一个名为blog.md的模板（名称可以根据自己的需求随便取，但是不可以与当前的文件夹中的文件重名，也不可以命名为page.md，因为hexo new page “名称”命令是新建一个页面）,添加以下内容（markdown源码）： 123456---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories:--- 如果要新建博客，通过hexo new blog “博客名称”命令新建，该命令中的blog字段说明使用的是名为blog.md的模板 PS.推荐直接修改post.md 详情查看hexo官网：https://hexo.io/zh-cn/docs/writing","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Java获取随机数","slug":"246","date":"2021-08-04T12:45:33.000Z","updated":"2022-04-14T02:14:15.287Z","comments":true,"path":"246.html","link":"","permalink":"https://blog.zoutl.cn/246.html","excerpt":"","text":"System.currentTimeMillis()通过System.currentTimeMillis()来获取随机数，实际上是获取当前时间毫秒数，它是long类型 123456789101112/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; long l = System.currentTimeMillis(); System.out.println(l); &#125;&#125; Math.random()它返回的是0(包含)到1(不包含)之间的double值，如果要返回[0,100]的int整数，只需要将获得的结果乘以100再转换为int类型即可 12345678910111213141516/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; //[0,1) double d = Math.random(); System.out.println(d); //[0,100] int i = (int) (d * 100); System.out.println(i); &#125;&#125; Random.nextInt(int bound)获取[0,bound-1]的int整数 12345678910111213141516import java.util.Random;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; Random random = new Random(); //[0,99] int i = random.nextInt(100); System.out.println(i); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Hexo Next添加页脚网站运行时间","slug":"245","date":"2021-08-03T13:32:31.000Z","updated":"2022-04-15T16:35:51.696Z","comments":true,"path":"245.html","link":"","permalink":"https://blog.zoutl.cn/245.html","excerpt":"","text":"关键代码1234567891011121314151617181920212223242526272829303132333435363738&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;&lt;script language=javascript&gt; function siteTime()&#123; window.setTimeout(&quot;siteTime()&quot;, 1000); var seconds = 1000; var minutes = seconds * 60; var hours = minutes * 60; var days = hours * 24; var years = days * 365; var today = new Date(); var todayYear = today.getFullYear(); var todayMonth = today.getMonth()+1; var todayDate = today.getDate(); var todayHour = today.getHours(); var todayMinute = today.getMinutes(); var todaySecond = today.getSeconds(); /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳) year - 作为date对象的年份，为4位年份值 month - 0-11之间的整数，做为date对象的月份 day - 1-31之间的整数，做为date对象的天数 hours - 0(午夜24点)-23之间的整数，做为date对象的小时数 minutes - 0-59之间的整数，做为date对象的分钟数 seconds - 0-59之间的整数，做为date对象的秒数 microseconds - 0-999之间的整数，做为date对象的毫秒数 */ var t1 = Date.UTC(2020,02,13,15,00,00); //北京时间2018-2-13 00:00:00 var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond); var diff = t2-t1; var diffYears = Math.floor(diff/years); var diffDays = Math.floor((diff/days)-diffYears*365); var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours); var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes); var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds); document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+/*diffYears+&quot; 年 &quot;+*/diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;; &#125; siteTime();&lt;/script&gt; 在页脚文件添加文件名称为：footer.swig，文件路径：themes/next/layout/_partials/footer.swig 在哪里添加根据自己的需求而定 效果 PS.来源：https://blog.csdn.net/qq_39720594/article/details/105411030","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Gitalk显示：未找到相关的Issues进行评论","slug":"244","date":"2021-08-03T05:40:19.000Z","updated":"2022-04-15T16:35:59.060Z","comments":true,"path":"244.html","link":"","permalink":"https://blog.zoutl.cn/244.html","excerpt":"","text":"前提已经正确安装Gitalk 解决办法GitHub网站登录进入GitHub网站，登录Gitalk评论仓库的所有者账号 Gitalk登录GitHub账号进入显示未找到相关的 Issues 进行评论的网页，点击使用GitHub登录按钮，Gitalk评论仓库将自动创建一个当前网页的 Issues ，然后每进入一个显示未找到相关的 Issues 进行评论的网页，将会自动创建 Issues 结果","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo Next创建标签页","slug":"243","date":"2021-08-03T04:59:53.000Z","updated":"2022-04-15T16:36:03.985Z","comments":true,"path":"243.html","link":"","permalink":"https://blog.zoutl.cn/243.html","excerpt":"","text":"创建命令1hexo new page &quot;tags&quot; 在站点根目录下的source文件夹中会新建一个名为tags的文件夹，文件夹中有一个index.md文件 修改index.md文件1234title: date: 2021-07-29 15:03:57comments: falsetype: &quot;tags&quot; title为该页面的标题 date为创建时间 comments: false代表该页面不能评论（没有评论模块） type: “tags”代表对应文章的tags 指定文章的tags变量Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量 文章的Front-matter添加tags变量，例如：（tags变量填标签名） 123title: hexo next创建标签页date: 2021-08-03 12:59:53tags: hexo 修改主题的配置文件_config.yml在memu中添加tags，加#号会注释掉不显示 12345678910menu: 主页: / || fa fa-home #about: /about/ || fa fa-user 标签: /tags || fa fa-tags #日期: /time/ || fa fa-calendar #categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive #schedule: /schedule/ || fa fa-calendar #sitemap: /sitemap.xml || fa fa-sitemap #commonweal: /404/ || fa fa-heartbeat 结果截图","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo常用命令","slug":"242","date":"2021-08-02T16:41:37.000Z","updated":"2022-04-15T16:36:06.986Z","comments":true,"path":"242.html","link":"","permalink":"https://blog.zoutl.cn/242.html","excerpt":"","text":"hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public) 在某些情况（尤其是更换主题后），如果对站点的更改无论如何也不生效，就运行该命令。 hexo g生成静态文件 是hexo generate的简写 hexo d部署网站，同时将网站的改动提交到GitHub仓库 是hexo deploy的简写 hexo g -dhexo g和hexo d先后执行 hexo s启动服务器。默认情况下，访问网址为： http://localhost:4000/ 是hexo server的简写 hexo v显示hexo的版本 是hexo version的简写 hexo new “文章名称”新建一个文章名称.md，该文件在站点根目录的source/_post/中 hexo new page “名称”新建一个页面，这个页面在站点根目录的source/名称/中（名为index.md），可以通过/名称/访问这个页面 PS.以上都是我常用的命令，更多命令及详情查看：https://hexo.io/zh-cn/docs/commands","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo Next开启本地搜索","slug":"241","date":"2021-08-02T14:52:59.000Z","updated":"2022-04-15T16:36:12.229Z","comments":true,"path":"241.html","link":"","permalink":"https://blog.zoutl.cn/241.html","excerpt":"","text":"安装插件插件名称为：hexo-generator-search 安装命令如下： 1npm install hexo-generator-search --save 修改_config.yml修改主题的_config.yml，修改local_search的enable为true，代表启用本地搜索 1234567891011local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 6 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 修改根目录的_config.yml在根目录的_config.yml中添加以下内容 123456#本地搜索search: path: search.xml field: post format: html limit: 10000 重新部署网站后就可以使用本地搜索功能了","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo Next安装黑暗模式","slug":"240","date":"2021-08-02T01:55:08.000Z","updated":"2022-04-15T16:36:15.589Z","comments":true,"path":"240.html","link":"","permalink":"https://blog.zoutl.cn/240.html","excerpt":"","text":"next自带的黑暗模式优点配置十分简单 缺点缺少切换按钮，默认是根据系统偏好（系统是否处于暗黑模式）来决定是否启用 启用修改next的主题配置文件_config.yml的darkmode对应的值为true 12# Dark Modedarkmode: true 自己安装安装插件插件名称：hexo-next-darkmode，安装前先关闭自带的黑暗模式 1npm install hexo-next-darkmode --save 配置插件在next的主题配置文件_config.yml中添加下面内容 1234567891011121314151617# Darkmode JS# For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.jsdarkmode_js: enable: true bottom: &#x27;64px&#x27; # default: &#x27;32px&#x27; right: &#x27;unset&#x27; # default: &#x27;32px&#x27; left: &#x27;32px&#x27; # default: &#x27;unset&#x27; time: &#x27;0.5s&#x27; # default: &#x27;0.3s&#x27; mixColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27; backgroundColor: &#x27;transparent&#x27; # default: &#x27;#fff&#x27; buttonColorDark: &#x27;#100f2c&#x27; # default: &#x27;#100f2c&#x27; buttonColorLight: &#x27;#fff&#x27; # default: &#x27;#fff&#x27; isActivated: true # default false saveInCookies: true # default: true label: &#x27;🌓&#x27; # default: &#x27;&#x27; autoMatchOsTheme: true # default: true libUrl: # Set custom library cdn url for Darkmode.js 至此，黑暗模式安装完成，点击左下角的按钮即可切换黑暗模式 PS.来源：Hexo Next 8.x 主题添加可切换的暗黑模式","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"GitHub Pages绑定自定义域名","slug":"239","date":"2021-08-01T17:06:52.000Z","updated":"2022-04-15T16:36:19.379Z","comments":true,"path":"239.html","link":"","permalink":"https://blog.zoutl.cn/239.html","excerpt":"","text":"修改对应域名的主机记录下图是阿里云的修改界面，主机记录为绑定的完整域名 修改记录类型记录类型选CNAME 修改记录值记录值填GitHub Pages的访问地址（你的GitHub用户名.github.io） 新建CNAME文件GitHub仓库中新建文件内容为你要绑定的域名 取消强制HTTPS取消下图的Enforce HTTPS的勾选即可，（进入该仓库的Settings，点击左侧菜单的Pages进入下面界面） 再次新建CNAME文件最好也在hexo的根目录的source文件夹中也新建相同的文件，内容也是你要绑定的域名 这样做的原因：如果根目录没有这个文件，通过hexo d命令更新仓库时会删除掉仓库中的CNAME文件，那就又需要在仓库中新建CNAME文件 结果稍后即可通过绑定的域名访问GitHub Pages了","categories":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"GitHub连接报错：\"ssh :connect to host github.com port :22 Connection timed out\"","slug":"238","date":"2021-07-29T19:40:01.000Z","updated":"2022-04-14T01:53:34.523Z","comments":true,"path":"238.html","link":"","permalink":"https://blog.zoutl.cn/238.html","excerpt":"","text":"新建config文本在存放公钥私钥（id_rsa 和 id_rsa.pub）的文件夹里，新建config文本，内容如下： 123456Host github.comUser 注册GitHub的邮箱Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 测试连接是否成功再次执行 ssh -T git@github.com 时，会出现提示如下，回车”yes”即可","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"Git上传本地代码到GitHub","slug":"237","date":"2021-07-29T05:04:48.000Z","updated":"2022-04-14T01:52:36.392Z","comments":true,"path":"237.html","link":"","permalink":"https://blog.zoutl.cn/237.html","excerpt":"","text":"初始化仓库初始化一个 Git 仓库，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（需要进入要初始化的文件夹内部，右键点击选择Git Bash Here） 输入初始化命令： 1git init 输入命令查看当前状态：git status，文件名颜色为红色 添加到仓库中输入添加命令： 1git add . 输入命令查看当前状态：git status，文件名颜色为绿色 commit到仓库输入提交命令： 1git commit -m &quot;提交备注&quot; 输入命令查看当前状态：git status，发现没有东西可以提交 复制项目的SSH地址记得先配置GitHub的SSH Key，如何配置查看博客：GitHub配置SSH Key 将本地的仓库关联到GitHub上把上一步复制的地址放到origin后，如果已经关联过则省略本步骤 输入关联命令： 1git remote add origin SSH地址 上传代码到GitHub远程仓库输入推送命令： 1git push -u origin master 去GitHub查看结果","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"GitHub配置SSH Key","slug":"236","date":"2021-07-29T04:31:21.000Z","updated":"2022-04-14T01:53:42.875Z","comments":true,"path":"236.html","link":"","permalink":"https://blog.zoutl.cn/236.html","excerpt":"","text":"配置SSH Keys的好处在管理Git项目上，很多时候都是直接使用https url克隆到本地，当然也有有些人使用SSH url克隆到本地。 这两种方式的主要区别在于： 使用https url克隆对初学者来说会比较方便，复制https url然后到Git Bash里面直接用clone命令克隆到本地就好了，但是每次fetch和push代码都需要输入账号和密码，这也是https方式的麻烦之处。 而使用SSH url克隆却需要在克隆之前先配置和添加好SSH key，如果你想要使用SSH url将代码提交到GitHub的话，你必须是这个项目的拥有者，否则你是无法添加SSH key的。 另外SSH默认是每次fetch和push代码都不需要输入账号和密码，如果你想要每次都输入账号密码才能进行fetch和push也可以另外进行设置。 步骤打开Git命令窗口桌面上右键鼠标选择Git bash here打开Git 检查本机已存在的SSH密匙输入命令： 1cd ~/.ssh 出现 No such file or directory 说明本机没有SSH密匙，否则继续输入ls查看.ssh文件夹内的文件 1ls 如果有下面两个文件，说明本机有SSH密匙 id_rsa id_rsa.pub 创建本机的SSH密匙本机有SSH密匙则跳过本步骤 输入命令： 1ssh-keygen -t rsa -C &quot;注册Github账户时用的邮箱&quot; 连续按下回车键三次，至此本机的SSH密匙创建完成，该密钥一般存放在C盘的用户文件夹的.ssh文件夹中（我的是C:\\Users\\LeDao\\.ssh） 配置Github的SSH Key进入Github首页，点击右上角的头像选择Settings，选择左侧菜单的SSH and GPG keys，然后点击右侧的New SSH key按钮，打开上面第三步的本地密钥id_rsa.pub文件（用记事本打开并复制其内容），复制到GitHub的key文本框中，title可以随意设置 测试输入下面命令来测试是否配置成功 1ssh -T git@github.com 出现Are you sure you want to continue connecting (yes/no/[fingerprint])? 输入yes 看到Hi a6678696! You’ve successfully authenticated, but GitHub does not provide shell access. 说明配置成功","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"JustAuth实现GitHub登录","slug":"235","date":"2021-07-28T05:38:20.000Z","updated":"2022-04-14T02:14:04.199Z","comments":true,"path":"235.html","link":"","permalink":"https://blog.zoutl.cn/235.html","excerpt":"GitHub创建第三方应用具体步骤查看博客：GitHub创建第三方应用 copy以下三个信息：Client ID、Client Secret和Authorization callback URL application.yml配置12345678910server: port: 80 servlet: context-path: / tomcat: uri-encoding: utf-8spring: session: store-type: none 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;me.zhyd.oauth&lt;/groupId&gt; &lt;artifactId&gt;JustAuth&lt;/artifactId&gt; &lt;version&gt;1.16.1&lt;/version&gt;&lt;/dependency&gt;","text":"GitHub创建第三方应用具体步骤查看博客：GitHub创建第三方应用 copy以下三个信息：Client ID、Client Secret和Authorization callback URL application.yml配置12345678910server: port: 80 servlet: context-path: / tomcat: uri-encoding: utf-8spring: session: store-type: none 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;me.zhyd.oauth&lt;/groupId&gt; &lt;artifactId&gt;JustAuth&lt;/artifactId&gt; &lt;version&gt;1.16.1&lt;/version&gt;&lt;/dependency&gt; 创建Request12345AuthRequest authRequest = new AuthGithubRequest(AuthConfig.builder() .clientId(&quot;Client ID&quot;) .clientSecret(&quot;Client Secret&quot;) .redirectUri(&quot;应用回调地址&quot;) .build()); 生成授权地址1String authorizeUrl = authRequest.authorize(AuthStateUtils.createState()); 完整代码IndexController1234567891011121314151617181920212223package com.ledao.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author LeDao * @company * @create 2021-07-28 0:05 */@RestControllerpublic class IndexController &#123; @RequestMapping(&quot;/&quot;) public String root() &#123; return &quot;&lt;h2 style=&#x27;text-align: center&#x27;&gt;&lt;a href=&#x27;/oauth/login/github&#x27;&gt;github登录&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&#x27;/oauth/login/gitee&#x27;&gt;gitee登录&lt;/a&gt;&lt;/span&gt;&quot;; &#125; @RequestMapping(&quot;/home&quot;) public String home() &#123; return &quot;&lt;h1&gt;主页&lt;/h1&gt;&quot;; &#125;&#125; JustAuthControllerClient ID、Client Secret和Authorization callback URL更换为自己的,下面代码中的是错误的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687package com.ledao.controller;import me.zhyd.oauth.config.AuthConfig;import me.zhyd.oauth.model.AuthCallback;import me.zhyd.oauth.model.AuthResponse;import me.zhyd.oauth.request.AuthGiteeRequest;import me.zhyd.oauth.request.AuthGithubRequest;import me.zhyd.oauth.request.AuthRequest;import me.zhyd.oauth.utils.AuthStateUtils;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author LeDao * @company * @create 2021-07-28 0:12 */@RestController@RequestMapping(&quot;/oauth&quot;)public class JustAuthController &#123; /** * 重定向 * * @param type * @param response * @throws IOException */ @RequestMapping(&quot;/login/&#123;type&#125;&quot;) public void login(@PathVariable String type, HttpServletResponse response) throws IOException &#123; //创建request AuthRequest authRequest = getAuthRequest(type); //重定向到授权链接 response.sendRedirect(authRequest.authorize(AuthStateUtils.createState())); &#125; /** * 登录后回调 * * @param type * @param callback * @return */ @RequestMapping(&quot;/callback/&#123;type&#125;&quot;) public AuthResponse callback(@PathVariable String type, AuthCallback callback) &#123; //创建request AuthRequest authRequest = getAuthRequest(type); //登录(获取用户信息) AuthResponse authResponse = authRequest.login(callback); return authResponse; &#125; /** * 授权平台创建响应的request * * @param type * @return */ private AuthRequest getAuthRequest(String type) &#123; AuthRequest authRequest = null; switch (type) &#123; //github平台 case &quot;github&quot;: authRequest = new AuthGithubRequest(AuthConfig.builder() .clientId(&quot;803de7712b9908181&quot;) .clientSecret(&quot;e863222b3de13fe5ca91224e4651c0316e&quot;) .redirectUri(&quot;http://localhost:80/oauth/callback/github&quot;) .build()); break; //gitee平台 case &quot;gitee&quot;: authRequest = new AuthGiteeRequest(AuthConfig.builder() .clientId(&quot;e7c5c4c0cadb936b728b5d87af2ae1f2958c0a2cb24af4daa6f29a5f7&quot;) .clientSecret(&quot;823a0fd650add2468a8e31ac684b7c614b1783331c73b32bb29040&quot;) .redirectUri(&quot;http://localhost:80/oauth/callback/gitee&quot;) .build()); break; default: break; &#125; return authRequest; &#125;&#125; 结果浏览器地址栏输入：http://localhost GitHub登录返回的结果 Gitee登录返回的结果 PS.代码中包含了Gitee登录 GitHub完整代码地址：https://github.com/a6678696/JustAuthDemo 更多第三方登录教程查看：https://justauth.wiki/ 如果需要获取返回的用户信息，callback方法返回的数据类型修改为AuthResponse&lt;AuthUser&gt;，完整代码如下：（可直接覆盖上面代码） 1234567891011121314151617181920212223242526/** * 登录后回调 * * @param type * @param callback * @return */@RequestMapping(&quot;/callback/&#123;type&#125;&quot;)public AuthResponse&lt;AuthUser&gt; callback(@PathVariable String type, AuthCallback callback) &#123; //创建request AuthRequest authRequest = getAuthRequest(type); //登录(获取用户信息) AuthResponse&lt;AuthUser&gt; authResponse = authRequest.login(callback); //打印授权回传代码（2000 表示成功，可以用来判断用户登录是否成功） System.out.println(&quot;状态码：&quot; + authResponse.getCode()); //打印用户的昵称、ID、头像 System.out.println(&quot;用户的uuid：&quot; + authResponse.getData().getUuid()); System.out.println(&quot;用户的昵称：&quot; + authResponse.getData().getNickname()); System.out.println(&quot;用户的头像：&quot; + authResponse.getData().getAvatar()); //打印用户的Token中的access_token System.out.println(&quot;access_token：&quot; + authResponse.getData().getToken().getAccessToken()); return authResponse;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"JustAuth","slug":"JustAuth","permalink":"https://blog.zoutl.cn/tags/JustAuth/"}]},{"title":"GitHub创建第三方应用","slug":"234","date":"2021-07-27T23:52:07.000Z","updated":"2022-04-14T01:53:54.116Z","comments":true,"path":"234.html","link":"","permalink":"https://blog.zoutl.cn/234.html","excerpt":"","text":"打开设置 点击右上角头像选择Settings进入设置 左侧菜单选择Developer settings 创建 左侧菜单选择OAuth Apps，点击右边的New OAuth App按钮 填写信息后，点击下方绿色的Register applaction按钮创建应用 Application name一般填写自己的网站名称即可 Application description一般填写自己的应用描述即可 Homepage URL填写自己的网站首页地址 Authorization callback URL，该地址为用户授权后需要跳转到的自己网站的地址，默认携带一个code参数以上信息输入完成后","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"Gson获取JSON字符串的值","slug":"233","date":"2021-07-27T22:19:20.000Z","updated":"2022-04-14T02:13:59.766Z","comments":true,"path":"233.html","link":"","permalink":"https://blog.zoutl.cn/233.html","excerpt":"","text":"引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; 使用的方法JsonParser.parse(“字符串”) 解析json字符串为JsonElement JsonElement.getAsJsonObject() 解析为JsonObject JsonObject.getAsJsonObject(“对象名”) 获取对象 JsonObject.get(“属性名称”).getAsString() 获取属性值 测试Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.google.gson.JsonElement;import com.google.gson.JsonObject;import com.google.gson.JsonParser;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; String json = &quot;&#123;\\n&quot; + &quot; \\&quot;code\\&quot;: 2000,\\n&quot; + &quot; \\&quot;msg\\&quot;: null,\\n&quot; + &quot; \\&quot;data\\&quot;: &#123;\\n&quot; + &quot; \\&quot;uuid\\&quot;: null,\\n&quot; + &quot; \\&quot;username\\&quot;: null,\\n&quot; + &quot; \\&quot;nickname\\&quot;: null,\\n&quot; + &quot; \\&quot;avatar\\&quot;: null,\\n&quot; + &quot; \\&quot;blog\\&quot;: null,\\n&quot; + &quot; \\&quot;company\\&quot;: null,\\n&quot; + &quot; \\&quot;location\\&quot;: null,\\n&quot; + &quot; \\&quot;email\\&quot;: null,\\n&quot; + &quot; \\&quot;remark\\&quot;: null,\\n&quot; + &quot; \\&quot;gender\\&quot;: \\&quot;UNKNOWN\\&quot;,\\n&quot; + &quot; \\&quot;source\\&quot;: \\&quot;GITHUB\\&quot;,\\n&quot; + &quot; \\&quot;token\\&quot;: &#123;\\n&quot; + &quot; \\&quot;accessToken\\&quot;: \\&quot;gho_V7z5mRl3zrZAclRnSdhmczkYW2jvx\\&quot;,\\n&quot; + &quot; \\&quot;expireIn\\&quot;: 0,\\n&quot; + &quot; \\&quot;refreshToken\\&quot;: null,\\n&quot; + &quot; \\&quot;uid\\&quot;: null,\\n&quot; + &quot; \\&quot;openId\\&quot;: null,\\n&quot; + &quot; \\&quot;accessCode\\&quot;: null,\\n&quot; + &quot; \\&quot;unionId\\&quot;: null,\\n&quot; + &quot; \\&quot;scope\\&quot;: null,\\n&quot; + &quot; \\&quot;tokenType\\&quot;: \\&quot;bearer\\&quot;,\\n&quot; + &quot; \\&quot;idToken\\&quot;: null,\\n&quot; + &quot; \\&quot;macAlgorithm\\&quot;: null,\\n&quot; + &quot; \\&quot;macKey\\&quot;: null,\\n&quot; + &quot; \\&quot;code\\&quot;: null,\\n&quot; + &quot; \\&quot;oauthToken\\&quot;: null,\\n&quot; + &quot; \\&quot;oauthTokenSecret\\&quot;: null,\\n&quot; + &quot; \\&quot;userId\\&quot;: null,\\n&quot; + &quot; \\&quot;screenName\\&quot;: null,\\n&quot; + &quot; \\&quot;oauthCallbackConfirmed\\&quot;: null\\n&quot; + &quot; &#125;\\n&quot; + &quot; &#125;\\n&quot; + &quot;&#125;&quot;; JsonParser jsonParser = new JsonParser(); //解析json字符串为JsonElement JsonElement jsonElement = jsonParser.parse(json); //解析为JsonObject JsonObject root = jsonElement.getAsJsonObject(); //获取data对象 JsonObject data = root.getAsJsonObject(&quot;data&quot;); //获取token对象 JsonObject token = data.getAsJsonObject(&quot;token&quot;); //获取token对象的accessToken属性的值 String accessToken = token.get(&quot;accessToken&quot;).getAsString(); System.out.println(accessToken); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"JSON","slug":"JSON","permalink":"https://blog.zoutl.cn/tags/JSON/"}]},{"title":"Java跳出多重循环","slug":"232","date":"2021-07-24T03:03:25.000Z","updated":"2022-04-14T02:13:58.160Z","comments":true,"path":"232.html","link":"","permalink":"https://blog.zoutl.cn/232.html","excerpt":"","text":"\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000 方法给for循环添加一个标记，然后使用break 标记跳到标记处，即可实现跳出多重循环 代码12345678910111213141516171819202122JAVA/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; here: for (int i = 0; i &lt; 3; i++) &#123; System.out.println(&quot;外层第&quot; + (i + 1) + &quot;次循环&quot;); for (int i1 = 0; i1 &lt; 3; i1++) &#123; System.out.print(i1 + &quot; &quot;); if (i1 == 1 &amp;&amp; i == 1) &#123; break here; &#125; &#125; System.out.println(); &#125; &#125;&#125; 结果 /** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test {​ public static void main(String[] args) { int[] arr1 = new int[]{6, 5, 4, 3, 2, 1}; int[] arr2 = arr1.clone(); //遍历 for (int j : arr2) { System.out.print(j + “ “); } }}java","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java将一个数组复制给另一个数组","slug":"231","date":"2021-07-24T02:40:55.000Z","updated":"2022-04-14T02:13:56.150Z","comments":true,"path":"231.html","link":"","permalink":"https://blog.zoutl.cn/231.html","excerpt":"","text":"for循环1234567891011121314151617181920/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; int[] arr1 = new int[]&#123;6, 5, 4, 3, 2, 1&#125;; int[] arr2 = new int[arr1.length]; //复制 for (int i = 0; i &lt; arr1.length; i++) &#123; arr2[i] = arr1[i]; &#125; //遍历 for (int j : arr2) &#123; System.out.print(j + &quot; &quot;); &#125; &#125;&#125; System.ararycopy123456789101112131415161718/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; int[] arr1 = new int[]&#123;6, 5, 4, 3, 2, 1&#125;; int[] arr2 = new int[arr1.length]; //复制 System.arraycopy(arr1, 0, arr2, 0, arr1.length); //遍历 for (int j : arr2) &#123; System.out.print(j + &quot; &quot;); &#125; &#125;&#125; clone()如果数组等长，而且对应copy，使用int[] B= A.clone() 12345678910111213141516/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; int[] arr1 = new int[]&#123;6, 5, 4, 3, 2, 1&#125;; int[] arr2 = arr1.clone(); //遍历 for (int j : arr2) &#123; System.out.print(j + &quot; &quot;); &#125; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"MyBatis-Plus Mapper CRUD 接口之Select","slug":"230","date":"2021-07-23T04:12:37.000Z","updated":"2022-04-14T01:45:46.252Z","comments":true,"path":"230.html","link":"","permalink":"https://blog.zoutl.cn/230.html","excerpt":"","text":"方法12345678910111213141516171819202122// 根据 ID 查询T selectById(Serializable id);// 根据 entity 条件，查询一条记录T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据ID 批量查询）List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 entity 条件，查询全部记录List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 查询（根据 columnMap 条件）List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);// 根据 Wrapper 条件，查询全部记录List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 entity 条件，查询全部记录（并翻页）IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询全部记录（并翻页）IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);// 根据 Wrapper 条件，查询总记录数Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); 测试代码selectById12345@Testvoid selectById() &#123; BlogType blogType = blogTypeMapper.selectById(1); System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum());&#125; selectOne @Testvoid updateById() { BlogType blogType = new BlogType(); blogType.setId(34); blogType.setName(“222”); blogType.setSortNum(222); blogTypeMapper.updateById(blogType);}java 1234567@Testvoid selectOne() &#123; QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); blogTypeQueryWrapper.eq(&quot;name&quot;, &quot;MyBatis&quot;); BlogType blogType = blogTypeMapper.selectOne(blogTypeQueryWrapper); System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum());&#125; selectBatchIds123456789101112@Testvoid selectBatchIds() &#123; List&lt;Integer&gt; idList = new ArrayList&lt;&gt;(); idList.add(1); idList.add(5); idList.add(6); idList.add(7); List&lt;BlogType&gt; blogTypeList = blogTypeMapper.selectBatchIds(idList); for (BlogType blogType : blogTypeList) &#123; System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum()); &#125;&#125; selectList12345678910111213141516@Testvoid selectList() &#123; //参数为空时查询所有 List&lt;BlogType&gt; blogTypeList = blogTypeMapper.selectList(null); for (BlogType blogType : blogTypeList) &#123; System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum()); &#125; System.out.println(&quot;------------------------&quot;); //根据条件查询 QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); blogTypeQueryWrapper.like(&quot;name&quot;, &quot;a&quot;); List&lt;BlogType&gt; blogTypeList1 = blogTypeMapper.selectList(blogTypeQueryWrapper); for (BlogType blogType : blogTypeList1) &#123; System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum()); &#125;&#125; selectByMap123456789@Testvoid selectByMap() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;sortNum&quot;, 81); List&lt;BlogType&gt; blogTypeList = blogTypeMapper.selectByMap(map); for (BlogType blogType : blogTypeList) &#123; System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum()); &#125;&#125; selectMaps查询到的数据以键值对的方式存储在map中 123456789@Testvoid selectMaps() &#123; QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); blogTypeQueryWrapper.gt(&quot;id&quot;, 5).like(&quot;name&quot;, &quot;a&quot;); List&lt;Map&lt;String, Object&gt;&gt; mapList = blogTypeMapper.selectMaps(blogTypeQueryWrapper); for (Map&lt;String, Object&gt; map : mapList) &#123; System.out.println(map.get(&quot;id&quot;)+&quot;,&quot;+map.get(&quot;name&quot;)+&quot;,&quot;+map.get(&quot;sortNum&quot;)); &#125;&#125; selectObjs只返回一个字段 12345678910@Testvoid selectObjs() &#123; QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); //选择要查询的字段,不选择就返回第一个字段(一般是id) blogTypeQueryWrapper.select(&quot;name&quot;); //查询条件 blogTypeQueryWrapper.gt(&quot;id&quot;, 5); List&lt;Object&gt; objectList = blogTypeMapper.selectObjs(blogTypeQueryWrapper); System.out.println(objectList);&#125; selectPage先配置分页插件 1234567891011121314151617181920212223242526272829package com.ledao;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * @author LeDao * @company * @create 2021-07-23 14:15 */@EnableTransactionManagement@Configurationpublic class MybatisPlusConfig &#123; @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求 默认false // paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 // paginationInterceptor.setLimit(500); // 开启 count 的 join 优化,只针对部分 left join paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true)); return paginationInterceptor; &#125;&#125; 测试 1234567891011121314@Testvoid selectPage() &#123; //设置查询条件 QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); blogTypeQueryWrapper.gt(&quot;id&quot;, 7); //设置当前页以及每页记录数 Page&lt;BlogType&gt; page = new Page&lt;&gt;(2, 2); //获取记录 Page&lt;BlogType&gt; blogTypePage = blogTypeMapper.selectPage(page, blogTypeQueryWrapper); List&lt;BlogType&gt; blogTypeList = blogTypePage.getRecords(); for (BlogType blogType : blogTypeList) &#123; System.out.println(blogType); &#125;&#125; selectMapsPage123456789101112@Testvoid selectMapsPage() &#123; //设置查询条件 QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); blogTypeQueryWrapper.gt(&quot;id&quot;, 7); //设置当前页以及每页记录数 Page page = new Page&lt;&gt;(2, 2); IPage&lt;Map&lt;String, Object&gt;&gt; mapIPage = blogTypeMapper.selectMapsPage(page, blogTypeQueryWrapper); for (Map&lt;String, Object&gt; record : mapIPage.getRecords()) &#123; System.out.println(record); &#125;&#125; selectCount1234567@Testvoid selectCount() &#123; QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); blogTypeQueryWrapper.gt(&quot;id&quot;, 7); int count = blogTypeMapper.selectCount(blogTypeQueryWrapper); System.out.println(count);&#125;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"MyBatis-Plus Mapper CRUD 接口之Update","slug":"229","date":"2021-07-23T03:59:06.000Z","updated":"2022-04-14T01:45:49.453Z","comments":true,"path":"229.html","link":"","permalink":"https://blog.zoutl.cn/229.html","excerpt":"","text":"方法1234// 根据 whereWrapper 条件，更新记录int update(@Param(Constants.ENTITY) T updateEntity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; whereWrapper);// 根据 ID 修改int updateById(@Param(Constants.ENTITY) T entity); 测试代码update12345678@Testvoid update() &#123; UpdateWrapper&lt;BlogType&gt; blogTypeUpdateWrapper = new UpdateWrapper&lt;&gt;(); blogTypeUpdateWrapper.eq(&quot;name&quot;, &quot;spring&quot;); BlogType blogType = new BlogType(); blogType.setSortNum(111); blogTypeMapper.update(blogType, blogTypeUpdateWrapper);&#125; updateById12345678@Testvoid updateById() &#123; BlogType blogType = new BlogType(); blogType.setId(34); blogType.setName(&quot;222&quot;); blogType.setSortNum(222); blogTypeMapper.updateById(blogType);&#125;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"MyBatis-Plus Mapper CRUD 接口之Delete","slug":"228","date":"2021-07-23T03:30:53.000Z","updated":"2022-04-14T01:45:53.362Z","comments":true,"path":"228.html","link":"","permalink":"https://blog.zoutl.cn/228.html","excerpt":"","text":"方法12345678// 根据 entity 条件，删除记录int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; wrapper);// 删除（根据ID 批量删除）int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);// 根据 ID 删除int deleteById(Serializable id);// 根据 columnMap 条件，删除记录int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); 测试代码delete123456@Testvoid delete() &#123; QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); blogTypeQueryWrapper.eq(&quot;name&quot;, &quot;spring&quot;); blogTypeMapper.delete(blogTypeQueryWrapper);&#125; deleteBatchIds123456789@Testvoid deleteBatchIds() &#123; List&lt;Integer&gt; idList = new ArrayList&lt;&gt;(); idList.add(29); idList.add(30); idList.add(31); int result = blogTypeMapper.deleteBatchIds(idList); System.out.println(result);&#125; deleteById12345@Testvoid deleteById() &#123; int result = blogTypeMapper.deleteById(32); System.out.println(result);&#125; deleteByMap12345678@Testvoid deleteByMap() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;name&quot;, 1); map.put(&quot;sortNum&quot;, 2); int result = blogTypeMapper.deleteByMap(map); System.out.println(result);&#125;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"MyBatis-Plus 自定义SQL","slug":"227","date":"2021-07-23T01:58:19.000Z","updated":"2022-04-14T01:45:56.614Z","comments":true,"path":"227.html","link":"","permalink":"https://blog.zoutl.cn/227.html","excerpt":"","text":"自定义SQL的方式 Annotation注解方式 XML配置文件方式 Annotation注解方式直接先定义接口方法，然后在接口方法上面开发注解即可 12345678910111213141516171819202122package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.BlogType;import org.apache.ibatis.annotations.Select;/** * @author LeDao * @company * @create 2021-07-22 22:15 */public interface BlogTypeMapper extends BaseMapper &#123; /** * 根据id查找博客类型 * * @param id * @return */ @Select(&quot;select * from t_blogtype where id=#&#123;id&#125;&quot;) BlogType findById(Integer id);&#125; XML配置文件方式1、修改application.yml配置文件 1234mybatis-plus: # 如果是放在src/main/java目录下 classpath:/com/*/*/mapper/*Mapper.xml # 如果是放在resource目录 classpath:/mapper/**.xml mapper-locations: classpath:/mapper/**.xml 2、自定义接口 1234567891011121314151617181920212223package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.BlogType;import java.util.List;import java.util.Map;/** * @author LeDao * @company * @create 2021-07-22 22:15 */public interface BlogTypeMapper extends BaseMapper&lt;BlogType&gt; &#123; /** * 根据情况获取博客类型列表 * * @param map * @return */ List&lt;BlogType&gt; list(Map&lt;String, Object&gt; map);&#125; 3、xml文件实现 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress ALL--&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ledao.mapper.BlogTypeMapper&quot;&gt; &lt;resultMap id=&quot;BlogResult&quot; type=&quot;com.ledao.entity.BlogType&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;result property=&quot;sortNum&quot; column=&quot;sortNum&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;list&quot; parameterType=&quot;map&quot; resultMap=&quot;BlogResult&quot;&gt; select * from t_blogtype &lt;where&gt; &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt; and name like #&#123;name&#125; &lt;/if&gt; &lt;/where&gt; &lt;if test=&quot;start != null and size != null&quot;&gt; limit #&#123;start&#125;,#&#123;size&#125; &lt;/if&gt; &lt;/select&gt;&lt;/mapper&gt; 4、测试代码 123456789@Testvoid list()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16); map.put(&quot;name&quot;, &quot;%a%&quot;); List&lt;BlogType&gt; blogTypeList = blogTypeMapper.list(map); for (BlogType blogType : blogTypeList) &#123; System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum()); &#125;&#125; 5、结果 PS.来源：https://www.jianshu.com/p/c0dd01a82fcc","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"MyBatis-Plus 条件构造器","slug":"226","date":"2021-07-23T01:17:30.000Z","updated":"2022-04-14T01:45:59.427Z","comments":true,"path":"226.html","link":"","permalink":"https://blog.zoutl.cn/226.html","excerpt":"","text":"条件构造器层级关系 介绍 ： 上图绿色框为抽象类abstract 蓝色框为正常class类，可new对象 黄色箭头指向为父子类关系，箭头指向为父类 wapper介绍 ： Wrapper ： 条件构造抽象类，最顶端父类，抽象类中提供4个方法西面贴源码展示 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。 LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper QueryWrapper ： Entity 对象封装操作类，不是用lambda语法 UpdateWrapper ： Update 条件封装，用于Entity对象更新操作 各函数及其实例 测试QueryWrapper12345678910@Testvoid queryWrapper() &#123; QueryWrapper&lt;BlogType&gt; blogTypeQueryWrapper = new QueryWrapper&lt;&gt;(); //name中包含tis的数据 blogTypeQueryWrapper.like(&quot;name&quot;, &quot;tis&quot;); List&lt;BlogType&gt; blogTypeList = blogTypeMapper.selectList(blogTypeQueryWrapper); for (BlogType blogType : blogTypeList) &#123; System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum()); &#125;&#125; UpdateWrapper12345678910111213141516@Testvoid updateWrapper() &#123; UpdateWrapper&lt;BlogType&gt; blogTypeUpdateWrapper = new UpdateWrapper&lt;&gt;(); //id是28的数据 blogTypeUpdateWrapper.eq(&quot;id&quot;, 28); BlogType blogType = new BlogType(); blogType.setName(&quot;spring&quot;); blogType.setSortNum(23); //更新成功返回1,失败返回0,可用于判断是否更新成功 int result = blogTypeMapper.update(blogType, blogTypeUpdateWrapper); if (result &gt; 0) &#123; System.out.println(&quot;更新成功!!&quot;); &#125; else &#123; System.out.println(&quot;更新失败!!&quot;); &#125;&#125; PS.来源：https://blog.csdn.net/m0_37034294/article/details/82917234","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"MyBatis-Plus Mapper CRUD 接口之Insert","slug":"225","date":"2021-07-22T17:02:39.000Z","updated":"2022-04-14T01:46:06.952Z","comments":true,"path":"225.html","link":"","permalink":"https://blog.zoutl.cn/225.html","excerpt":"","text":"方法12// 插入一条记录int insert(T entity); 参数为要插入的实体 该方法返回的是成功插入的数据条数，所以我们可以根据返回的结果是否大于0来判断是否插入成功，大于代表成功，反之则是失败 配置application.yml1234mybatis-plus: global-config: db-config: id-type: auto 目的：让插入的数据的id自增 测试Java代码 123456789101112@Testvoid insert() &#123; BlogType blogType = new BlogType(); blogType.setName(&quot;222&quot;); blogType.setSortNum(22); int result = blogTypeMapper.insert(blogType); if (result &gt; 0) &#123; System.out.println(&quot;插入成功&quot;); &#125; else &#123; System.out.println(&quot;插入失败&quot;); &#125;&#125; 结果","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"Spring Boot引入MyBatis-Plus","slug":"224","date":"2021-07-22T14:32:05.000Z","updated":"2022-04-14T01:46:08.999Z","comments":true,"path":"224.html","link":"","permalink":"https://blog.zoutl.cn/224.html","excerpt":"","text":"引入依赖12345678910&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; application.yml配置12345678910111213141516171819202122232425262728293031server: port: 8080 servlet: context-path: / tomcat: uri-encoding: UTF-8spring: servlet: multipart: enabled: true file-size-threshold: 0 max-file-size: 10MB max-request-size: 100MB #数据库连接配置 datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db_test?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8 username: root password: 123456 jackson: time-zone: GMT+8 date-format: yyyy-MM-dd HH:mm:ssmybatis-plus: global-config: db-config: id-type: auto # 如果是放在src/main/java目录下 classpath:/com/*/*/mapper/*Mapper.xml # 如果是放在resource目录 classpath:/mapper/**.xml mapper-locations: classpath:/mapper/**.xml 添加注解启动类里也需要加一个mapper扫描配置@MapperScan(“com.ledao.mapper”) 123456789101112131415161718package com.ledao;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author LeDao */@MapperScan(&quot;com.ledao.mapper&quot;)@SpringBootApplicationpublic class MyBatisPlusDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MyBatisPlusDemoApplication.class, args); &#125;&#125; 测试表结构 BlogType实体类12345678910111213141516171819202122package com.ledao.entity;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.annotation.TableName;import lombok.Data;/** * @author LeDao * @company * @create 2021-07-22 22:14 */@Data@TableName(value = &quot;t_blogtype&quot;)public class BlogType &#123; @TableId private Integer id; private String name; @TableField(value = &quot;sortNum&quot;) private Integer sortNum;&#125; BlogTypeMapper123456789101112package com.ledao.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.ledao.entity.BlogType;/** * @author LeDao * @company * @create 2021-07-22 22:15 */public interface BlogTypeMapper extends BaseMapper&lt;BlogType&gt; &#123;&#125; 测试代码12345678910111213141516171819202122232425package com.ledao;import com.ledao.entity.BlogType;import com.ledao.mapper.BlogTypeMapper;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import javax.annotation.Resource;import java.util.List;@SpringBootTestclass MyBatisPlusDemoApplicationTests &#123; @Resource private BlogTypeMapper blogTypeMapper; @Test void contextLoads() &#123; List&lt;BlogType&gt; blogTypeList = blogTypeMapper.selectList(null); for (BlogType blogType : blogTypeList) &#123; System.out.println(blogType.getId() + &quot;,&quot; + blogType.getName() + &quot;,&quot; + blogType.getSortNum()); &#125; &#125;&#125; 结果","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"}]},{"title":"队列","slug":"223","date":"2021-07-21T02:38:20.000Z","updated":"2022-04-14T02:13:47.454Z","comments":true,"path":"223.html","link":"","permalink":"https://blog.zoutl.cn/223.html","excerpt":"","text":"简介队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表 LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用 队列的操作使用了LinkedList类的方法进行封装，更多LinkedList类的方法去查看JDK enqueue加入队列（在表的后端进行插入操作） dequeue离开队列（在表的前端进行删除操作） 代码实现Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.LinkedList;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); //加入队列 enqueue(1, linkedList); enqueue(3, linkedList); enqueue(4, linkedList); enqueue(6, linkedList); //遍历 System.out.print(&quot;当前所有元素: &quot;); for (Integer integer : linkedList) &#123; System.out.print(integer + &quot; &quot;); &#125; System.out.println(); //离开队列 dequeue(linkedList); System.out.print(&quot;当前所有元素: &quot;); for (Integer integer : linkedList) &#123; System.out.print(integer + &quot; &quot;); &#125; &#125; /** * 离开队列(删除) * * @param linkedList */ public static void dequeue(LinkedList&lt;Integer&gt; linkedList) &#123; if (linkedList.size() &gt; 0) &#123; linkedList.removeFirst(); &#125; else &#123; System.out.println(&quot;队列为空&quot;); &#125; &#125; /** * 加入队列(插入) * * @param a * @param linkedList */ public static void enqueue(int a, LinkedList&lt;Integer&gt; linkedList) &#123; linkedList.addLast(a); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"栈","slug":"222","date":"2021-07-21T02:15:01.000Z","updated":"2022-04-14T02:13:45.562Z","comments":true,"path":"222.html","link":"","permalink":"https://blog.zoutl.cn/222.html","excerpt":"","text":"简介栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素 栈的操作empty()测试此堆栈是否为空 peek()查看此堆栈顶部的对象，而不从堆栈中删除它 pop()删除此堆栈顶部的对象，并将该对象作为此函数的值返回 push()将元素添加到堆栈的顶部 栈的代码实现Java代码 1234567891011121314151617181920212223package com;import java.util.Stack;/** * @author LeDao * @company * @create 2019-10-03 19:30 */public class Main &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); //判断是否为空,true表示堆栈为空 System.out.println(stack.empty()); stack.push(&quot;a&quot;); stack.push(&quot;b&quot;); stack.push(&quot;c&quot;); //查看顶部元素 System.out.println(stack.peek()); //移除顶部元素,移除后返回这个元素 System.out.println(stack.pop()); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"IntelliJ IDEA Alt+Enter快捷键添加javadoc文档注释被disabled的解决方法","slug":"221","date":"2021-07-20T19:03:27.000Z","updated":"2022-04-14T02:45:10.820Z","comments":true,"path":"221.html","link":"","permalink":"https://blog.zoutl.cn/221.html","excerpt":"","text":"问题描述Alt+Enter快捷键本来是有添加javadoc文档注释选项的，但是不小心点击disabled后，该选项就没有了 解决方法 打开配置（快捷键为Ctrl+Shift+S） 根据下图提示找到Add Javadoc，勾选后保存即可","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"二分查找","slug":"220","date":"2021-07-20T16:15:00.000Z","updated":"2022-04-14T02:13:28.894Z","comments":true,"path":"220.html","link":"","permalink":"https://blog.zoutl.cn/220.html","excerpt":"","text":"介绍二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 要求1、必须采用顺序存储结构 2、必须按关键字大小有序排列 基本思想二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x Java代码12345678910111213141516171819202122232425262728293031323334353637383940import java.util.Arrays;import java.util.Scanner;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;; int index = 0; int result = -1; System.out.println(&quot;输入你要查找的数：&quot;); Scanner sc = new Scanner(System.in); int num = sc.nextInt(); int start = 0, end = arr.length - 1; while (start &lt;= end) &#123; index++; int mid = start + (end - start) / 2; System.out.println(&quot;第&quot; + index + &quot;次: start=&quot; + start + &quot;,end=&quot; + end + &quot;,mid=&quot; + mid); if (num &lt; arr[mid]) &#123; end = mid - 1; &#125; else if (arr[mid] &lt; num) &#123; start = mid + 1; &#125; else &#123; result = mid; break; &#125; &#125; if (result == -1) &#123; System.out.println(&quot;你要查找的数不存在！！&quot;); System.out.println(&quot;循环执行了&quot; + index + &quot;次&quot;); &#125; else &#123; System.out.println(&quot;你要查找的数的数组下标为：&quot; + result); System.out.println(&quot;循环执行了&quot; + index + &quot;次&quot;); &#125; &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"线性查找","slug":"219","date":"2021-07-20T14:49:17.000Z","updated":"2022-04-14T02:13:26.909Z","comments":true,"path":"219.html","link":"","permalink":"https://blog.zoutl.cn/219.html","excerpt":"","text":"介绍线性查找又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败。 Java代码12345678910111213141516171819202122232425import java.util.Scanner;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;3, 6, 1, 9, 21, 34, 65, 13, 67, 23, 89&#125;; System.out.println(&quot;输入你要查找的数：&quot;); Scanner sc = new Scanner(System.in); int num = sc.nextInt(); for (int i = 0; i &lt; arr.length; i++) &#123; if (num == arr[i]) &#123; System.out.println(&quot;你要查找的数的数组下标为：&quot; + i); break; &#125; if (i == arr.length - 1) &#123; System.out.println(&quot;你要查找的数不存在！！&quot;); &#125; &#125; &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Java的HTML解析器：jsoup","slug":"218","date":"2021-07-20T13:57:54.000Z","updated":"2022-04-14T02:13:23.635Z","comments":true,"path":"218.html","link":"","permalink":"https://blog.zoutl.cn/218.html","excerpt":"","text":"介绍jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 主要功能从一个URL，文件或字符串中解析HTML 使用DOM或CSS选择器来查找、取出数据 可操作HTML元素、属性、文本 常用方法Jsoup.connect(url字符串).get()从URL加载HTML Jsoup.parse(HTML文件路径)从文件加载HTML Jsoup.parse(HTML字符串)从字符串加载HTML document.title()获取HTML页面的标题 document.select()获取标签 elements.attr()获取标签的属性 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.13.1&lt;/version&gt;&lt;/dependency&gt; 例子Java代码Link实体类12345678910111213141516171819202122232425262728293031323334353637package entity;/** * @author LeDao * @company * @create 2021-07-20 8:22 */public class Link &#123; private Integer id; private String linkName; private String linkUrl; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLinkName() &#123; return linkName; &#125; public void setLinkName(String linkName) &#123; this.linkName = linkName; &#125; public String getLinkUrl() &#123; return linkUrl; &#125; public void setLinkUrl(String linkUrl) &#123; this.linkUrl = linkUrl; &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243import entity.Link;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws Exception &#123; int i = 1; List&lt;Link&gt; linkList = new ArrayList&lt;&gt;(); //爬取前3页 while (i &lt;= 3) &#123; //获取该页面的HTML源代码 Document document = Jsoup.connect(&quot;http://www.zoutl.cn/index?page=&quot; + i).get(); //爬取id为div1的链接 Elements links = document.select(&quot;a#div1&quot;); for (Element link : links) &#123; Link link1 = new Link(); link1.setLinkName(link.text()); link1.setLinkUrl(&quot;http://www.zoutl.cn&quot; + link.attr(&quot;href&quot;)); linkList.add(link1); &#125; System.out.println(new Date() + &quot;: 完成第&quot; + i + &quot;页的爬取&quot;); i++; &#125; int index = 1; //遍历 for (Link link : linkList) &#123; System.out.println(index + &quot;、&quot; + link.getLinkName() + &quot;：&quot; + link.getLinkUrl()); index++; &#125; &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"jsoup","slug":"jsoup","permalink":"https://blog.zoutl.cn/tags/jsoup/"}]},{"title":"一款免费且好用的SSH连接工具","slug":"217","date":"2021-07-18T15:39:38.000Z","updated":"2022-03-26T19:11:29.926Z","comments":true,"path":"217.html","link":"","permalink":"https://blog.zoutl.cn/217.html","excerpt":"","text":"优点免费、简单、有图形界面可以直接操作文件、可以使用网页版无需安装 使用下载与安装官网地址：https://www.terminal.icu/ 使用注册并登录后，添加自己的服务器，输入对应ip及其登录密码开始连接即可 结果左侧上方是命令行输入终端，下方是图形界面（可以直接操作文件），右侧是系统的一些信息","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"highlight.js实现代码复制","slug":"216","date":"2021-07-18T12:07:31.000Z","updated":"2022-04-14T02:00:02.078Z","comments":true,"path":"216.html","link":"","permalink":"https://blog.zoutl.cn/216.html","excerpt":"","text":"下载js文件阿里云盘链接：https://www.aliyundrive.com/s/LGzQZBYXYGZ 前端引入样式和js文件引入顺序按下面代码所示，顺序不同可能会得不到我们想要的结果 123456789101112131415&lt;!--代码高亮样式--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/androidstudio.min.css&quot;&gt;&lt;!--行号js文件--&gt;&lt;script th:src=&quot;@&#123;/static/js/highlight.line-numbers.js&#125;&quot;&gt;&lt;/script&gt;&lt;!--代码高亮js文件--&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;!--代码复制--&gt;&lt;script th:src=&quot;@&#123;/static/js/highlightjs-copy-button.js&#125;&quot;&gt;&lt;/script&gt;&lt;script th:src=&quot;@&#123;/static/js/highlightjs-copy-button.min.js&#125;&quot;&gt;&lt;/script&gt;&lt;!--初始化--&gt;&lt;script&gt; hljs.initHighlightingOnLoad();//代码高亮 hljsln.initLineNumbersOnLoad();//行号 hljs.initCopyButtonOnLoad();//代码复制&lt;/script&gt; 修改复制代码按钮大小及其样式123456789.hljs-button&#123; font-size: 11px; color: #0b0b0b;&#125;.hljs-button:hover&#123; color: white; background-color: #6eb9f1;&#125; 结果 PS.来源：https://github.com/DevCreel/highlightjs-copy-button.js","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"highlight.js","slug":"highlight-js","permalink":"https://blog.zoutl.cn/tags/highlight-js/"}]},{"title":"将JSON字符串转为list","slug":"215","date":"2021-07-17T15:27:16.000Z","updated":"2022-04-14T02:13:18.302Z","comments":true,"path":"215.html","link":"","permalink":"https://blog.zoutl.cn/215.html","excerpt":"","text":"引入hutool依赖使用到该依赖的HTTP请求方法 12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.9&lt;/version&gt;&lt;/dependency&gt; HTTP请求的地址为：http://www.zoutl.cn/getFruitListJson ，返回的结果如下图（下面四种方法只能处理中括号[]以及其中的内容，所以要对HTTP请求返回的结果进行截取处理） Fruit实体类12345678910111213141516171819202122232425262728293031323334353637/** * @author LeDao * @company * @create 2021-07-17 22:27 */public class Fruit &#123; private Integer id; private String name; private Integer num; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125;&#125; 使用GSON引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; Java代码1234567891011121314151617181920212223242526272829import cn.hutool.http.HttpUtil;import com.google.gson.Gson;import com.google.gson.reflect.TypeToken;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; //http请求获取json字符串 String str = HttpUtil.get(&quot;https://www.zoutl.cn/getFruitListJson&quot;); int start = str.indexOf(&quot;[&quot;); int end = str.indexOf(&quot;]&quot;) + 1; //截取字符串 str = str.substring(start, end); System.out.println(str); //转为list Gson gson = new Gson(); List&lt;Fruit&gt; fruitList = gson.fromJson(str, new TypeToken&lt;List&lt;Fruit&gt;&gt;()&#123;&#125;.getType()); for (Fruit fruit : fruitList) &#123; System.out.println(fruit.getId() + &quot;,&quot; + fruit.getName() + &quot;,&quot; + fruit.getNum()); &#125; &#125;&#125; 使用FastJSON引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt;&lt;/dependency&gt; Java代码123456789101112131415161718192021222324252627import cn.hutool.http.HttpUtil;import com.alibaba.fastjson.JSON;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; //http请求获取json字符串 String str = HttpUtil.get(&quot;https://www.zoutl.cn/getFruitListJson&quot;); int start = str.indexOf(&quot;[&quot;); int end = str.indexOf(&quot;]&quot;) + 1; //截取字符串 str = str.substring(start, end); System.out.println(str); //转为list List&lt;Fruit&gt; fruitList = JSON.parseArray(str, Fruit.class); for (Fruit fruit : fruitList) &#123; System.out.println(fruit.getId() + &quot;,&quot; + fruit.getName() + &quot;,&quot; + fruit.getNum()); &#125; &#125;&#125; 使用JackJSON引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt; Java代码123456789101112131415161718192021222324252627282930import cn.hutool.http.HttpUtil;import com.fasterxml.jackson.core.type.TypeReference;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; //http请求获取json字符串 String str = HttpUtil.get(&quot;https://www.zoutl.cn/getFruitListJson&quot;); int start = str.indexOf(&quot;[&quot;); int end = str.indexOf(&quot;]&quot;) + 1; //截取字符串 str = str.substring(start, end); System.out.println(str); //转为list ObjectMapper objectMapper = new ObjectMapper(); List&lt;Fruit&gt; fruitList = objectMapper.readValue(str, new TypeReference&lt;List&lt;Fruit&gt;&gt;()&#123;&#125;); for (Fruit fruit : fruitList) &#123; System.out.println(fruit.getId() + &quot;,&quot; + fruit.getName() + &quot;,&quot; + fruit.getNum()); &#125; &#125;&#125; 传统方式org.json引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20210307&lt;/version&gt;&lt;/dependency&gt; Java代码12345678910111213141516171819202122232425262728293031323334353637383940import cn.hutool.http.HttpUtil;import org.json.JSONArray;import org.json.JSONObject;import java.util.ArrayList;import java.util.List;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; //http请求获取json字符串 String str = HttpUtil.get(&quot;https://www.zoutl.cn/getFruitListJson&quot;); int start = str.indexOf(&quot;[&quot;); int end = str.indexOf(&quot;]&quot;) + 1; //截取字符串 str = str.substring(start, end); System.out.println(str); //先转为jsonArray JSONArray jsonArray = new JSONArray(str); //转为list List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); for (Object o : jsonArray) &#123; //将数组的每个元素转为jsonObject JSONObject jsonObject = new JSONObject(o.toString()); Fruit fruit = new Fruit(); fruit.setId((Integer) jsonObject.get(&quot;id&quot;)); fruit.setName((String) jsonObject.get(&quot;name&quot;)); fruit.setNum((Integer) jsonObject.get(&quot;num&quot;)); fruitList.add(fruit); &#125; for (Fruit fruit : fruitList) &#123; System.out.println(fruit.getId() + &quot;,&quot; + fruit.getName() + &quot;,&quot; + fruit.getNum()); &#125; &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"JSON","slug":"JSON","permalink":"https://blog.zoutl.cn/tags/JSON/"}]},{"title":"浏览器格式化JSON数据插件","slug":"214","date":"2021-07-13T17:58:34.000Z","updated":"2022-04-10T15:10:12.322Z","comments":true,"path":"214.html","link":"","permalink":"https://blog.zoutl.cn/214.html","excerpt":"","text":"下载和安装 Edge直接安装 微软Edge外接程序下载地址：https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home 搜索JSONview并安装即可 通过下载插件包安装 下载地址：https://www.extfans.com/productivity/cgphfnglahpambfhocchajalljaeegef/ 结果直接在浏览器输入https://www.zoutl.cn/getFruitListJson 测试 使用插件前 使用插件后","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://blog.zoutl.cn/tags/JSON/"}]},{"title":"MyBatis使用分页插件PageHelper","slug":"213","date":"2021-07-13T17:00:47.000Z","updated":"2022-04-14T01:43:47.018Z","comments":true,"path":"213.html","link":"","permalink":"https://blog.zoutl.cn/213.html","excerpt":"","text":"GitHub完整代码地址：https://github.com/a6678696/MyBatisPageHelperTest pom.xml引入分页插件12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; application.yml配置12345pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql User.java1234567891011121314151617181920package com.ledao.entity;import lombok.Data;/** * @author LeDao * @company * @create 2021-07-13 23:36 */@Datapublic class User &#123; private Integer id; private String userName; private String password; private String nickName;&#125; UserMapper.java1234567891011121314151617181920package com.ledao.mapper;import com.ledao.entity.User;import java.util.List;/** * @author LeDao * @company * @create 2021-07-13 23:40 */public interface UserMapper &#123; /** * 查找全部用户 * * @return */ List&lt;User&gt; findAll();&#125; UserMapper.xml123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--suppress ALL--&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ledao.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;UserResult&quot; type=&quot;User&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;userName&quot; column=&quot;userName&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt; &lt;result property=&quot;nickName&quot; column=&quot;nickName&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;UserResult&quot;&gt; select * from t_user &lt;/select&gt;&lt;/mapper&gt; UserService.java1234567891011121314151617181920package com.ledao.service;import com.github.pagehelper.PageInfo;/** * @author LeDao * @company * @create 2021-07-13 23:37 */public interface UserService &#123; /** * 查找全部用户 * * @param page * @param size * @return */ PageInfo findAll(int page, int size);&#125; UserServiceImpl.java12345678910111213141516171819202122232425262728293031package com.ledao.service.impl;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.ledao.entity.User;import com.ledao.mapper.UserMapper;import com.ledao.service.UserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;/** * @author LeDao * @company * @create 2021-07-13 23:38 */@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService &#123; @Resource private UserMapper userMapper; @Override public PageInfo findAll(int page, int size) &#123; PageHelper.startPage(page, size); List&lt;User&gt; userList = userMapper.findAll(); PageInfo result = new PageInfo&lt;&gt;(userList); return result; &#125;&#125; UserController.java1234567891011121314151617181920212223242526package com.ledao.controller;import com.github.pagehelper.PageInfo;import com.ledao.service.UserService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @author LeDao * @company * @create 2021-07-14 0:10 */@RestController@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Resource private UserService userService; @RequestMapping(&quot;/findAll&quot;) public PageInfo findAll(int page, int size) &#123; return userService.findAll(page, size); &#125;&#125; 结果浏览器地址栏输入http://localhost/user/findAll?page=3&amp;size=4","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"创建线程的四种方式","slug":"212","date":"2021-07-09T15:02:30.000Z","updated":"2022-04-14T02:13:13.558Z","comments":true,"path":"212.html","link":"","permalink":"https://blog.zoutl.cn/212.html","excerpt":"","text":"继承Thread类通过继承Thread类，并重写它的run方法，我们就可以创建一个线程 1234567891011121314151617/** * @author LeDao * @company * @create 2021-07-09 22:45 */public class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;线程运行&quot;); &#125; public static void main(String[] args) &#123; Thread thread = new MyThread(); thread.start(); &#125;&#125; 实现 Runnable接口通过实现Runnable，并实现run方法，也可以创建一个线程 1234567891011121314151617/** * @author LeDao * @company * @create 2021-07-09 22:45 */public class MyThread implements Runnable&#123; @Override public void run() &#123; System.out.println(&quot;运行线程&quot;); &#125; public static void main(String[] args) &#123; Thread thread = new Thread(new MyThread()); thread.start(); &#125;&#125; 实现 Callable 接口实现Callable接口，并结合Future实现 1234567891011121314151617181920212223import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * @author LeDao * @company * @create 2021-07-09 22:45 */public class MyThread implements Callable &#123; @Override public String call() &#123; return &quot;1&quot;; &#125; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask task = new FutureTask(new MyThread()); new Thread(task).start(); String result = (String) task.get(); System.out.println(result); &#125;&#125; 通过线程池创建线程用JDK自带的Executors来创建线程池对象 1234567891011121314151617181920212223import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @author LeDao * @company * @create 2021-07-09 22:45 */public class MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot;thread run...&quot;); &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; executorService.execute(new MyThread()); &#125; executorService.shutdown(); &#125;&#125; PS.来源：https://segmentfault.com/a/1190000037589073","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java自定义异常","slug":"211","date":"2021-07-07T03:01:30.000Z","updated":"2022-04-14T02:13:11.266Z","comments":true,"path":"211.html","link":"","permalink":"https://blog.zoutl.cn/211.html","excerpt":"","text":"概述可以继承的父类有Throwable、Exception、RunTimeException，一般继承后两个，如果不要求调用者一定要处理抛出的异常，就继承RuntimeException 自定义异常类构造方法idea可以自动生成，Alt+Insert快捷键，选择构造方法 代码如下MyException.java1234567891011121314151617181920212223242526/** * @author LeDao * @company * @create 2021-07-07 10:43 */public class MyException extends RuntimeException&#123; public MyException() &#123; &#125; public MyException(String message) &#123; super(message); &#125; public MyException(String message, Throwable cause) &#123; super(message, cause); &#125; public MyException(Throwable cause) &#123; super(cause); &#125; public MyException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) &#123; super(message, cause, enableSuppression, writableStackTrace); &#125;&#125; People.java123456789101112131415161718192021222324252627282930/** * @author LeDao * @company * @create 2021-07-07 10:45 */public class People &#123; private String name; private String sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) throws MyException &#123; if (&quot;男&quot;.equals(sex) || &quot;女&quot;.equals(sex)) &#123; this.sex = sex; &#125; else &#123; throw new MyException(&quot;性别必须是男或女&quot;); &#125; &#125;&#125; Test.java123456789101112/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) &#123; People people = new People(); people.setSex(&quot;11&quot;); &#125;&#125; 结果 PS.来源：Java自定义异常 - 拭不去の泪痕 - 博客园","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"cmd命令运行一个Java文件","slug":"210","date":"2021-07-07T01:24:21.000Z","updated":"2022-04-14T02:13:09.682Z","comments":true,"path":"210.html","link":"","permalink":"https://blog.zoutl.cn/210.html","excerpt":"","text":"代码如下名称为HelloWorld.java 12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello World!!&quot;); &#125;&#125; 使用javac命令将.java文件编译成.class字节码文件 1javac HelloWorld.java 使用java命令运行一个已编译的Java程序，参数是类名 1java HelloWorld 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"cmd","slug":"cmd","permalink":"https://blog.zoutl.cn/tags/cmd/"}]},{"title":"Java中四种循环语句","slug":"209","date":"2021-07-07T00:58:55.000Z","updated":"2022-04-14T02:13:07.362Z","comments":true,"path":"209.html","link":"","permalink":"https://blog.zoutl.cn/209.html","excerpt":"","text":"概述Java中循环有while、do…while…，for，增强for while12345678910public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个数字:&quot;); int n = sc.nextInt(); int i = 1; while (i &lt;= n) &#123; System.out.print(i+&quot; &quot;); i++; &#125;&#125; do…while…即使循环条件不满足，也至少执行一次 1234567public static void main(String[] args) &#123; int i = 1; do &#123; System.out.print(i + &quot; &quot;); i++; &#125; while (i &lt; 6);&#125; for12345public static void main(String[] args) &#123; for (int i = 0; i &lt; 6; i++) &#123; System.out.print(i + &quot; &quot;); &#125;&#125; 增强for一般用于遍历数组和集合，数据类型为数组或集合的数据类型 123456public static void main(String[] args) &#123; int[] intArr = &#123;1, 2, 3, 4, 5&#125;; for (int i : intArr) &#123; System.out.print(i + &quot; &quot;); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"在线考试系统","slug":"208","date":"2021-07-01T20:38:36.000Z","updated":"2022-04-10T15:08:01.298Z","comments":true,"path":"208.html","link":"","permalink":"https://blog.zoutl.cn/208.html","excerpt":"","text":"项目地址GitHub地址前端代码地址：https://github.com/a6678696/ExamSystem2 后端代码地址：https://github.com/a6678696/ExamSystem 使用的技术本项目为前后端分离项目，使用的技术有：Spring Boot、Mybatis、MySQL5.6、Vue.js、Element UI 功能介绍考生功能注册、登录、在线考试（交卷、强制交卷、自动交卷）、查看成绩以及试卷详情、修改密码、注销登录 教师功能登录、发布试题（单选题和填空题）、查看全部试题（包括其他教师发布的试题）、我的试题管理（增删改查）、查看全部学生成绩、修改密码、注销登录 管理员功能和教师的功能一样，但是多了用户管理（添加、修改、查看用户信息）、全部试题管理、科目管理 图片展示考生考生注册 考生登录 考生界面 选择试题类型 考生考试 考生查看成绩 考生修改密码 考生注销登录 教师教师登录 教师界面 教师查看学生成绩 教师添加试题 教师查看全部试题 教师管理我的试题 教师修改密码 教师注销登录 管理员管理员登录 管理员界面 科目管理 用户管理 全部试题管理 PS.在本地IDE部署本项目的步骤查看博客：前后端分离项目在本地IDE部署步骤 | LeDao的博客 (zoutl.cn)","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"Spring Boot+Mybatis使用Element UI分页","slug":"207","date":"2021-07-01T14:22:02.000Z","updated":"2022-04-14T02:13:03.451Z","comments":true,"path":"207.html","link":"","permalink":"https://blog.zoutl.cn/207.html","excerpt":"","text":"前端向后端发送的数据有当前页、每页记录数，后端向前端发送的数据有查询到的数据集合、数据总记录数（满足查询条件的全部数据的总记录数） 前端分页代码12345678910&lt;el-pagination align=&quot;center&quot; style=&quot;margin-top: 8px&quot; background layout=&quot;prev, pager, next&quot; :current-page.sync=&quot;pagination.page&quot; :page-size.sync=&quot;pagination.size&quot; :total=&quot;pagination.count&quot; @current-change=&quot;handleCurrentChange&quot;&gt;&lt;/el-pagination&gt; 分页属性包括当前页，每页记录数，数据总记录数 12345pagination: &#123; page: 1, size: 2, count: 0,&#125; 更新当前页的值 1234//刷新当前页的值handleCurrentChange(page) &#123; this.pagination.page = page;&#125; 请求后台123456axios .get(&#x27;http://localhost/paper/getListFindByUserId?userId=&#x27; + sessionStorage.getItem(&quot;userId&quot;) + &#x27;&amp;page=&#x27; + this.pagination.page + &#x27;&amp;size=&#x27; + this.pagination.size) .then(response =&gt; (this.myPaper = response.data.rows, this.pagination.count = response.data.total)) .catch(function (error) &#123; console.log(error); &#125;); mapper.xml代码1234567891011121314151617181920212223&lt;select id=&quot;list&quot; parameterType=&quot;map&quot; resultMap=&quot;paperResult&quot;&gt; select * from t_paper &lt;where&gt; &lt;if test=&quot;userId != null&quot;&gt; and userId = #&#123;userId&#125; &lt;/if&gt; &lt;/where&gt; order by id desc &lt;if test=&quot;start != null and size != null&quot;&gt; limit #&#123;start&#125;,#&#123;size&#125; &lt;/if&gt;&lt;/select&gt; &lt;select id=&quot;getCount&quot; parameterType=&quot;map&quot; resultType=&quot;java.lang.Long&quot;&gt; select count(*) from t_paper &lt;where&gt; &lt;if test=&quot;userId != null&quot;&gt; and userId = #&#123;userId&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 请求的后端方法12345678910111213141516171819/** * 根据用户id获取试卷(分页) * * @param userId * @return */@RequestMapping(&quot;/getListFindByUserId&quot;)public Map getListFindByUserId(Integer userId, @RequestParam(value = &quot;page&quot;,required = false)Integer page, @RequestParam(value = &quot;size&quot;,required = false)Integer size) &#123; PageBean pageBean = new PageBean(page, size); Map resultMap = new HashMap&lt;&gt;(16); Map map = new HashMap&lt;&gt;(16); map.put(&quot;userId&quot;, userId); map.put(&quot;start&quot;, pageBean.getStart()); map.put(&quot;size&quot;, pageBean.getPageSize()); List&lt;Paper&gt; paperList = paperService.list(map); resultMap.put(&quot;total&quot;, paperService.getCount(map)); resultMap.put(&quot;rows&quot;, paperList); return resultMap;&#125; 分页Model类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 分页Model类 * * @author LeDao * @company * @create 2020-09-10 21:53 */public class PageBean &#123; /** * 第几页 */ private int page; /** * 每页记录数 */ private int pageSize; /** * 起始页 */ private int start; public PageBean(int page, int pageSize) &#123; super(); this.page = page; this.pageSize = pageSize; &#125; public int getPage() &#123; return page; &#125; public void setPage(int page) &#123; this.page = page; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public int getStart() &#123; return (page - 1) * pageSize; &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://blog.zoutl.cn/tags/Element-UI/"}]},{"title":"Element UI引入第三方图标","slug":"206","date":"2021-06-28T07:37:49.000Z","updated":"2022-03-26T19:24:38.396Z","comments":true,"path":"206.html","link":"","permalink":"https://blog.zoutl.cn/206.html","excerpt":"","text":"Element UI自带的图标数量太少了,并不能满足我们的开发需求 第三方图标地址iconfont-阿里巴巴矢量图标库 操作步骤 查找需要的图标,添加入库 点击右上角的购物车图标按钮，添加到项目，没有项目就新建 修改项目设置 修改图片（样式、名称等） 选择Font Class，下载至本地 将下载的压缩包解压后，将里面的文件复制到项目中 在项目中引用 1import &#x27;@/assets/myicon/iconfont.css&#x27;;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Element UI","slug":"Element-UI","permalink":"https://blog.zoutl.cn/tags/Element-UI/"}]},{"title":"使用路由实现组件切换","slug":"205","date":"2021-06-26T17:58:50.000Z","updated":"2022-04-14T01:58:02.971Z","comments":true,"path":"205.html","link":"","permalink":"https://blog.zoutl.cn/205.html","excerpt":"","text":"新建项目时选择自动下载vue-router 修改src/main.js12345678910111213141516import ElementUI from &#x27;element-ui&#x27; //新添加import &#x27;element-ui/lib/theme-chalk/index.css&#x27; //新添加，避免后期打包样式不同，要放在import App from &#x27;./App&#x27;;之前import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import router from &#x27;./router&#x27;Vue.config.productionTip = falseVue.use(ElementUI)//新添加/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, router, render: h =&gt; h(App), components: &#123;App&#125;, template: &#x27;&lt;App/&gt;&#x27;&#125;) 修改src/router/index.js12345678910111213141516171819202122import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;//引入组件import Student from &quot;../components/Student&quot;;import Teacher from &quot;../components/Teacher&quot;;Vue.use(Router)export default new Router(&#123; mode: &#x27;history&#x27;, //定义路由地址和组件 routes: [ &#123; path: &#x27;/Student&#x27;, component: Student &#125;, &#123; path: &#x27;/Teacher&#x27;, component: Teacher &#125; ]&#125;) App.vue1234567891011121314151617&lt;template&gt; &lt;div style=&quot;text-align: center&quot;&gt; &lt;router-link to=&quot;/Student&quot;&gt;学生&lt;/router-link&gt; &lt;router-link to=&quot;/Teacher&quot;&gt;教师&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;App&#x27;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Student.Vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;el-tag type=&quot;danger&quot; style=&quot;margin-top: 10px&quot;&gt;当前是学生表&lt;/el-tag&gt; &lt;el-table :data=&quot;students&quot; style=&quot;width: 60%;margin-left: 20%;margin-top: 20px&quot; border&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;编号&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;sex&quot; label=&quot;性别&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Student&#x27;, data()&#123; return&#123; students:[ &#123; id:1, name:&#x27;小米&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:2, name:&#x27;小花&#x27;, sex:&#x27;女&#x27; &#125;, &#123; id:3, name:&#x27;小明&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:4, name:&#x27;雪莉&#x27;, sex:&#x27;女&#x27; &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Teacher.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;el-tag type=&quot;warning&quot; style=&quot;margin-top: 10px&quot;&gt;当前是教师表&lt;/el-tag&gt; &lt;el-table :data=&quot;teachers&quot; style=&quot;width: 60%;margin-left: 20%;margin-top: 20px&quot; border&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;编号&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;sex&quot; label=&quot;性别&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Teacher&#x27;, data()&#123; return&#123; teachers:[ &#123; id:1, name:&#x27;Tom&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:2, name:&#x27;Sherry&#x27;, sex:&#x27;女&#x27; &#125;, &#123; id:3, name:&#x27;Jack&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:4, name:&#x27;Mary&#x27;, sex:&#x27;女&#x27; &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 结果","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"使用动态组件实现组件切换","slug":"204","date":"2021-06-26T16:40:12.000Z","updated":"2022-04-14T01:58:05.326Z","comments":true,"path":"204.html","link":"","permalink":"https://blog.zoutl.cn/204.html","excerpt":"","text":"定义两个组件Student.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;el-tag type=&quot;danger&quot; style=&quot;margin-top: 10px&quot;&gt;当前是学生表&lt;/el-tag&gt; &lt;el-table :data=&quot;students&quot; style=&quot;width: 60%;margin-left: 20%;margin-top: 20px&quot; border&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;编号&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;sex&quot; label=&quot;性别&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Student&#x27;, data()&#123; return&#123; students:[ &#123; id:1, name:&#x27;小米&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:2, name:&#x27;小花&#x27;, sex:&#x27;女&#x27; &#125;, &#123; id:3, name:&#x27;小明&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:4, name:&#x27;雪莉&#x27;, sex:&#x27;女&#x27; &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Teacher.vue 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div&gt; &lt;el-tag type=&quot;warning&quot; style=&quot;margin-top: 10px&quot;&gt;当前是教师表&lt;/el-tag&gt; &lt;el-table :data=&quot;teachers&quot; style=&quot;width: 60%;margin-left: 20%;margin-top: 20px&quot; border&gt; &lt;el-table-column prop=&quot;id&quot; label=&quot;编号&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;sex&quot; label=&quot;性别&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;Teacher&#x27;, data()&#123; return&#123; teachers:[ &#123; id:1, name:&#x27;Tom&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:2, name:&#x27;Sherry&#x27;, sex:&#x27;女&#x27; &#125;, &#123; id:3, name:&#x27;Jack&#x27;, sex:&#x27;男&#x27; &#125;, &#123; id:4, name:&#x27;Mary&#x27;, sex:&#x27;女&#x27; &#125; ] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在App.vue中引入上面两个组件App.vue 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div style=&quot;text-align: center&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;currentCom=&#x27;Student&#x27;&quot;&gt;查看学生&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;currentCom=&#x27;Teacher&#x27;&quot;&gt;查看教师&lt;/el-button&gt; &lt;component :is=&quot;currentCom&quot;&gt;&lt;/component&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Student from &#x27;./components/Student&#x27;import Teacher from &#x27;./components/Teacher&#x27;export default &#123; name: &#x27;App&#x27;, data () &#123; return &#123; currentCom: &#x27;&#x27; &#125; &#125;, components: &#123; Student, Teacher &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 效果 PS.本实例使用了Element UI，请先安装Element UI：基于 vue-cli 安装与卸载 Element UI | LeDao 的博客 (zoutl.cn)","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"基于vue-cli安装与卸载Element UI","slug":"203","date":"2021-06-26T15:37:50.000Z","updated":"2022-04-14T01:58:08.231Z","comments":true,"path":"203.html","link":"","permalink":"https://blog.zoutl.cn/203.html","excerpt":"","text":"安装安装方法一共有三个方法： 使用npm命令 使用cnpm命令 在package.json中添加 使用npm命令有三个地方可以执行npm命令 使用 CMD 命令打开项目文件夹后 使用 Git Bash 命令打开项目文件夹后 WebStorm 中使用 Terminal 命令窗口 1npm i element-ui -S 使用cnpm命令cnpm 是淘宝版 npm，如果因为网络原因无法使用 npm 命令，那么就可以使用 cnpm 命令，cnpm 安装和卸载 Element UI 的命令如下： 12345# 安装cnpm i element-ui -S# 卸载cnpm uninstall element-ui 在package.json中添加 打开 package.js 文件，找到 devDependencies 并在最后加上&quot;element-ui&quot;: &quot;^2.15.6&quot;，多个依赖之间用英文逗号,隔开 通过 npm install 或者 cnpm install 命令进行安装 123456789101112131415/*入口js:创建实例*/import ElementUI from &#x27;element-ui&#x27; //新添加import &#x27;element-ui/lib/theme-chalk/index.css&#x27; //新添加，避免后期打包样式不同，要放在import App from &#x27;./App&#x27;;之前import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;Vue.use(ElementUI)//新添加new Vue(&#123; el:&#x27;#app&#x27;, components:&#123; App &#125;, template:&#x27;&lt;App&gt;&lt;/App&gt;&#x27;&#125;) 到此，Element UI安装成功 使用导入在 src/main.js 中添加以下内容： 123import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(ElementUI) 添加的位置如下面代码所示： 123456789101112131415/*入口js:创建实例*/import ElementUI from &#x27;element-ui&#x27; //新添加import &#x27;element-ui/lib/theme-chalk/index.css&#x27; //新添加，避免后期打包样式不同，要放在import App from &#x27;./App&#x27;;之前import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;Vue.use(ElementUI)//新添加new Vue(&#123; el:&#x27;#app&#x27;, components:&#123; App &#125;, template:&#x27;&lt;App&gt;&lt;/App&gt;&#x27;&#125;) 使用新建ElementUI.vue，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 60%;margin-left: 20%;margin-top: 200px&quot; border&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot; align=&quot;center&quot;&gt;&lt;/el-table-column&gt; &lt;/el-table&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;ElementUI&#x27;, data () &#123; return &#123; tableData: [&#123; date: &#x27;2016-05-02&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1518 弄&#x27; &#125;, &#123; date: &#x27;2016-05-04&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1517 弄&#x27; &#125;, &#123; date: &#x27;2016-05-01&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1519 弄&#x27; &#125;, &#123; date: &#x27;2016-05-03&#x27;, name: &#x27;王小虎&#x27;, address: &#x27;上海市普陀区金沙江路 1516 弄&#x27; &#125;] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; App.vue代码如下： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;ElementUI&gt;&lt;/ElementUI&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ElementUI from &#x27;./components/ElementUI&#x27;export default &#123; name: &#x27;App&#x27;, components: &#123; ElementUI &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 结果 卸载有三个地方可以执行npm命令 使用 CMD 命令打开项目文件夹后 使用 Git Bash 命令打开项目文件夹后 WebStorm 中使用 Terminal 命令窗口 1npm uninstall element-ui","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://blog.zoutl.cn/tags/Element-UI/"}]},{"title":"基于vue-cli搭建自己的项目","slug":"202","date":"2021-06-26T13:49:35.000Z","updated":"2022-04-14T01:58:10.665Z","comments":true,"path":"202.html","link":"","permalink":"https://blog.zoutl.cn/202.html","excerpt":"","text":"概述在src/components下新建一个HelloWorld.vue文件，每个.vue文件都包括三个部分：&lt;template&gt;模版代码块，&lt;script&gt;是js代码块，&lt;style&gt;是样式代码块，其中如果&lt;style&gt;使用了scoped属性（让当前组件的样式不会修改到其它地方的样式，在父组件中是不能直接修改子组件的样式的，需要在父组件中使用vue的深度作用选择器），该样式只在本.vue文件下生效 HelloWolrd.vue1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p class=&quot;info&quot;&gt;&#123;&#123; info &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;HelloWorld&#x27;, data () &#123; return &#123; info: &#x27;Hello Vue!&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.info &#123; color: red; font-size: 20px;&#125;&lt;/style&gt; 修改App.vue删除App.vue的全部代码，重写，在&lt;template&gt;中使用组件，&lt;script&gt;中引入组件，&lt;style&gt;中写样式 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;HelloWorld&gt;&lt;/HelloWorld&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import HelloWorld from &#x27;./components/HelloWorld&#x27;//引入组件HelloWorld.vueexport default &#123; name: &#x27;App&#x27;, components: &#123; //映射组件标签,可以写成HelloWorld:HelloWorld,如果文件名和组件名一样那么可简写成HelloWorld HelloWorld &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 修改main.jssrc下的main.js 这个是项目入口配置文件，代码也删除重写 123456789101112/*入口js:创建实例*/import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;new Vue(&#123; el:&#x27;#app&#x27;, components:&#123; App &#125;, template:&#x27;&lt;App&gt;&lt;/App&gt;&#x27;&#125;) 启动项目","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"vue-cli脚手架新建和删除Vue项目","slug":"201","date":"2021-06-26T07:19:31.000Z","updated":"2022-04-14T13:12:42.965Z","comments":true,"path":"201.html","link":"","permalink":"https://blog.zoutl.cn/201.html","excerpt":"","text":"新建项目在 Vue 项目存储文件夹中打开 cmd ，输入命令：vue init webpack vue_demo，vue_demo 是项目名称，然后进行一些配置 项目配置项目名称 项目描述 作者信息 构建方式 是否安装vue-router现在不安装的话，后期可以在项目中安装 使用ESLintESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码，建议不使用 安装单元测试 安装E2E测试框架NightWatch 选择包管理工具 启动项目打开package.json文件，点击第9行左边的启动按钮，选择第一个选项启动即可 访问打开运行信息的地址即可访问项目，出现以下页面说明成功运行 要停止运行，使用快捷键CTRL+C，或者点击IDE的停止按钮 修改端口修改端口为80，修改 config 文件夹的 index.js，port:8080改为port:80 让项目启动时自动打开浏览器，修改 config 文件夹的 index.js，autoOpenBrower:false改为autoOpenBrower:true 删除项目直接删除对应文件夹即可 PS.如果一直卡住在/ fetchMetadata: sill pacote range manifest for，那就更换成淘宝的源 1npm config set registry https://registry.npm.taobao.org 查看设置结果 1npm config get registry","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.zoutl.cn/tags/Node-js/"}]},{"title":"安装vue-cli脚手架","slug":"200","date":"2021-06-26T06:34:18.000Z","updated":"2022-04-14T01:58:16.859Z","comments":true,"path":"200.html","link":"","permalink":"https://blog.zoutl.cn/200.html","excerpt":"","text":"安装Node.js官网：https://nodejs.org 下载第一个稳定版本，点击安装文件一直下一步即可 检验是否安装成功，分别输入命令node --version，npm -v都可以看到版本号说明Node.js安装完成 安装vue-cli脚手架打开CMD，输入命令：npm install -g vue-cli@2.9.6，运行 等待安装完成，输入命令：vue -V，看到版本号说明脚手架安装完成","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.zoutl.cn/tags/Node-js/"}]},{"title":"Vue.js Ajax(vue-resource)","slug":"199","date":"2021-06-26T04:56:28.000Z","updated":"2022-04-14T01:58:19.077Z","comments":true,"path":"199.html","link":"","permalink":"https://blog.zoutl.cn/199.html","excerpt":"","text":"引入1&lt;script src=&quot;https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js&quot;&gt;&lt;/script&gt; get请求1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue/2.4.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p style=&quot;color: red&quot;&gt;&#123;&#123;myInfo&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;get()&quot;&gt;获取&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; myInfo:&#x27;看这里&#x27; &#125;, methods:&#123; get: function () &#123; let _this = this; this.$http .get(&#x27;https://www.zoutl.cn/getFruitListJson&#x27;) .then(function (result) &#123; _this.myInfo = result.data; &#125;, function () &#123; console.log(&#x27;请求失败&#x27;); &#125;); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue/2.4.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue-resource/1.5.1/vue-resource.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p style=&quot;color: red&quot;&gt;&#123;&#123;myInfo&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;post()&quot;&gt;获取&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; myInfo: &#x27;看这里&#x27; &#125;, methods: &#123; post: function () &#123; let _this = this; this.$http .post(&#x27;https://www.zoutl.cn/getFruitJson2&#x27;, //传递的数据 &#123; id: 3, name: &#x27;香蕉&#x27;, num: 6 &#125;, //如果Web服务器无法处理编码为 application/json 的请求，可以启用 emulateJSON 选项 &#123; emulateJSON: true &#125; ) .then(function (result) &#123; _this.myInfo = result.data; &#125;, function () &#123; console.log(&#x27;请求失败&#x27;); &#125;); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js的事件处理器中Ajax请求无法通过this调用Vue实例的数据","slug":"198","date":"2021-06-26T04:21:49.000Z","updated":"2022-04-14T01:58:21.939Z","comments":true,"path":"198.html","link":"","permalink":"https://blog.zoutl.cn/198.html","excerpt":"","text":"解决办法Ajax请求外定义变量 let _this=this; Ajax请求内使用该变量调用Vue实例的数据 _this.数据名=要修改的值 错误的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; style=&quot;margin-left: 20%;margin-top: 10%&quot;&gt; &lt;p&gt;传递的数据:&lt;span style=&quot;color: red&quot;&gt;&#123;&#123;myInfo&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;输入水果的信息:&lt;/p&gt; 编号:&lt;input type=&quot;text&quot; v-model=&quot;fruitId&quot;/&gt;&amp;nbsp;&amp;nbsp; 名称:&lt;input type=&quot;text&quot; v-model=&quot;fruitName&quot;/&gt;&amp;nbsp;&amp;nbsp; 数量:&lt;input type=&quot;text&quot; v-model=&quot;fruitNum&quot;/&gt; &lt;button @click=&quot;submitData&quot;&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; fruitId: 1, fruitName: &#x27;苹果&#x27;, fruitNum: 3, myInfo: &#x27;这里显示传递的数据&#x27; &#125;, methods: &#123; submitData: function () &#123; axios .post(&#x27;https://www.zoutl.cn/getFruitJson2?id=&#x27; + this.fruitId + &#x27;&amp;name=&#x27; + this.fruitName + &#x27;&amp;num=&#x27; + this.fruitNum + &#x27;&#x27;) .then(function (response) &#123; let id = response.data.id; let name = response.data.name; let num = response.data.num; this.myInfo = &quot;编号:&quot; + id + &quot;，名称:&quot; + name + &quot;，数量:&quot; + num; &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 点击提交按钮后，红色字体内容不改变 修改后修改methods内的submitData方法 12345678910111213141516methods: &#123; submitData: function () &#123; let _this = this; axios .post(&#x27;https://www.zoutl.cn/getFruitJson2?id=&#x27; + this.fruitId + &#x27;&amp;name=&#x27; + this.fruitName + &#x27;&amp;num=&#x27; + this.fruitNum + &#x27;&#x27;) .then(function (response) &#123; let id = response.data.id; let name = response.data.name; let num = response.data.num; _this.myInfo = &quot;编号:&quot; + id + &quot;，名称:&quot; + name + &quot;，数量:&quot; + num; &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125;&#125; 点击提交按钮后，红色字体内容改变","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js Ajax(axios)","slug":"197","date":"2021-06-25T17:53:16.000Z","updated":"2022-04-14T01:58:26.201Z","comments":true,"path":"197.html","link":"","permalink":"https://blog.zoutl.cn/197.html","excerpt":"","text":"概述Vue.js 2.0版本推荐使用axios来完成ajax请求，axios是一个基于Promise的HTTP库，可以用在浏览器和node.js中，推荐使用axios，不推荐使用vue-resource 引入直接在页面引入1&lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt; 使用命令安装1npm install --save axios get请求示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;returnInfo&#125;&#125;&lt;/p&gt; &lt;p&gt;总数量：&#123;&#123;getTotal&#125;&#125;&lt;/p&gt; &lt;p v-for=&quot;(value,index) in returnInfo&quot;&gt; 编号：&#123;&#123;value.id&#125;&#125;，名称：&#123;&#123;value.name&#125;&#125;，数量：&#123;&#123;value.num&#125;&#125; &lt;button @click=&quot;addOne(index)&quot;&gt;加1&lt;/button&gt; &lt;button @click=&quot;lessOne(index)&quot;&gt;减1&lt;/button&gt; &lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data() &#123; return &#123; returnInfo: null, total: 0 &#125; &#125;, mounted() &#123; axios .get(&#x27;https://www.zoutl.cn/getFruitListJson&#x27;) .then(response =&gt; (this.returnInfo = response.data.rows)) .catch(function (error) &#123; console.log(error); &#125;); &#125;, methods: &#123; //水果数量加1 addOne: function (index) &#123; this.returnInfo[index].num++; &#125;, //水果数量减1 lessOne: function (index) &#123; if (this.returnInfo[index].num &gt; 0) &#123; this.returnInfo[index].num--; &#125; &#125; &#125;, computed: &#123; //计算水果总数 getTotal: function () &#123; let total = 0; for (let i = 0; i &lt; this.returnInfo.length; i++) &#123; total += this.returnInfo[i].num; &#125; return total; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; post请求示例 直接在url中拼接要传递的数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; style=&quot;margin-left: 20%;margin-top: 10%&quot;&gt; &lt;p&gt;输入水果的信息:&lt;/p&gt; 编号:&lt;input type=&quot;text&quot; v-model=&quot;fruitId&quot;/&gt;&amp;nbsp;&amp;nbsp; 名称:&lt;input type=&quot;text&quot; v-model=&quot;fruitName&quot;/&gt;&amp;nbsp;&amp;nbsp; 数量:&lt;input type=&quot;text&quot; v-model=&quot;fruitNum&quot;/&gt; &lt;button @click=&quot;submitData&quot;&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; fruitId: 1, fruitName: &#x27;苹果&#x27;, fruitNum: 3 &#125;, methods: &#123; submitData: function () &#123; axios .post(&#x27;https://www.zoutl.cn/getFruitJson2?id=&#x27; + this.fruitId + &#x27;&amp;name=&#x27; + this.fruitName + &#x27;&amp;num=&#x27; + this.fruitNum + &#x27;&#x27;) .then(function (response) &#123; let id = response.data.id; let name = response.data.name; let num = response.data.num; alert(&quot;编号:&quot; + id + &quot;，名称:&quot; + name + &quot;，数量:&quot; + num); &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用URLSearchParams传递数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot; style=&quot;margin-left: 20%;margin-top: 10%&quot;&gt; &lt;p&gt;输入水果的信息:&lt;/p&gt; 编号:&lt;input type=&quot;text&quot; v-model=&quot;fruitId&quot;/&gt;&amp;nbsp;&amp;nbsp; 名称:&lt;input type=&quot;text&quot; v-model=&quot;fruitName&quot;/&gt;&amp;nbsp;&amp;nbsp; 数量:&lt;input type=&quot;text&quot; v-model=&quot;fruitNum&quot;/&gt; &lt;button @click=&quot;submitData&quot;&gt;提交&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; fruitId: 1, fruitName: &#x27;苹果&#x27;, fruitNum: 3, myInfo: &#x27;&#x27; &#125;, methods: &#123; submitData: function () &#123; let param = new URLSearchParams(); param.append(&quot;id&quot;, this.fruitId); param.append(&quot;name&quot;, this.fruitName); param.append(&quot;num&quot;, this.fruitNum); axios .post(&#x27;https://www.zoutl.cn/getFruitJson2&#x27;, param) .then(function (response) &#123; let id = response.data.id; let name = response.data.name; let num = response.data.num; alert(&quot;编号:&quot; + id + &quot;，名称:&quot; + name + &quot;，数量:&quot; + num); &#125;) .catch(function (error) &#123; console.log(error); &#125;); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Spring Boot解决跨域问题","slug":"196","date":"2021-06-25T15:55:55.000Z","updated":"2022-04-14T02:12:54.624Z","comments":true,"path":"196.html","link":"","permalink":"https://blog.zoutl.cn/196.html","excerpt":"","text":"概述如果没有实现跨域，前后端分离项目中Ajax就无法返回数据，方法有两个：（推荐使用第二种） 使用@CrossOrigin注解 新建一个配置类，实现WebMvcConfigurer的addCorsMappings方法 实现过程使用@CrossOrigin注解Spring Boot解决跨域使用@CrossOrigin注解，该注解有两个参数： origins： 允许可访问的域列表 maxAge:准备响应前的缓存持续的最大时间（以秒为单位） 在指定类上方添加注解，整个类的方法都可以跨域访问 在指定方法上方添加注解，只有这个方法可以跨域访问 新建跨域配置类新建一个配置类，实现WebMvcConfigurer的addCorsMappings方法（推荐使用） 12345678910111213141516171819202122232425package com.ledao.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;/** * 实现跨域 * * @author LeDao * @company * @create 2022-03-29 22:32 */@Configurationpublic class WebAppConfigurer implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true) .allowedMethods(&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) .maxAge(3600); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"}]},{"title":"Vue.js 路由","slug":"195","date":"2021-06-25T13:38:22.000Z","updated":"2022-04-14T01:58:32.453Z","comments":true,"path":"195.html","link":"","permalink":"https://blog.zoutl.cn/195.html","excerpt":"","text":"概述Vue.js 路由允许我们通过不同的 URL 访问不同的内容，通过 Vue.js 可以实现多视图的单页Web应用 引入1&lt;script src=&quot;https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js&quot;&gt;&lt;/script&gt; 简单实例12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航. --&gt; &lt;!-- 通过传入 `to` 属性指定链接. --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt; &lt;router-link to=&quot;/blog1&quot;&gt;第一篇博客&lt;/router-link&gt; &lt;router-link to=&quot;/blog2&quot;&gt;第二篇博客&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; // 1. 定义（路由）组件 let blog1 = &#123;template: &#x27;&lt;p style=&quot;color: blue&quot;&gt;现在是第一篇博客&lt;/p&gt;&#x27;&#125; let blog2 = &#123;template: &#x27;&lt;p style=&quot;color: red&quot;&gt;现在是第二篇博客&lt;/p&gt;&#x27;&#125; // 2. 定义路由 let routes = [ &#123;path: &#x27;/blog1&#x27;, component: blog1&#125;, &#123;path: &#x27;/blog2&#x27;, component: blog2&#125; ] // 3. 创建 router 实例，然后传 `routes` 配置 let router = new VueRouter(&#123;routes&#125;) // 4. 创建和挂载根实例 new Vue(&#123; router &#125;).$mount(&#x27;#app&#x27;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js自定义指令","slug":"194","date":"2021-06-25T13:08:25.000Z","updated":"2022-04-14T01:58:35.498Z","comments":true,"path":"194.html","link":"","permalink":"https://blog.zoutl.cn/194.html","excerpt":"","text":"概述除了默认设置的核心指令( v-model 和 v-show )，Vue 也允许注册自定义指令 自定义指令分为全局指令和局部指令 下面分别注册全局指令和局部指令，指令功能：在页面加载时，元素获得焦点 全局指令每个实例都可以使用 1234567891011121314&lt;div id=&quot;app&quot; style=&quot;margin-left: 444px&quot;&gt; &lt;p style=&quot;color: red&quot;&gt;页面加载时,input元素自动获取焦点&lt;/p&gt; 姓名:&lt;input type=&quot;text&quot; v-focus&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.directive(&#x27;focus&#x27;, &#123; inserted: function (elements) &#123; elements.focus(); &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27; &#125;)&lt;/script&gt; 局部指令只能在注册局部指令的实例中使用 12345678910111213141516&lt;div id=&quot;app&quot; style=&quot;margin-left: 444px&quot;&gt; &lt;p style=&quot;color: red&quot;&gt;页面加载时,input元素自动获取焦点&lt;/p&gt; 姓名:&lt;input type=&quot;text&quot; v-focus&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, directives: &#123; focus: &#123; inserted: function (el) &#123; el.focus(); &#125; &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js 组件 - 自定义事件","slug":"193","date":"2021-06-25T12:19:11.000Z","updated":"2022-04-14T01:58:37.947Z","comments":true,"path":"193.html","link":"","permalink":"https://blog.zoutl.cn/193.html","excerpt":"","text":"概述父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，就需要使用自定义事件 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件，以下实例中子组件已经和它外部完全解耦了，它所做的只是触发一个父组件关心的内部事件 代码1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot; style=&quot;text-align: center&quot;&gt; &lt;p style=&quot;color: red&quot;&gt;&#123;&#123;total&#125;&#125;&lt;/p&gt; &lt;my-button v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/my-button&gt; &lt;my-button v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/my-button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#x27;my-button&#x27;, &#123; template: &#x27;&lt;button @click=&quot;incrementHandler&quot;&gt;&#123;&#123;counter&#125;&#125;&lt;/button&gt;&#x27;, data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; incrementHandler: function () &#123; this.counter++; this.$emit(&#x27;increment&#x27;); &#125; &#125; &#125;) new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total++; &#125; &#125; &#125;)&lt;/script&gt; 结果 代码解读点击按钮时，触发子组件内部的incrementHandler点击事件（当前按钮的标签值counter加1，触发父组件的子组件my-button外部的increment事件），increment事件即执行Vue实例的incrementTotal方法（total加1） 子组件内部：子组件的代码，例如上面的代码中子组件的内部就是&lt;button @click=”incrementHandler”&gt;&lt;/button&gt; 子组件的外部：&lt;子组件名称&gt;&lt;/子组件名称&gt;多出来的内容，例如上面的代码中子组件的外部就是v-on:increment=”incrementTotal”","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"父组件向子组件传递数据","slug":"192","date":"2021-06-25T11:47:35.000Z","updated":"2022-04-14T01:58:41.000Z","comments":true,"path":"192.html","link":"","permalink":"https://blog.zoutl.cn/192.html","excerpt":"","text":"概述prop 是子组件用来接受父组件传递过来的数据的一个自定义属性 父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 “prop” 关于父组件和子组件：（下面的这段话中相同颜色代表同一组件） 我们将某段代码封装成一个组件，而这个组件又在另一个组件中被引入，而引入该封装的组件的组件叫做父组件（另一个组件），被引入的组件叫做子组件（这个组件） 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;-----------------------------------------------&lt;h3 style=&quot;color: red&quot;&gt;传递静态数据&lt;/h3&gt;&lt;div id=&quot;app1&quot;&gt; &lt;my-span1 message11=&quot;11&quot; message22=&quot;22&quot;&gt;&lt;/my-span1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&quot;my-span1&quot;, &#123; //传递多个数据 props: [&#x27;message11&#x27;, &#x27;message22&#x27;], template: &#x27;&lt;span&gt;message11=&#123;&#123;message11&#125;&#125;,message22=&#123;&#123;message22&#125;&#125;&lt;/span&gt;&#x27; &#125;) new Vue(&#123; el: &#x27;#app1&#x27; &#125;)&lt;/script&gt;-----------------------------------------------&lt;h3 style=&quot;color: red&quot;&gt;传递动态数据&lt;/h3&gt;&lt;div id=&quot;app2&quot;&gt; 父组件内容: &lt;input type=&quot;text&quot; v-model=&quot;parentMessage&quot;&gt; &lt;br&gt; 子组件内容: &lt;my-span1 v-bind:message2=&quot;parentMessage&quot;&gt;&lt;/my-span1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#x27;my-span1&#x27;, &#123; //传递单个数据 props: [&#x27;message2&#x27;], template: &#x27;&lt;span&gt;&#123;&#123;message2&#125;&#125;&lt;/span&gt;&#x27; &#125;) new Vue(&#123; el: &#x27;#app2&#x27;, data: &#123; parentMessage: &#x27;123456&#x27; &#125; &#125;)&lt;/script&gt;-----------------------------------------------&lt;/body&gt;&lt;/html&gt; 结果","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js组件","slug":"191","date":"2021-06-25T07:02:30.000Z","updated":"2022-04-14T01:58:42.986Z","comments":true,"path":"191.html","link":"","permalink":"https://blog.zoutl.cn/191.html","excerpt":"","text":"概述Vue.js组件有全局组件和局部组件 全局组件所有实例都能用，注册方法如下 1234//全局组件Vue.component(&#x27;myh1&#x27;, &#123; template: &#x27;&lt;h1 style=&quot;color: red&quot;&gt;我的全局组件:myh1&lt;/h1&gt;&#x27;&#125;) 局部组件在实例选项中注册，组件只能在这个实例中使用，注册方法如下 1234567//局部组件let Child = &#123; template: &#x27;&lt;h1&gt;我的局部组件:Child&lt;/h1&gt;&#x27;&#125;let Child2 = &#123; template: &#x27;&lt;h1&gt;我的局部组件:Child2&lt;/h1&gt;&#x27;&#125; 组件使用创建一个js文件专门用于定义组件 1234567891011//全局组件Vue.component(&#x27;myh1&#x27;, &#123; template: &#x27;&lt;h1 style=&quot;color: red&quot;&gt;我的全局组件:myh1&lt;/h1&gt;&#x27;&#125;)//局部组件let Child = &#123; template: &#x27;&lt;h1&gt;我的局部组件:Child&lt;/h1&gt;&#x27;&#125;let Child2 = &#123; template: &#x27;&lt;h1&gt;我的局部组件:Child2&lt;/h1&gt;&#x27;&#125; Vue实例使用组件 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/component.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;测试app1（只有全局组件myh1生效，因为Vue实例中没有使用任何局部组件）&lt;div id=&quot;app1&quot;&gt; &lt;myh1&gt;&lt;/myh1&gt; &lt;myh2&gt;&lt;/myh2&gt; &lt;myh3&gt;&lt;/myh3&gt;&lt;/div&gt;测试app2（全局组件myh1和局部组件（Child，Child2）都生效）&lt;div id=&quot;app2&quot;&gt; &lt;myh1&gt;&lt;/myh1&gt; &lt;myh2&gt;&lt;/myh2&gt; &lt;myh3&gt;&lt;/myh3&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app1&#x27; &#125;) new Vue(&#123; el: &#x27;#app2&#x27;, components: &#123; &#x27;myh2&#x27;: Child, &#x27;myh3&#x27;: Child2 &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js遍历数组时获取对象的下标","slug":"190","date":"2021-06-25T05:59:36.000Z","updated":"2022-04-14T01:58:46.465Z","comments":true,"path":"190.html","link":"","permalink":"https://blog.zoutl.cn/190.html","excerpt":"","text":"概述v-for=”(value, index) in 数组名” 第一个参数表示遍历时的对象，第二个参数则代表下标（参数值可以根据自己的需求设置） 参考代码使用了数组下标设置数组的值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;h3 style=&quot;color: red&quot;&gt;总价：&#123;&#123;calculatePriceTotal&#125;&#125;&lt;/h3&gt; &lt;h3 v-for=&quot;(value, index) in snacks&quot;&gt; &lt;div style=&quot;background: beige&quot;&gt; &lt;p style=&quot;color: blue&quot;&gt;数组下标:&#123;&#123;index&#125;&#125;&amp;nbsp;&amp;nbsp;对象:&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;p&gt;编号:&#123;&#123;value.id&#125;&#125;&amp;nbsp;&amp;nbsp;名称:&#123;&#123;value.name&#125;&#125;&amp;nbsp;&amp;nbsp;价格:&#123;&#123;value.price&#125;&#125;&amp;nbsp;&amp;nbsp;数量:&#123;&#123;value.num&#125;&#125;&amp;nbsp;&amp;nbsp;当前商品总价：&#123;&#123;value.num * value.price&#125;&#125;&lt;/p&gt; &lt;div style=&quot;margin-top: 5px&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;value.num&quot;&gt; &lt;button @click=&quot;addNum(index)&quot;&gt;加1&lt;/button&gt; &lt;button @click=&quot;lessNum(index)&quot;&gt;减1&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/h3&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; snacks: [ &#123;id: 1, name: &#x27;零食1&#x27;, price: 11, num: 3&#125;, &#123;id: 2, name: &#x27;零食2&#x27;, price: 5, num: 2&#125;, &#123;id: 3, name: &#x27;零食3&#x27;, price: 8, num: 6&#125; ] &#125;, methods: &#123; addNum: function (index) &#123; this.snacks[index].num++; &#125;, lessNum: function (index) &#123; if (this.snacks[index].num &gt; 0) &#123; this.snacks[index].num--; &#125; &#125; &#125;, computed: &#123; calculatePriceTotal: function () &#123; let total = 0; for (let i = 0; i &lt; this.snacks.length; i++) &#123; total += parseInt(this.snacks[i].num) * parseInt(this.snacks[i].price); &#125; return total; &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js表单","slug":"189","date":"2021-06-25T02:05:22.000Z","updated":"2022-04-14T01:58:50.285Z","comments":true,"path":"189.html","link":"","permalink":"https://blog.zoutl.cn/189.html","excerpt":"","text":"概述用 v-model 指令在表单控件元素上创建双向数据绑定 输入框123456789101112131415161718&lt;div id=&quot;app&quot; style=&quot;text-align: center&quot;&gt; &lt;p&gt;info1:&lt;/p&gt; &lt;p&gt;&#123;&#123;info1&#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;info1&quot; placeholder=&quot;请输入内容...&quot; style=&quot;width: 333px&quot;&gt; &lt;hr&gt; &lt;p&gt;info2:&lt;/p&gt; &lt;p style=&quot;white-space: pre&quot;&gt;&#123;&#123;info2&#125;&#125;&lt;/p&gt; &lt;textarea v-model=&quot;info2&quot; placeholder=&quot;输入多行文本...&quot; style=&quot;width: 333px;height: 222px&quot;&gt;&lt;/textarea&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; info1:&#x27;LeDao的博客:http://www.zoutl.cn&#x27;, info2:&#x27;LeDao的博客:\\r\\nhttp://www.zoutl.cn&#x27; &#125; &#125;)&lt;/script&gt; 单选按钮123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;Edge&quot; value=&quot;Edge&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;Edge&quot;&gt;Edge&lt;/label&gt; &lt;input type=&quot;radio&quot; id=&quot;Chrome&quot; value=&quot;Chrome&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;Chrome&quot;&gt;Chrome&lt;/label&gt; &lt;p&gt;当前选中:&lt;span style=&quot;color: red&quot;&gt;&#123;&#123;picked&#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; picked: &#x27;Edge&#x27; &#125; &#125;)&lt;/script&gt; 复选框复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组 12345678910111213141516171819202122&lt;div id=&quot;app&quot; style=&quot;margin-left: 200px&quot;&gt; &lt;p&gt;单个复选框:&lt;/p&gt; &lt;input type=&quot;checkbox&quot; id=&quot;flag&quot; v-model=&quot;checkValue&quot;&gt; &lt;label for=&quot;flag&quot;&gt;&#123;&#123;checkValue ? &#x27;是&#x27; : &#x27;否&#x27;&#125;&#125;&lt;/label&gt; &lt;p&gt;多个复选框:&lt;/p&gt; &lt;input type=&quot;checkbox&quot; id=&quot;Edge&quot; value=&quot;Edge&quot; v-model=&quot;browers&quot;&gt; &lt;label for=&quot;Edge&quot;&gt;Edge&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;Chrome&quot; value=&quot;Chrome&quot; v-model=&quot;browers&quot;&gt; &lt;label for=&quot;Chrome&quot;&gt;Chrome&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;Firefox&quot; value=&quot;Firefox&quot; v-model=&quot;browers&quot;&gt; &lt;label for=&quot;Firefox&quot;&gt;Firefox&lt;/label&gt; &lt;p&gt;选择的浏览器:&lt;span style=&quot;color: red&quot;&gt;&#123;&#123;browers&#125;&#125;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; checkValue: true, browers: [] &#125; &#125;)&lt;/script&gt; select列表1234567891011121314151617&lt;div id=&quot;app&quot; style=&quot;margin-left: 222px&quot;&gt; &lt;p&gt;选择的浏览器是:&lt;span style=&quot;color: red&quot;&gt;&#123;&#123;mySelect&#125;&#125;&lt;/span&gt;&lt;/p&gt; &lt;select v-model=&quot;mySelect&quot; name=&quot;browers&quot;&gt; &lt;option value=&quot;&quot;&gt;选择一个浏览器&lt;/option&gt; &lt;option value=&quot;Edge&quot;&gt;Edge&lt;/option&gt; &lt;option value=&quot;Chrome&quot;&gt;Chrome&lt;/option&gt; &lt;option value=&quot;Firefox&quot;&gt;Firefox&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; mySelect: &#x27;&#x27; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js事件处理器","slug":"188","date":"2021-06-24T17:55:10.000Z","updated":"2022-04-14T01:58:52.614Z","comments":true,"path":"188.html","link":"","permalink":"https://blog.zoutl.cn/188.html","excerpt":"","text":"概述事件监听使用 v-on 指令 v-on:click点击事件，可以简写成@click 代码1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot; style=&quot;text-align: center&quot;&gt; &lt;h3&gt;计数器：&lt;span style=&quot;color: red&quot;&gt;&#123;&#123;counter&#125;&#125;&lt;/span&gt;&lt;/h3&gt; &lt;button v-on:click=&quot;counter++&quot;&gt;加1&lt;/button&gt; &lt;button @click=&quot;counter--&quot;&gt;减1&lt;/button&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;number&quot;&gt; &lt;button @click=&quot;add(number)&quot;&gt;加&lt;/button&gt; &lt;br&gt; &lt;input type=&quot;text&quot; v-model=&quot;number2&quot;&gt; &lt;button @click=&quot;less(number2)&quot;&gt;减&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0, number: 0, number2: 0 &#125;, methods: &#123; add: function (number) &#123; this.counter += parseInt(number); &#125;, less: function (number2) &#123; this.counter -= parseInt(number2); &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"一个优秀的制作GIF动图的软件：ScreenToGif","slug":"187","date":"2021-06-24T16:41:53.000Z","updated":"2022-04-10T15:06:12.907Z","comments":true,"path":"187.html","link":"","permalink":"https://blog.zoutl.cn/187.html","excerpt":"","text":"下载与安装官网：https://www.screentogif.com/ 使用打开软件，选择录像机 调整录屏窗口大小 点击右下角的红色圆点开始录像 点击右下角的蓝色正方形完成录像 选择文件、另存为、保存即可得到gif动图","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"Vue.js样式绑定","slug":"186","date":"2021-06-24T14:56:22.000Z","updated":"2022-04-14T01:58:58.738Z","comments":true,"path":"186.html","link":"","permalink":"https://blog.zoutl.cn/186.html","excerpt":"","text":"概述class 与 style 是 HTML 元素的属性，用于设置元素的样式，我们可以用 v-bind 来设置样式属性。 Vue.js v-bind 在处理 class 和 style 时， 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。 class属性绑定①使用属性值 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue测试&lt;/title&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .active &#123; width: 100px; height: 100px; background: green; &#125; .active2 &#123; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; 第一种方式： &lt;div v-bind:class=&quot;isActive?&#x27;active&#x27;:&#x27;active2&#x27;&quot;&gt;&lt;/div&gt; 第二种方式： &lt;div v-bind:class=&quot;&#123; &#x27;active2&#x27;: isActive,&#x27;active&#x27;:!isActive &#125;&quot;&gt;&lt;/div&gt; &lt;br&gt; &lt;button v-on:click=&quot;modifyClass&quot;&gt;改变样式&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isActive: true &#125;, methods: &#123; modifyClass: function () &#123; this.isActive = !this.isActive; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②使用对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue测试&lt;/title&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .active &#123; width: 100px; height: 100px; background: green; &#125; .active2 &#123; width: 100px; height: 100px; background: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;classObject: &#123; &#x27;active&#x27;: &#123;&#123;classObject.active&#125;&#125;, &#x27;active2&#x27;: &#123;&#123;classObject.active2&#125;&#125; &#125;&lt;/p&gt; &lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt; &lt;br&gt; &lt;button v-on:click=&quot;modifyClass&quot;&gt;改变样式&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; classObject: &#123; &#x27;active&#x27;: true, &#x27;active2&#x27;: false &#125; &#125;, methods: &#123; modifyClass: function () &#123; this.classObject.active = !this.classObject.active; this.classObject.active2 = !this.classObject.active2; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ③数组语法 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue测试&lt;/title&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .active &#123; width: 100px; height: 100px; &#125; .active2 &#123; background: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;class=&quot;&#123;&#123;activeClass&#125;&#125; &#123;&#123;active2Class&#125;&#125;&quot;&lt;/p&gt; &lt;div v-bind:class=&quot;[activeClass,active2Class]&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; activeClass: &#x27;active&#x27;, active2Class: &#x27;active2&#x27; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue.js style(内联样式)①在 v-bind:style 直接设置样式 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;p v-bind:style=&quot;&#123;color:fontColor,fontSize:fontSize+&#x27;px&#x27;&#125;&quot;&gt;LeDao的博客&lt;/p&gt; &lt;button v-on:click=&quot;bigFontSize&quot;&gt;增大字号&lt;/button&gt; &lt;button v-on:click=&quot;smallFontSize&quot;&gt;减小字号&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; fontColor: &#x27;red&#x27;, fontSize: 15 &#125;, methods: &#123; bigFontSize: function () &#123; this.fontSize++; &#125;, smallFontSize: function () &#123; this.fontSize--; &#125; &#125; &#125;)&lt;/script&gt; ②绑定一个对象 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p v-bind:style=&quot;styleObject&quot;&gt;LeDao的博客：http://www.zoutl.cn&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; styleObject: &#123; color: &#x27;red&#x27;, fontSize: &#x27;33px&#x27; &#125; &#125; &#125;)&lt;/script&gt; ③绑定多个对象 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;p v-bind:style=&quot;[style1,style2]&quot;&gt;LeDao的博客&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; style1:&#123; &#x27;color&#x27;:&#x27;green&#x27;, &#x27;font-size&#x27;:&#x27;33px&#x27; &#125;, style2:&#123; &#x27;font-weight&#x27;:&#x27;bold&#x27; &#125; &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js监听属性","slug":"185","date":"2021-06-24T13:35:43.000Z","updated":"2022-04-14T01:59:01.447Z","comments":true,"path":"185.html","link":"","permalink":"https://blog.zoutl.cn/185.html","excerpt":"","text":"概述通过 watch 来响应数据的变化 代码12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=&quot;app&quot; style=&quot;text-align: center&quot;&gt; &lt;h3&gt; 计数器:&#123;&#123;counter&#125;&#125; &lt;span v-if=&quot;seen&quot;&gt;（ 修改前值为：&lt;span style=&quot;color: blue&quot;&gt;&#123;&#123;oldVal&#125;&#125;&lt;/span&gt;， 修改后值为：&lt;span style=&quot;color: red&quot;&gt;&#123;&#123;newVal&#125;&#125;&lt;/span&gt;） &lt;/span&gt; &lt;/h3&gt; &lt;button v-on:click=&quot;addCounter&quot;&gt;自加&lt;/button&gt; &lt;button v-on:click=&quot;lessCounter&quot;&gt;自减&lt;/button&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; counter: 0, seen: false, oldVal: 0, newVal: 0 &#125;, methods: &#123; addCounter: function () &#123; this.counter++; &#125;, lessCounter: function () &#123; if (this.counter &gt; 0) &#123; this.counter--; &#125; &#125; &#125;, watch: &#123; //第一个参数是新的值（改变后），第二个是旧的值（改变前） counter: function (newValue, oldValue) &#123; this.oldVal = oldValue; this.newVal = newValue; this.seen = true; &#125; &#125; &#125;)&lt;/script&gt; 结果","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js计算属性","slug":"184","date":"2021-06-24T07:17:50.000Z","updated":"2022-04-14T01:59:04.265Z","comments":true,"path":"184.html","link":"","permalink":"https://blog.zoutl.cn/184.html","excerpt":"","text":"概述计算属性关键词: computed 计算属性在处理一些复杂逻辑时是很有用的，在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以 代码1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;p&gt;计算X1²+X2²-2X1+3X2,其中X1=&#123;&#123;X1&#125;&#125;,X2=&#123;&#123;X2&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;X1&#125;&#125; * &#123;&#123;X1&#125;&#125; + &#123;&#123;X2&#125;&#125; * &#123;&#123;X2&#125;&#125; - 2 * &#123;&#123;X1&#125;&#125; + 3 * &#123;&#123;X2&#125;&#125;=&lt;span style=&quot;color: red&quot;&gt;&#123;&#123;calculate&#125;&#125;&lt;/span&gt;&lt;/p&gt; 输入X1:&lt;input type=&quot;text&quot; v-model=&quot;X1&quot;&gt;， 输入X2:&lt;input type=&quot;text&quot; v-model=&quot;X2&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; X1: 5, X2: 3 &#125;, computed: &#123; calculate: function () &#123; return this.X1 * this.X1 + this.X2 * this.X2 - 2 * this.X1 + 3 * this.X2; &#125; &#125; &#125;)&lt;/script&gt; 在输入框改变值，结果也会随之改变","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js循环语句","slug":"183","date":"2021-06-24T06:31:45.000Z","updated":"2022-04-15T07:48:33.306Z","comments":true,"path":"183.html","link":"","permalink":"https://blog.zoutl.cn/183.html","excerpt":"","text":"概述循环使用 v-for 指令 v-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名 如果要限制遍历的数量，则格式为：site in sites.slice(0,3)，3为数量代表只遍历3个 迭代数组12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;p v-for=&quot;student in students&quot;&gt; &#123;&#123;student.name&#125;&#125;的年龄：&#123;&#123;student.age&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; students: [ &#123;name: &#x27;Tom&#x27;, age: 14&#125;, &#123;name: &#x27;Mary&#x27;, age: 12&#125;, &#123;name: &#x27;Sherry&#x27;, age: 15&#125; ] &#125; &#125;)&lt;/script&gt; 迭代对象1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(value,key,index) in student&quot;&gt; &#123;&#123;index&#125;&#125;---&#123;&#123;key&#125;&#125;:&#123;&#123;value&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; student: &#123; name: &#x27;Tom&#x27;, age: 14, sex: &#x27;男&#x27; &#125; &#125; &#125;)&lt;/script&gt; 迭代整数12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;p&gt;遍历1到&lt;span&gt;&#123;&#123;num&#125;&#125;&lt;/span&gt;:&lt;/p&gt; &lt;span v-for=&quot;n in num&quot; v-if=&quot;n&lt;num&quot;&gt;&#123;&#123;n&#125;&#125;，&lt;/span&gt; &lt;span v-else&gt;&#123;&#123;num&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; num:33 &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Vue.js条件语句","slug":"182","date":"2021-06-24T05:12:31.000Z","updated":"2022-04-14T01:59:11.034Z","comments":true,"path":"182.html","link":"","permalink":"https://blog.zoutl.cn/182.html","excerpt":"","text":"v-if1234567891011&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;flag&quot;&gt;flag是true就显示我&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true &#125; &#125;)&lt;/script&gt; v-else123456789101112&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;flag&quot;&gt;flag==true&lt;/p&gt; &lt;p v-else&gt;flag==false&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true &#125; &#125;)&lt;/script&gt; v-else-if1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;type===&#x27;A&#x27;&quot;&gt;A&lt;/p&gt; &lt;p v-else-if=&quot;type===&#x27;B&#x27;&quot;&gt;B&lt;/p&gt; &lt;p v-else-if=&quot;type===&#x27;C&#x27;&quot;&gt;C&lt;/p&gt; &lt;p v-else&gt;D&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; type: &#x27;C&#x27; &#125; &#125;)&lt;/script&gt; v-show1234567891011&lt;div id=&quot;app&quot;&gt; &lt;p v-show=&quot;flag&quot;&gt;11111111&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; flag: true &#125; &#125;)&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Spring Boot项目添加webapp目录","slug":"181","date":"2021-06-24T03:11:52.000Z","updated":"2022-04-14T02:45:37.062Z","comments":true,"path":"181.html","link":"","permalink":"https://blog.zoutl.cn/181.html","excerpt":"","text":"打开Project Structure 添加Web服务 添加web.xml文件 选择web.xml的文件路径","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"创建第一个Vue应用","slug":"180","date":"2021-06-24T01:41:23.000Z","updated":"2022-04-14T01:59:24.075Z","comments":true,"path":"180.html","link":"","permalink":"https://blog.zoutl.cn/180.html","excerpt":"","text":"引入Vue.js 下载js文件后引入 1&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; 使用CDN方法 开发环境版本 12&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js&quot;&gt;&lt;/script&gt; 生产环境版本 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2&quot;&gt;&lt;/script&gt; HTML代码12345&lt;div id=&quot;app1&quot;&gt; &lt;p v-bind:style=&quot;flag?&#x27;color:blue&#x27;:&#x27;color:red&#x27;&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;button v-on:click=&quot;modifyColor&quot;&gt;改变p的颜色&lt;/button&gt;&lt;/div&gt; JavaScript代码123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; new Vue(&#123; el: &#x27;#app1&#x27;, data: &#123; message: &#x27;Hello Vue!!&#x27;, flag: true &#125;, methods: &#123; modifyColor: function () &#123; if (this.flag) &#123; this.flag = false; &#125; else &#123; this.flag = true; &#125; &#125; &#125; &#125;)&lt;/script&gt; 结果改变输入框内容，上面的文本也随之改变，点击按钮文本的颜色由蓝色和红色来回变换 小结data 用于定义属性 methods 用于定义的函数，可以通过 return 来返回函数值 { { } } 于输出对象属性和函数返回值 el 用于绑定某个id的标签 v-on:click 触发某个点击事件 v-model 动态绑定某个属性的值 v-bind 用于绑定HTML属性","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"}]},{"title":"Java单元测试","slug":"179","date":"2021-06-23T18:47:26.000Z","updated":"2022-04-14T02:12:36.095Z","comments":true,"path":"179.html","link":"","permalink":"https://blog.zoutl.cn/179.html","excerpt":"","text":"引入junit依赖123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建测试用文件夹创建一个测试专用的文件夹（在src文件夹下创建） 常用注解介绍@Test把一个方法标记为测试方法 @Before每一个测试方法执行前自动调用一次 @After每一个测试方法执行完自动调用一次 @BeforeClass所有测试方法执行前执行一次，在测试类还没有实例化就已经被加载，所以用static修饰 @AfterClass所有测试方法执行完执行一次，在测试类还没有实例化就已经被加载，所以用static修饰 @Ignore暂不执行该测试方法 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import jdk.nashorn.internal.ir.annotations.Ignore;import org.junit.*;import org.junit.Test;/** * @author LeDao * @company * @create 2021-06-24 2:31 */public class MyTest &#123; @BeforeClass public static void startAll() &#123; System.out.println(&quot;开始所有单元测试&quot;); &#125; @AfterClass public static void endAll() &#123; System.out.println(&quot;所有单元测试结束&quot;); &#125; @Before public void start() &#123; System.out.println(&quot;**********&quot;); System.out.println(&quot;开始单元测试&quot;); &#125; @After public void end() &#123; System.out.println(&quot;单元测试结束&quot;); System.out.println(&quot;----------&quot;); &#125; @Ignore public void ignoreMe() &#123; System.out.println(&quot;忽略我&quot;); &#125; @Test public void test1() &#123; System.out.println(&quot;单元测试1&quot;); &#125; @Test public void test2() &#123; System.out.println(&quot;单元测试2&quot;); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"a标签实现文件下载","slug":"178","date":"2021-06-23T08:27:14.000Z","updated":"2022-04-14T02:12:33.999Z","comments":true,"path":"178.html","link":"","permalink":"https://blog.zoutl.cn/178.html","excerpt":"","text":"实现一般文件通过纯前端技术实现文件下载，直接把a标签的href属性设置为文件路径即可 12345&lt;p&gt; &lt;a href=&quot;https://www.zoutl.cn/fileDownload/nhdogjmejiglipccpnnnanhbledajbpd.zip&quot;&gt; &lt;input name=&quot;下载&quot; type=&quot;button&quot; value=&quot;下载&quot; /&gt; &lt;/a&gt;&lt;/p&gt; 特殊文件 org.springframework.boot spring-boot-maven-plugin 2.2.6.RELEASExml download属性为空（下载名为vue.js的文件） 12345&lt;p&gt; &lt;a download=&quot;&quot; href=&quot;https://www.zoutl.cn/fileDownload/vue.js&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;下载&quot; /&gt; &lt;/a&gt;&lt;/p&gt; download属性不为空（下载名为vue3.js的文件） 12345&lt;p&gt; &lt;a download=&quot;vue3.js&quot; href=&quot;https://www.zoutl.cn/fileDownload/vue.js&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;下载&quot; /&gt; &lt;/a&gt;&lt;/p&gt; 结果","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Maven出现错误：Plugin org.springframework.boot:spring-boot-maven-plugin: not found的解决办法","slug":"177","date":"2021-06-22T03:51:40.000Z","updated":"2022-04-14T02:29:46.190Z","comments":true,"path":"177.html","link":"","permalink":"https://blog.zoutl.cn/177.html","excerpt":"","text":"解决办法给spring-boot-maven-plugin指定版本 修改前1234&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt; 修改后12345&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2.6.RELEASE&lt;/version&gt;&lt;/plugin&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"}]},{"title":"Redis的持久化之AOF方式","slug":"176","date":"2021-06-21T18:33:13.000Z","updated":"2022-04-14T02:24:26.548Z","comments":true,"path":"176.html","link":"","permalink":"https://blog.zoutl.cn/176.html","excerpt":"","text":"概述AOF方式：将以日志，记录每一个操作 优势：安全性相对RDB方式高很多 劣势：效率相对RDB方式低很多 查看和修改配置找到并修改redis.conf appendonly no默认关闭aof方式，我们修改成 yes 就开启 下面那个是默认的aof文件名 接下来找到 这里是三种同步策略： always是只要发生修改，立即同步（推荐使用，安全性最高） everysec是每秒同步一次 no是不同步 我们修改成always 保存并退出 备份数据启动Redis服务，增加几个key，退出客户端，查看当前目录，发现多了一个备份文件appendonly.aof [root@localhost redis]# ./bin/redis-server ./redis.conf[root@localhost redis]# ps -ef | grep -i redisroot 1754 1 0 02:04 ? 00:00:00 ./bin/redis-server *:6379root 1758 1498 0 02:04 pts/0 00:00:00 grep –color=auto -i redis[root@localhost redis]# ./bin/redis-cli127.0.0.1:6379&gt; keys *(empty list or set)127.0.0.1:6379&gt; set a 1OK127.0.0.1:6379&gt; set b 2OK127.0.0.1:6379&gt; keys *1)”a”2)”b” 127.0.0.1:6379&gt; exit[root@localhost redis]# ps -ef | grep -i redisroot 1754 1 0 02:04 ? 00:00:00 ./bin/redis-server *:6379root 1761 1498 0 02:05 pts/0 00:00:00 grep –color=auto -i redis[root@localhost redis]# ll总用量 52-rw-r–r–. 1 root root 77 6月 22 02:04 appendonly.aofdrwxr-xr-x. 2 root root 134 6月 20 00:37 bin-rw-r–r–. 1 root root 46698 6月 22 02:02 redis.conf 退出Redis服务，用shutdown nosave命令关闭Redis就不会创建dump.rdb备份文件 [root@localhost redis]# ./bin/redis-cli127.0.0.1:6379&gt; keys *1)”a”2)”b” 127.0.0.1:6379&gt; shutdown nosavenot connected&gt; exit[root@localhost redis]# ll总用量 52-rw-r–r–. 1 root root 77 6月 22 02:04 appendonly.aofdrwxr-xr-x. 2 root root 134 6月 20 00:37 bin-rw-r–r–. 1 root root 46698 6月 22 02:02 redis.conf 恢复数据将appendonly.aof剪切到其它目录，重启Redis服务，查看所有key，发现没有数据 [root@localhost redis]# ./bin/redis-server ./redis.conf[root@localhost redis]# ./bin/redis-cli127.0.0.1:6379&gt; keys *(empty list or set) 退出Redis服务（shutdown nosave命令），将剪切到其它目录的appendonly.aof重新复制到备份文件指定目录/usr/local/redis，重启Redis服务，查看所有key，发现有数据 127.0.0.1:6379&gt; shutdown nosavenot connected&gt; exit[root@localhost redis]# cp /home/data/appendonly.aof /usr/local/redis/cp：是否覆盖”/usr/local/redis/appendonly.aof”？ y[root@localhost redis]# ./bin/redis-server ./redis.conf[root@localhost redis]# ./bin/redis-cli127.0.0.1:6379&gt; keys *1)”b”2)”a” 总结我们平时可以把aof文件定期备份，然后需要的时候拷贝到redis下，重启即可 PS.来源：Redis的持久化之AOF方式_Java开源博客系统-Powered by java1234","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis的持久化之RDB方式","slug":"175","date":"2021-06-21T16:33:55.000Z","updated":"2022-04-14T02:24:35.550Z","comments":true,"path":"175.html","link":"","permalink":"https://blog.zoutl.cn/175.html","excerpt":"","text":"概述RDB方式，Redis是默认支持的 优势：只有一个文件，时间间隔的数据，可以归档为一个文件，方便压缩转移（就一个文件） 劣势：如果宕机，数据损失比较大，因为它是没一个时间段进行持久化操作的。也就是积攒的数据比较多，一旦懵逼，就彻底懵逼了 查看Redis配置[root@localhost ~]# cd /usr/local/redis/[root@localhost redis]# vi redis.conf save 900 1 表示 每900秒内至少有1个key发生变化，就持久化 save 300 10表示 每300秒内至少有10个key发生变化，就持久化 save 60 10000表示 每60秒内至少有10000个key发生变化，就持久化 dbfilename配置是保存的持久化的文件名，默认是dump.rdb dir ./ 表示文件存储路径是当前路径 查看当前路径的文件[root@localhost redis]# ll 当前路径里确实是有dump.rdb这个文件的 备份和恢复数据备份数据删除已存在的备份文件 [root@localhost redis]# lsbin dump.rdb redis.conf[root@localhost redis]# rm dump.rdbrm：是否删除普通文件 “dump.rdb”？y[root@localhost redis]# lsbin redis.conf 打开Redis服务 [root@localhost redis]# ./bin/redis-server ./redis.conf 进入Redis客户端 [root@localhost redis]# ./bin/redis-cli 查看所有key（此时是没有数据的） 127.0.0.1:6379&gt; keys *(empty list or set) 创建几个key 127.0.0.1:6379&gt; set a1 1OK127.0.0.1:6379&gt; set a2 2OK127.0.0.1:6379&gt; set a3 3OK127.0.0.1:6379&gt; keys *1)”a3”2)”a2”3)”a1” 保存并关闭Redis（当前路径下多了一个备份文件dump.rdb） 127.0.0.1:6379&gt; shutdown savenot connected&gt; exit[root@localhost redis]# lsbin dump.rdb redis.conf 恢复数据再次打开Redis服务，查看所有key，发现有数据（说明是数据加载进来了，Redis服务启动时会自动加载备份文件） [root@localhost redis]# ./bin/redis-server ./redis.conf[root@localhost redis]# ./bin/redis-cli127.0.0.1:6379&gt; keys *1)”a2”2)”a3”3)”a1” 再次关闭Redis服务，将备份文件dump.rdb剪切到其它目录，然后启动Redis服务，查看所有key，发现是没有数据的（由于备份文件已经剪切到其它目录了，所以启动Redis服务时无法自动加载备份数据，查看所有key没有数据） [root@localhost redis]# /usr/local/redis/bin/redis-cli shutdown[root@localhost redis]# lsbin dump.rdb redis.conf[root@localhost redis]# mv dump.rdb /home/data/[root@localhost redis]# lsbin redis.conf[root@localhost redis]# ./bin/redis-server ./redis.conf[root@localhost redis]# ./bin/redis-cli127.0.0.1:6379&gt; keys *(empty list or set) 然后我们将之前剪切到其它目录的备份文件复制到Redis备份文件指定目录中，将新创建的备份文件（关闭Redis服务时自动创建）覆盖掉，启动Redis服务后又有数据了（Redis会在启动时加载备份文件） [root@localhost redis]# cp /home/data/dump.rdb /usr/local/redis/cp：是否覆盖”/usr/local/redis/dump.rdb”？ y[root@localhost redis]# ./bin/redis-server ./redis.conf[root@localhost redis]# ./bin/redis-cli127.0.0.1:6379&gt; keys *1)”a1”2)”a3”3)”a2” 总结Redis服务在启动时自动加载备份文件，平时我们可以定期把rdb文件备份到指定地方，需要恢复的时候，直接把rdb搞到redis备份文件指定目录/usr/local/redis下即可 PS.来源：Redis的持久化之RDB方式_Java开源博客系统-Powered by java1234","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis持久化","slug":"174","date":"2021-06-21T15:34:21.000Z","updated":"2022-04-14T02:25:11.809Z","comments":true,"path":"174.html","link":"","permalink":"https://blog.zoutl.cn/174.html","excerpt":"","text":"持久化是将程序数据在持久状态和瞬时状态间转换的机制。通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库中，能够长久保存） 持久化操作有两种方式：rdb方式、aof方式，可以单独使用或者结合使用 rdb方式：在指定的时间间隔写入硬盘，查看博客：Redis 的持久化之 RDB 方式 | LeDao 的博客 (zoutl.cn) aof方式：将以日志，记录每一个操作，服务器启动后就构建数据库，查看博客：Redis 的持久化之 AOF 方式 | LeDao 的博客 (zoutl.cn)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Tomcat安装SSL证书","slug":"173","date":"2021-06-21T13:35:54.000Z","updated":"2022-04-10T15:01:49.184Z","comments":true,"path":"173.html","link":"","permalink":"https://blog.zoutl.cn/173.html","excerpt":"","text":"环境阿里云服务器、CentOS7系统、Tomcat9 申请免费证书阿里云可申请一年的免费证书 申请证书教程：https://help.aliyun.com/document_detail/98574.html?spm=a2c4g.11186623.6.600.1a2d7597CYqniO 安装SSL证书前提条件已从阿里云SSL证书服务控制台下载Tomcat服务器证书（包含PFX格式证书文件和TXT格式密码文件）。 申请SSL证书时绑定的域名已完成DNS解析、实现了该域名指向您Tomcat服务器的IP地址。 域名解析设置完成后执行ping www.yourdomain.com 命令，如果返回了您所设置解析的主机IP地址，说明解析成功。 操作步骤 解压Tomcat证书 每次下载证书都会产生新的密码，该密码仅匹配本次下载的证书。如果需要更新证书文件，同时也要更新匹配的密码 将下载的证书和密码文件拷贝到Tomcat的conf目录下 打开Tomcat/conf/server.xml，在server.xml文件中找到以下参数并进行修改 ①将Connector port修改为80，将redirectPort修改为SSL默认端口443，让HTTPS请求转发到443端口 修改前： 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改后： 123&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;443&quot; /&gt; ②将下面代码复制到server.xml中，certificateKeystoreFile代表证书文件的路径，certificateKeystorePassword为SSL证书的密码 1234567&lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt; &lt;SSLHostConfig&gt; &lt;Certificate certificateKeystoreFile=&quot;/home/tomcat9/apache-tomcat-9.0.46/conf/证书名称&quot; certificateKeystorePassword=&quot;证书密码&quot; certificateKeystoreType=&quot;PKCS12&quot; /&gt; &lt;/SSLHostConfig&gt;&lt;/Connector&gt; ③找到下面代码并修改 修改前： 1&lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 修改后： 1&lt;Connector protocol=&quot;AJP/1.3&quot; port=&quot;8009&quot; redirectPort=&quot;443&quot; secretRequired=&quot;&quot;/&gt; ④在web.xml文件最底部添加以下内容，实现HTTP自动跳转为HTTPS 123456789&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt;&lt;/security-constraint&gt; 保存server.xml，重启Tomcat 结果出现锁图标和https说明SSL证书已经安装成功","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"阿里云","slug":"阿里云","permalink":"https://blog.zoutl.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"SSL证书","slug":"SSL证书","permalink":"https://blog.zoutl.cn/tags/SSL%E8%AF%81%E4%B9%A6/"}]},{"title":"图片压缩","slug":"172","date":"2021-06-21T05:01:48.000Z","updated":"2022-03-26T20:05:57.331Z","comments":true,"path":"172.html","link":"","permalink":"https://blog.zoutl.cn/172.html","excerpt":"","text":"为什么要图片压缩？使用更少的带宽，可以加快网站加载速度 tinypng网站地址https://tinypng.com/ 使用点击虚线框可以选择要压缩的图片，或将图片（最多20张）拖到虚线框 压缩成功，点击下载按钮即可下载到本地 squoosh网站地址https://squoosh.app/ 可以安装到电脑上，下载地址：https://squoosh-desktop.vercel.app/#download 使用上传图片后会自动压缩，点击下载按钮即可下载到本地 对比squoosh更加方便，squoosh压缩后下载的是图片，tinypng下载的是图片的压缩包还要解压一下；squoosh还可以安装到电脑上，不需要打开浏览器","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"使用Log4j","slug":"171","date":"2021-06-21T04:46:43.000Z","updated":"2022-04-14T02:12:26.497Z","comments":true,"path":"171.html","link":"","permalink":"https://blog.zoutl.cn/171.html","excerpt":"","text":"引入Log4j依赖12345&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 配置文件新建一个log4j.properties文件，文件存放位置： 文件内容如下： 123456789101112log4j.rootLogger=DEBUG, Console ,File #Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=%d [%t] %-5p [%c] - %m%n#Filelog4j.appender.File = org.apache.log4j.FileAppenderlog4j.appender.File.File = E://myLog.loglog4j.appender.File.layout = org.apache.log4j.PatternLayoutlog4j.appender.File.layout.ConversionPattern =%d [%t] %-5p [%c] - %m%n Java代码12345678910111213141516import org.apache.log4j.Logger;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; private static final Logger logger = Logger.getLogger(Test.class); public static void main(String[] args) &#123; logger.info(&quot;调试信息&quot;); logger.error(&quot;错误信息&quot;); &#125;&#125; 结果 E盘下也有一个myLog.log文件","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Redis有序集合(sorted set)","slug":"170","date":"2021-06-21T01:39:57.000Z","updated":"2022-04-14T02:24:42.936Z","comments":true,"path":"170.html","link":"","permalink":"https://blog.zoutl.cn/170.html","excerpt":"","text":"概述Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 有序集合的成员是唯一的,但分数(score)却可以重复。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 zadd添加元素，里面包括年龄和名称，根据数值从小到大排列，如果继续添加元素：①值已存在，则数值覆盖②值不存在，就会添加进去 zadd key 数值1 字段1 数值2 字段2 … 127.0.0.1:6379&gt; zadd age 11 tom 8 jack 22 mary(integer) 3 zrange查找元素位置下标从0开始，结束位置如果是-1代表是最后一个 zrange key start end 127.0.0.1:6379&gt; zrange age 0 -11)”jack”2)”tom”3)”mary” 显示数值上面没有显示数值，命令后面加上withscores可以显示数值 zrange key 0 -1 withscores 127.0.0.1:6379&gt; zrange age 0 -1 withscores1)”jack”2)”8”3)”tom”4)”11”5)”mary”6)”22” zrevrange降序排列，和zrange相反 zrevrange key start end withscores 127.0.0.1:6379&gt; zrevrange age 0 -1 withscores1)”mary”2)”22”3)”tom”4)”11”5)”jack”6)”8” zrem删除一个或多个元素 zrem key 字段1 字段2 … 127.0.0.1:6379&gt; zrange age 0 -11)”sherry”2)”jack”3)”tom”4)”mary” 127.0.0.1:6379&gt; zrem age sherry(integer) 1127.0.0.1:6379&gt; zrange age 0 -11)”jack”2)”tom”3)”mary” zcard查看集合里的元素个数 zcard key 127.0.0.1:6379&gt; zcard age(integer) 3 zremrangebyrank根据排名来删除元素 zremrangebyrank key start end 127.0.0.1:6379&gt; zrange age 0 -1 withscores 1)”aa” 2)”1” 3)”bb” 4)”2” 5)”jack” 6)”8” 7)”tom” 8)”11” 9)”mary”10)”22”127.0.0.1:6379&gt; zremrangebyrank age 0 1(integer) 2127.0.0.1:6379&gt; zrange age 0 -1 withscores1)”jack”2)”8”3)”tom”4)”11”5)”mary”6)”22” zremrangebyscore根据数值范围来删除元素（包含） zremrangebyscore key min max 127.0.0.1:6379&gt; zrange age 0 -1 withscores 1)”aa” 2)”1” 3)”bb” 4)”2” 5)”jack” 6)”8” 7)”tom” 8)”11” 9)”mary”10)”22”127.0.0.1:6379&gt; zremrangebyscore age 0 4(integer) 2127.0.0.1:6379&gt; zrange age 0 -1 withscores1)”jack”2)”8”3)”tom”4)”11”5)”mary”6)”22” zrangebyscore根据评分范围来查找元素zrangebyscore key min max withscores 127.0.0.1:6379&gt; zrange age 0 -1 withscores1)”jack”2)”8”3)”tom”4)”11”5)”mary”6)”22”127.0.0.1:6379&gt; zrangebyscore age 8 11 withscores1)”jack”2)”8”3)”tom”4)”11” 限定查找起始第一个元素的下标为0，end为-1时查全部 zrangebyscore key min max withscores limit statr end 127.0.0.1:6379&gt; zrangebyscore age 0 100 withscores limit 0 21)”jack”2)”8”3)”tom”4)”11” zincrby给指定元素加分 zincrby key 数值 字段名 127.0.0.1:6379&gt; zrange age 0 -1 withscores1)”jack”2)”8”3)”tom”4)”11”5)”mary”6)”22”127.0.0.1:6379&gt; zincrby age 2 jack“10”127.0.0.1:6379&gt; zrange age 0 -1 withscores1)”jack”2)”10”3)”tom”4)”11”5)”mary”6)”22” zcount查找指定数值范围的元素个数 zcount key min max 127.0.0.1:6379&gt; zrange age 0 -1 withscores1)”jack”2)”10”3)”tom”4)”11”5)”mary”6)”22”127.0.0.1:6379&gt; zcount age 9 10(integer) 1","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis集合(Set)","slug":"169","date":"2021-06-21T00:05:35.000Z","updated":"2022-04-14T02:24:46.646Z","comments":true,"path":"169.html","link":"","permalink":"https://blog.zoutl.cn/169.html","excerpt":"","text":"概述Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 Redis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。 sadd添加set元素（添加一个或多个），set集合如果不存在就会先创建集合 sadd key member1 member2… 127.0.0.1:6379&gt; sadd set1 a b c a(integer) 3 smembers查看指定key集合元素 smembers key 127.0.0.1:6379&gt; smembers set11)”b”2)”a”3)”c” srem删除元素（删除一个或多个元素） srem key member1 member2… 127.0.0.1:6379&gt; smembers set11)”1”2)”c”3)”a”4)”b”5)”3”6)”2”127.0.0.1:6379&gt; srem set1 a 1(integer) 2127.0.0.1:6379&gt; smembers set11)”b”2)”c”3)”3”4)”2” sismember判断某个元素是否存在（返回1表示存在，返回0表示不存在） sismember key member 127.0.0.1:6379&gt; smembers set11)”b”2)”c”3)”3”4)”2”127.0.0.1:6379&gt; sismember set1 a(integer) 0127.0.0.1:6379&gt; sismember set1 2(integer) 1 sdiff计算两个集合的差集（key1去掉key1和key2的交集元素，key1和key2的位置交换会得到不同的结果） sdiff key1 key2 127.0.0.1:6379&gt; sadd set2 a b c(integer) 3127.0.0.1:6379&gt; sadd set3 b c d e(integer) 4127.0.0.1:6379&gt; sdiff set2 set31)”a”127.0.0.1:6379&gt; sdiff set3 set21)”d”2)”e” sinter计算两个集合的交集 sinter key1 key2 127.0.0.1:6379&gt; sinter set2 set31)”b”2)”c” sunion计算两个集合的并集 sunion key1 key2 127.0.0.1:6379&gt; sunion set2 set31)”b”2)”a”3)”c”4)”e”5)”d” scard计算元素总数 scard key 127.0.0.1:6379&gt; smembers set11)”b”2)”c”3)”3”4)”2”127.0.0.1:6379&gt; scard set1(integer) 4 srandmember随机取一个或多个元素，count为空或者是1时，只随机选一个元素 srandmember key count 127.0.0.1:6379&gt; srandmember set1“3”127.0.0.1:6379&gt; srandmember set1“b”127.0.0.1:6379&gt; srandmember set1 21)”b”2)”3”127.0.0.1:6379&gt; srandmember set1 21)”3”2)”2” sdiffstore把差集结果存储到新集合中 sdiffstore newKey key1 key2 127.0.0.1:6379&gt; smembers set21)”b”2)”a”3)”c”127.0.0.1:6379&gt; smembers set31)”d”2)”b”3)”e”4)”c”127.0.0.1:6379&gt; sdiffstore newSet set2 set3(integer) 1127.0.0.1:6379&gt; smembers newSet1)”a” sinterstore把交集结果存储到新集合中 sinterstore newKey key1 key2 127.0.0.1:6379&gt; smembers set21)”b”2)”a”3)”c”127.0.0.1:6379&gt; smembers set31)”d”2)”b”3)”e”4)”c”127.0.0.1:6379&gt; sinterstore newSet set2 set3(integer) 2127.0.0.1:6379&gt; smembers newSet1)”b”2)”c” sunionstore把并集结果存储到新集合中 sunionstore newKey key1 key2 127.0.0.1:6379&gt; smembers set21)”b”2)”a”3)”c”127.0.0.1:6379&gt; smembers set31)”d”2)”b”3)”e”4)”c”127.0.0.1:6379&gt; sunionstore newSet set2 set3(integer) 5127.0.0.1:6379&gt; smembers newSet1)”b”2)”a”3)”c”4)”e”5)”d”","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis结合JSON存储Java对象","slug":"168","date":"2021-06-20T15:44:11.000Z","updated":"2022-04-14T02:12:23.486Z","comments":true,"path":"168.html","link":"","permalink":"https://blog.zoutl.cn/168.html","excerpt":"","text":"概述先将Java对象转化成json字符串，然后Redis存储json字符串 实现过程引入gson依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; 使用到的方法Jedis.rpop() 右侧弹出元素 Jedis.llen() 获取Redis的list长度 Jedis.rpush() 从右侧开始添加元素 Jedis.lrange() 获取全部元素集合 Gson.toJson() Java对象转化成json Gson.fromJson() json转化成Java对象 Java代码 Fruit实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.ledao.jedis;/** * @author LeDao * @company * @create 2021-06-20 22:30 */public class Fruit &#123; /** * 编号 */ private Integer id; /** * 名称 */ private String name; /** * 数量 */ private Integer num; public Fruit() &#123; &#125; public Fruit(String name, Integer num) &#123; this.name = name; this.num = num; &#125; public Fruit(Integer id, String name, Integer num) &#123; this.id = id; this.name = name; this.num = num; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125; @Override public String toString() &#123; return &quot;Fruit&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, num=&quot; + num + &#x27;&#125;&#x27;; &#125;&#125; 测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ledao.jedis;import com.google.gson.Gson;import redis.clients.jedis.Jedis;import java.util.ArrayList;import java.util.List;/** * @author LeDao * @company * @create 2021-06-20 7:47 */public class JedisTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.0.153&quot;, 6379); jedis.auth(&quot;123456&quot;); Fruit fruit1 = new Fruit(1, &quot;苹果&quot;, 11); Fruit fruit2 = new Fruit(2, &quot;梨&quot;, 6); Fruit fruit3 = new Fruit(3, &quot;油桃&quot;, 8); List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); fruitList.add(fruit1); fruitList.add(fruit2); fruitList.add(fruit3); //转化成json，便于redis存储Java对象 System.out.println(&quot;转化成json：&quot;); Gson gson = new Gson(); for (Fruit fruit : fruitList) &#123; jedis.rpush(&quot;redisFruitList&quot;, gson.toJson(fruit)); &#125; //遍历 List&lt;String&gt; redisFruitList = jedis.lrange(&quot;redisFruitList&quot;, 0, -1); for (String s : redisFruitList) &#123; System.out.println(s); &#125; //Redis的list转化成Java对象 System.out.println(&quot;转化成Java对象：&quot;); for (int i = 0; i &lt; redisFruitList.size(); i++) &#123; Fruit fruit = gson.fromJson(redisFruitList.get(i), Fruit.class); System.out.println(fruit.toString()); &#125; //清空redisFruitList Long length = jedis.llen(&quot;redisFruitList&quot;); if (length &gt; 0) &#123; for (int i = 0; i &lt; length; i++) &#123; jedis.rpop(&quot;redisFruitList&quot;); &#125; &#125; //关闭连接 jedis.close(); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"JSON","slug":"JSON","permalink":"https://blog.zoutl.cn/tags/JSON/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis列表(List)","slug":"167","date":"2021-06-20T13:54:34.000Z","updated":"2022-04-14T02:24:50.723Z","comments":true,"path":"167.html","link":"","permalink":"https://blog.zoutl.cn/167.html","excerpt":"","text":"lpush方式添加，从左边开始添加 lpush key value1 value2… 127.0.0.1:6379&gt; lpush l1 a b c d(integer) 4127.0.0.1:6379&gt; lpush l1 1 2 3 4(integer) 8 rpush从右端开始添加（一般人比较习惯这种方式） rpush key value1 value2… 127.0.0.1:6379&gt; rpush l2 a b c d(integer) 4127.0.0.1:6379&gt; rpush l2 1 2 3 4(integer) 8127.0.0.1:6379&gt; lrange l2 0 -11)”a”2)”b”3)”c”4)”d”5)”1”6)”2”7)”3”8)”4” lrange获取指定方位的集合元素（end是-1时表示最后一个位置） lrange key start end 127.0.0.1:6379&gt; lrange l1 0 -11)”4”2)”3”3)”2”4)”1”5)”d”6)”c”7)”b”8)”a” lpop左侧弹出集合元素，返回弹出的元素 lpop/rpop key 127.0.0.1:6379&gt; lrange l2 0 -11)”a”2)”b”3)”c”4)”d”5)”1”6)”2”7)”3”8)”4”128.127.0.0.1:6379&gt; lpop l2“a”127.0.0.1:6379&gt; lrange l2 0 -11)”b”2)”c”3)”d”4)”1”5)”2”6)”3”7)”4” rpop右侧弹出集合元素，返回弹出的元素 127.0.0.1:6379&gt; lrange l2 0 -11)”b”2)”c”3)”d”4)”1”5)”2”6)”3”7)”4” 128.127.0.0.1:6379&gt; rpop l2“4”127.0.0.1:6379&gt; lrange l2 0 -11)”b”2)”c”3)”d”4)”1”5)”2”6)”3” llen查看元素个数 llen key 127.0.0.1:6379&gt; lrange l2 0 -11)”b”2)”c”3)”d”4)”1”5)”2”6)”3”127.0.0.1:6379&gt; llen l2(integer) 6 lset重新设置集合指定索引的值（即修改） lset key index value 127.0.0.1:6379&gt; lrange l2 0 -11)”b”2)”c”3)”d”4)”1”5)”2”6)”3”127.0.0.1:6379&gt; lset l2 0 b1OK127.0.0.1:6379&gt; lrange l2 0 -11)”b1”2)”c”3)”d”4)”1”5)”2”6)”3” linsert在集合里插入指定元素 在某元素之前插入一个元素（在某元素之后插入一个元素只要将before修改为after即可） linsert key before 某元素 插入的元素 127.0.0.1:6379&gt; lrange l2 0 -11)”b1”2)”c”3)”d”4)”1”5)”2”6)”3”127.0.0.1:6379&gt; linsert l2 before 1 0(integer) 7127.0.0.1:6379&gt; lrange l2 0 -11)”b1”2)”c”3)”d”4)”0”5)”1”6)”2”7)”3”","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis哈希(Hash)","slug":"166","date":"2021-06-20T04:20:59.000Z","updated":"2022-04-14T02:24:53.290Z","comments":true,"path":"166.html","link":"","permalink":"https://blog.zoutl.cn/166.html","excerpt":"","text":"概述Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。 Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。 hset为单个字段设置值 hset key 字段名 值 127.0.0.1:6379&gt; hset h1 username root(integer) 1127.0.0.1:6379&gt; hset h1 password 123456(integer) 1 hget获取字段的值 hget key 字段名 127.0.0.1:6379&gt; hget h1 username“root”127.0.0.1:6379&gt; hget h1 password“123456” hmset为多个字段一起设置值 hmset key 字段名1 值 字段名2 值 … 127.0.0.1:6379&gt; hmset h2 username ledao password 333OK hmget获取多个字段的值 hmget key 字段名1 字段名2 … 127.0.0.1:6379&gt; hmget h2 username password1)”ledao”2)”333” hgetall获取全部字段的值 hgetall key 127.0.0.1:6379&gt; hgetall h21)”username”2)”ledao”3)”password”4)”333” hdel删除属性，可以一次删除一个或者多个 hdel key 字段名1 字段名2 … 127.0.0.1:6379&gt; hdel h2 username password(integer) 2127.0.0.1:6379&gt; hgetall h2(empty list or set) hincrby给字段的值加一个数，这个字段的值的数据类型要为integer hincrby key 字段名 数值 127.0.0.1:6379&gt; hset h1 age 20(integer) 1127.0.0.1:6379&gt; hgetall h11)”username”2)”root”3)”password”4)”123456”5)”age”6)”20”127.0.0.1:6379&gt; hincrby h1 age 5(integer) 25 hexists判断字段是否存在，1表示存在，0表示不存在 hexists key 字段名 127.0.0.1:6379&gt; hexists h1 age(integer) 1127.0.0.1:6379&gt; hexists h1 age2(integer) 0 hlen获取hash属性个数 hlen key 127.0.0.1:6379&gt; hlen h1(integer) 3 hkeys获取所有属性名称 hkeys key 127.0.0.1:6379&gt; hkeys h11)”username”2)”password”3)”age” hvals获取所有属性值 hvals key 127.0.0.1:6379&gt; hvals h11)”root”2)”123456”3)”25” Java代码12345678910111213141516171819202122232425262728package com.ledao.jedis;import redis.clients.jedis.Jedis;import java.util.Map;/** * @author LeDao * @company * @create 2021-06-20 7:47 */public class JedisTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.0.153&quot;, 6379); jedis.auth(&quot;123456&quot;); //设置字段 jedis.hset(&quot;h1&quot;, &quot;username&quot;, &quot;root&quot;); jedis.hset(&quot;h1&quot;, &quot;password&quot;, &quot;123456&quot;); System.out.println(&quot;用户名：&quot; + jedis.hget(&quot;h1&quot;, &quot;username&quot;) + &quot;，密码：&quot; + jedis.hget(&quot;h1&quot;, &quot;password&quot;)); //获取全部字段 Map&lt;String, String&gt; map=jedis.hgetAll(&quot;h1&quot;); for (Map.Entry&lt;String, String&gt; stringStringEntry : map.entrySet()) &#123; System.out.println(stringStringEntry.getKey()+&quot;:&quot;+stringStringEntry.getValue()); &#125; jedis.close(); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis keys命令","slug":"165","date":"2021-06-20T03:38:38.000Z","updated":"2022-04-14T02:24:56.155Z","comments":true,"path":"165.html","link":"","permalink":"https://blog.zoutl.cn/165.html","excerpt":"","text":"get获取指定 key 的值 get key 127.0.0.1:6379&gt; get name“ledao” del删除指定key del key 127.0.0.1:6379&gt; get num“1”127.0.0.1:6379&gt; del num(integer) 1127.0.0.1:6379&gt; get num(nil) exists检查给定 key 是否存在 exists key 127.0.0.1:6379&gt; exists name(integer) 1 type返回 key 所储存的值的类型删除指定key type key 127.0.0.1:6379&gt; type namestring keyskeys *显示所有key 127.0.0.1:6379&gt; keys *1)”set3”2)”age”3)”l1”4)”newSet”5)”l2”6)”set1”7)”1”8)”fruitList”9)”set2” keys f*查找所有以某字符串开头的key 127.0.0.1:6379&gt; keys f*1)”fruitList” rename重命名key rename key name 127.0.0.1:6379&gt; rename list1 list2OK PS.更多命令：https://www.runoob.com/redis/redis-keys.html","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis字符串","slug":"164","date":"2021-06-20T02:46:12.000Z","updated":"2022-04-14T02:25:01.380Z","comments":true,"path":"164.html","link":"","permalink":"https://blog.zoutl.cn/164.html","excerpt":"","text":"get获取指定key的值 get key 127.0.0.1:6379&gt; get name“ledao” set设置指定key的值（如果key不存在就新建并复制，存在则值覆盖） set key 值 127.0.0.1:6379&gt; set name ledaoOK127.0.0.1:6379&gt; get name“ledao”127.0.0.1:6379&gt; set name ledao333OK127.0.0.1:6379&gt; get name“ledao333” del删除指定key，删除一个或多个 del key1 key2 … 127.0.0.1:6379&gt; get num“1”127.0.0.1:6379&gt; del num(integer) 1127.0.0.1:6379&gt; get num(nil) getrange返回 key 中字符串值的子字符（包括头包括尾，下标从0开始计算） getrange key 开始位置 结束位置 127.0.0.1:6379&gt; set name ledao333OK127.0.0.1:6379&gt; get name“ledao333”127.0.0.1:6379&gt; getrange name 0 1“le” getset设置给定 key 的值，并返回 key 的旧值 getset key 值 127.0.0.1:6379&gt; getset name LeDao“ledao333”127.0.0.1:6379&gt; get name“LeDao” setnx只有在 key 不存在时设置 key 的值 setnx key 值 127.0.0.1:6379&gt; get name“LeDao”127.0.0.1:6379&gt; setnx name ledao(integer) 0127.0.0.1:6379&gt; get name“LeDao” strlen返回 key 所储存的字符串值的长度 strlen key 127.0.0.1:6379&gt; get name“LeDao”127.0.0.1:6379&gt; strlen name(integer) 5 mset同时设置一个或多个 key-value 对 mset key1 值 key2 值 … 127.0.0.1:6379&gt; mset name1 ledao1 name2 ledao2OK127.0.0.1:6379&gt; get name1“ledao1”127.0.0.1:6379&gt; get name2“ledao2” incr将 key 中储存的数字值增一 incr key 127.0.0.1:6379&gt; set num 0OK127.0.0.1:6379&gt; get num“0”127.0.0.1:6379&gt; incr num(integer) 1127.0.0.1:6379&gt; get num“1” decr将 key 中储存的数字值减一 decr key 127.0.0.1:6379&gt; get num“2”127.0.0.1:6379&gt; decr num(integer) 1127.0.0.1:6379&gt; get num“1” append如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾，如果不存在就相当于set key value append key 值 127.0.0.1:6379&gt; get name“LeDao”127.0.0.1:6379&gt; append name 666(integer) 8127.0.0.1:6379&gt; get name“LeDao666”127.0.0.1:6379&gt; get name4(nil)127.0.0.1:6379&gt; append name4 666(integer) 3127.0.0.1:6379&gt; get name4“666” Java代码：请先设置Redis的连接密码，查看博客：实现Jedis连接 | LeDao的博客 (zoutl.cn) ，在第4点的第②小点 12345678910111213141516171819package com.ledao.jedis;import redis.clients.jedis.Jedis;/** * @author LeDao * @company * @create 2021-06-20 7:47 */public class JedisTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.0.153&quot;, 6379); jedis.auth(&quot;123456&quot;); jedis.set(&quot;LeDao的博客&quot;, &quot;http://www.zoutl.cn&quot;); System.out.println(&quot;LeDao的博客网址：&quot;+jedis.get(&quot;LeDao的博客&quot;)); jedis.close(); &#125;&#125; PS.更多命令：https://www.runoob.com/redis/redis-strings.html","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"CentOS7关闭Redis的两种方法","slug":"163","date":"2021-06-20T01:42:47.000Z","updated":"2022-04-14T02:25:05.211Z","comments":true,"path":"163.html","link":"","permalink":"https://blog.zoutl.cn/163.html","excerpt":"","text":"使用Linux命令如果设置了连接密码，就不能使用此方法 1/usr/local/redis/bin/redis-cli shutdown 使用Redis命令先进入Redis客户端 1/usr/local/redis/bin/redis-cli 进入客户端后输入shutdown关闭Redis服务，然后按ctrl+c退出 PS.查看Redis服务是否开启（有端口号说明Redis服务已经启动，没有则说明服务已停止） 1ps -ef | grep -i redis","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"Redis使用连接池","slug":"162","date":"2021-06-20T01:09:09.000Z","updated":"2022-04-14T02:25:08.012Z","comments":true,"path":"162.html","link":"","permalink":"https://blog.zoutl.cn/162.html","excerpt":"","text":"池化的基本思想 可以在初始化的时候创建一些对象，当有需要使用的时候直接从池中获取，提高响应速度； 使用过的对象不进行销毁，保存起来，等下一次需要对象的时候，拿出来重复使用，减少频繁创建对象所造成的销； 创建的对象统一保存，方面管理和维护。 池化好处总结 提高响应的速度 降低资源的消耗 方便管理和维护 Jedis连接的就是连接池中JedisPool管理的资源，JedisPool保证资源在一个可控范围内，并且保障线程安全。使用合理的GenericObjectPoolConfig配置能够提升Redis的服务性能，降低资源开销。 重要参数下列两表将对一些重要参数进行说明 空闲Jedis对象检测由下列四个参数组合完成，testWhileIdle是该功能的开关。 可以在org.apache.commons.pool2.impl.BaseObjectPoolConfig中查看全部默认值。 关键参数设置建议maxTotal（最大连接数）想合理设置maxTotal（最大连接数）需要考虑的因素较多，如： 业务希望的Redis并发量 客户端执行命令时间 Redis资源，例如nodes（如应用个数等），maxTotal不能超过Redis的最大连接数 资源开销，例如虽然希望控制空闲连接，但又不希望因为连接池中频繁地释放和创建连接造成不必要的开销 假设一次命令时间，即borrow|return resource加上Jedis执行命令 （ 含网络耗时）的平均耗时约为1ms，一个连接的QPS大约是1000，业务期望的QPS是50000，那么理论上需要的资源池大小是50000 / 1000 = 50。但事实上这只是个理论值，除此之外还要预留一些资源，所以maxTotal可以比理论值大一些。这个值不是越大越好，一方面连接太多会占用客户端和服务端资源，另一方面对于Redis这种高QPS的服务器，如果出现大命令的阻塞，即使设置再大的资源池也无济于事。 maxIdle与minIdlemaxIdle实际上才是业务需要的最大连接数，maxTotal 是为了给出余量，所以 maxIdle 不要设置得过小，否则会有new Jedis（新连接）开销，而minIdle是为了控制空闲资源检测。连接池的最佳性能是maxTotal=maxIdle，这样就避免了连接池伸缩带来的性能干扰。但如果并发量不大或者maxTotal设置过高，则会导致不必要的连接资源浪费，您可以根据实际总QPS和调用Redis的客户端规模整体评估每个节点所使用的连接池大小。 使用监控获取合理值在实际环境中，比较可靠的方法是通过监控来尝试获取参数的最佳值。可以考虑通过JMX等方式实现监控，从而找到合理值。 Java代码12345678910111213141516171819202122232425262728293031323334353637package com.ledao.jedis;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * @author LeDao * @company * @create 2021-06-20 7:47 */public class JedisTest &#123; public static void main(String[] args) &#123; JedisPoolConfig jedisPoolConfig = new JedisPoolConfig(); jedisPoolConfig.setMaxTotal(100); jedisPoolConfig.setMaxIdle(10); JedisPool jedisPool = new JedisPool(jedisPoolConfig, &quot;192.168.0.153&quot;, 6379); Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.auth(&quot;123456&quot;); jedis.set(&quot;name&quot;, &quot;LeDao&quot;); String value = jedis.get(&quot;name&quot;); System.out.println(value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; if (jedisPool != null) &#123; jedisPool.close(); &#125; &#125; &#125;&#125; PS.来源：掌握JedisPoolConfig参数配置，学会调优技能_阿飞云-CSDN博客","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"实现Jedis连接","slug":"161","date":"2021-06-20T00:24:20.000Z","updated":"2022-04-17T01:30:23.646Z","comments":true,"path":"161.html","link":"","permalink":"https://blog.zoutl.cn/161.html","excerpt":"","text":"引入依赖12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; Java代码12345678910111213141516171819package com.ledao.jedis;import redis.clients.jedis.Jedis;/** * @author LeDao * @company * @create 2021-06-20 7:47 */public class JedisTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.0.153&quot;, 6379); jedis.set(&quot;name&quot;, &quot;LeDao&quot;); String value = jedis.get(&quot;name&quot;); System.out.println(value); jedis.close(); &#125;&#125; 运行代码时出现错误 代表连接超时了，我们配置下防火墙，开一个6379端口权限 12firewall-cmd \\--zone=public \\--add-port=6379/tcp \\--permanentfirewall-cmd \\--reload 修改 /usr/local/redis/redis.conf 配置文件，将bind 127.0.0.1注释掉，在前面加#号即可（因为这里绑定了本机） 重启Redis服务 重启Redis服务，再次运行Java代码 1234# 停止Redis服务./bin/redis-cli shutdown# 启动Redis服务./bin/redis-server ./redis.conf 再次出现错误（下面是错误信息） Exception in thread “main” redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to ‘no’, and then restarting the server. 3) If you started the server manually just for testing, restart it with the ‘--protected-mode no’ option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside. at redis.clients.jedis.Protocol.processError(Protocol.java:127) at redis.clients.jedis.Protocol.process(Protocol.java:161) at redis.clients.jedis.Protocol.read(Protocol.java:215) at redis.clients.jedis.Connection.readProtocolWithCheckingBroken(Connection.java:340) at redis.clients.jedis.Connection.getStatusCodeReply(Connection.java:239) at redis.clients.jedis.Jedis.set(Jedis.java:121) at com.ledao.jedis.JedisTest.main(JedisTest.java:14) 出现错误的原因是因为远程连接 redis，因为 redis 的自我保护，会拒绝被访问，解决办法有两种：（推荐使用第二种方法：设置Redis连接密码） 关闭Redis的自我保护（不推荐使用） protected-mode yes 的yes修改为no即可 设置Redis连接密码，关闭Redis服务后就会失效，需要重新设置（推荐使用） 进入客户端 [root@localhost redis]# ./bin/redis-cli 设置密码 127.0.0.1:6379&gt; config set requirepass 123456OK 验证是否设置成功（出现OK就说明设置成功了） 127.0.0.1:6379&gt; auth 123456OK 退出客户端 127.0.0.1:6379&gt; quit 设置Redis密码Java代码中设置Redis密码jedis.auth(&quot;123456&quot;)，然后再次运行 1234567891011121314151617181920package com.ledao.jedis;import redis.clients.jedis.Jedis;/** * @author LeDao * @company * @create 2021-06-20 7:47 */public class JedisTest &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis(&quot;192.168.0.153&quot;, 6379); jedis.auth(&quot;123456&quot;); jedis.set(&quot;name&quot;, &quot;LeDao&quot;); String value = jedis.get(&quot;name&quot;); System.out.println(value); jedis.close(); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"CentOS7安装Redis","slug":"160","date":"2021-06-19T16:34:52.000Z","updated":"2022-04-15T17:11:27.597Z","comments":true,"path":"160.html","link":"","permalink":"https://blog.zoutl.cn/160.html","excerpt":"","text":"安装gccgcc编译c的，因为redis是c编写的，所以我们先安装下gcc 1yum install gcc-c++ 下载wget方式下载redis压缩包，并解压，以及编译 下载命令 1wget http://download.redis.io/releases/redis-3.2.9.tar.gz 解压命令 1tar -zxvf redis-3.2.9.tar.gz 编译命令，进入解压后的文件夹，在执行make命令 12cd redis-3.2.9make 安装安装命令 1make PREFIX=/usr/local/redis install 安装完后，需要将刚刚解压的文件夹内redis.conf复制到redis的安装目录/usr/local/redis/中 1cp /root/redis-3.2.9/redis.conf /usr/local/redis/ 启动和关闭Redis前台启动和关闭启动命令如下： 1/usr/local/redis/bin/redis-server 看到下面的界面说明已经启动成功了 按CTRL+C退出 这种启动是前台启动，假如退出程序就终止或者退出了 所以这种服务程序，必须后台运行 后台启动和关闭修改配置文件redis.conf 打开配置文件（打开后按/键，并输入关键字按下回车键可快速搜索文本内容） 1vi /usr/local/redis/redis.conf daemonize no修改成：daemonize yes 加载配置文件运行Redis 1/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf 搜索Redis服务 1ps -ef | grep -i redis 看到端口号说明已经启动成功了 停止Redis服务 1/usr/local/redis/bin/redis-cli shutdown 再次搜索Redis服务，发现端口号没了，说明Redis服务已经停止了","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"}]},{"title":"CentOS7实时查看Tomcat运行日志","slug":"159","date":"2021-06-17T19:56:12.000Z","updated":"2022-04-14T02:37:30.898Z","comments":true,"path":"159.html","link":"","permalink":"https://blog.zoutl.cn/159.html","excerpt":"","text":"查找catalina.out的路径1find / -name catalina.out 该文件在Tomcat安装目录的logs目录下 实时查看Tomcat运行日志命令1tail -f /home/tomcat9/apache-tomcat-9.0.46/logs/catalina.out 结果如下图 按CTRL+C退出","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"CentOS7部署Java项目速度很慢","slug":"158","date":"2021-06-17T19:30:47.000Z","updated":"2022-04-14T02:37:34.080Z","comments":true,"path":"158.html","link":"","permalink":"https://blog.zoutl.cn/158.html","excerpt":"","text":"查找 java.security 文件的路径1find / -name java.security 打开 java.security 文件1vi /home/java/jdk1.8.0_131/jre/lib/security/java.security 修改securerandom.source=file:/dev/random替换成：securerandom.source=file:/dev/urandom 保存并退出即可","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"CentOS7部署Java项目","slug":"157","date":"2021-06-16T20:37:36.000Z","updated":"2022-04-14T02:37:48.304Z","comments":true,"path":"157.html","link":"","permalink":"https://blog.zoutl.cn/157.html","excerpt":"","text":"打包项目具体步骤查看博客：idea将Spring Boot项目打包成war包 | LeDao的博客 (zoutl.cn) 特别地，平时我们开发用Windows系统，而部署项目用Linux系统（没有C、D等盘符），那么我们需要修改文件路径 Windows系统①Java代码 1private static final String mySettingLocation = &quot;E:\\\\MyProject\\\\IDEA\\\\ActualCombat\\\\MyBlog\\\\src\\\\main\\\\webapp\\\\static\\\\myConfig.setting&quot;; ②yml文件路径 12#博客正文图片存储地址blogImageFilePath: C://Java/apache-tomcat-9.0.22-windows-x64/apache-tomcat-9.0.22-windows-x64/apache-tomcat-9.0.22/webapps/MyBlog/static/images/blogImage/ ③yml文件MySQL连接 1234567#数据库连接配置datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/db_myblog?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8 username: root password: 12345 Linux系统①Java代码 1private static final String mySettingLocation = &quot;/home/tomcat9/apache-tomcat-9.0.46/webapps/MyBlog/static/myConfig.setting&quot;; ②yml文件路径 12#博客正文图片存储地址blogImageFilePath: /home/tomcat9/apache-tomcat-9.0.46/webapps/MyBlog/static/images/blogImage/ ③yml文件MySQL连接 1234567#数据库连接配置datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://192.168.0.153/db_myblog?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8 username: root password: 123456 CentOS7安装与配置环境Xshell连接CentOS7 CentOS7安装vsftp服务 CentOS7安装和配置jre1.8 CentOS7安装和配置MySQL5.7 CentOS7安装和配置Tomcat9 上传war包上传war包到/home/data目录 详细步骤查看博客：FTPRush向CentOS7上传文件和从CentOS7下载文件) 移动war包将/home/data目录的war包移动到/home/tomcat9/apache-tomcat-9.0.46/webapps目录中 [root@localhost webapps]# mv /home/data/MyBlog.war /home/tomcat9/apache-tomcat-9.0.46/webapps 修改Tomcat的配置修改/home/tomcat9/apache-tomcat-9.0.46/conf中的server.xml [root@localhost conf]# vi /home/tomcat9/apache-tomcat-9.0.46/conf/server.xml 在下图位置添加代码： 1&lt;Context path=&quot;&quot; docBase=&quot;/home/tomcat9/apache-tomcat-9.0.46/webapps/MyBlog&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; /&gt; 保存后退出 启动Tomcat[root@localhost conf]# /home/tomcat9/apache-tomcat-9.0.46/bin/startup.sh 结果在浏览器地址栏直接输入CentOS7的ip即可","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"CentOS7安装和配置Tomcat9","slug":"156","date":"2021-06-16T18:57:09.000Z","updated":"2022-04-14T02:37:37.017Z","comments":true,"path":"156.html","link":"","permalink":"https://blog.zoutl.cn/156.html","excerpt":"","text":"下载Tomcat下载地址：https://tomcat.apache.org/download-90.cgi 下载 tar.gz 压缩包 上传使用 FTPRush 上传 Tomcat 压缩包到 /home/data 目录 详细步骤查看博客：FTPRush向CentOS7上传文件和从CentOS7下载文件) 新建目录新建 /home/tomcat9 目录存放 tomcat9 1mkdir tomcat9 解压1tar -zxvf apache-tomcat-9.0.46.tar.gz 移动文件夹将解压后的文件夹剪切到 /home/tomcat9 目录 1mv apache-tomcat-9.0.46 /home/tomcat9/ 修改server.xmlserver.xml可以配置端口，编码以及配置项目等等，我们这里就配置一个端口，把默认的8080，修改成80 1vi /home/tomcat9/apache-tomcat-9.0.46/conf/server.xml 配置防火墙开放80端口 1firewall-cmd \\--zone=public \\--add-port=80/tcp \\--permanent 重启防火墙 1firewall-cmd \\--reload 启动[root@localhost tomcat9]# /home/tomcat9/apache-tomcat-9.0.46/bin/startup.sh 看到下面界面说明安装成功","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"CentOS7安装和配置MySQL5.7","slug":"155","date":"2021-06-16T18:33:03.000Z","updated":"2022-04-14T02:37:39.728Z","comments":true,"path":"155.html","link":"","permalink":"https://blog.zoutl.cn/155.html","excerpt":"","text":"安装wget1yum -y install wget 下载和安装MySQL源包12345#下载命令wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm#安装命令yum -y localinstall mysql57-community-release-el7-11.noarch.rpm 在线安装MySQL1yum -y install mysql-community-server 可能会报错：Public key for mysql-community-libs-compat-5.7.37-1.el7.x86_64.rpm is not installed，报错原因为：原因是Mysql的GPG升级了，需要重新获取 输入下面命令解决上面的报错，然后再次执行yum -y install mysql-community-server命令在线安装MySQL 1rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022 启动MySQL服务1systemctl start mysqld 设置开机启动12345#设置mysql开机启动systemctl enable mysqld#使设置生效systemctl daemon-reload 修改root本地登录密码MySQL 安装完成之后，在 /var/log/mysqld.log 文件中给 root 生成了一个临时的默认密码（下图中划红线的就是临时密码），复制它 1vi /var/log/mysqld.log 进入 MySQL 命令行，输入上面获取的临时密码 1mysql -uroot -p 然后输入下面命令修改密码，LeDao@2021是修改后的密码 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;LeDao@2021&#x27;; 修改密码为 LeDao@2021 (备注 MySQL5.7 默认密码策略要求密码必须是大小写字母数字特殊字母的组合，至少8位) 设置允许远程登录MySQL 默认不允许远程登录的，我们需要设置一下，不然会报1045的错误，然后防火墙开放 3306 端口，在 MySQL 命令行输入下面命令，LeDao@2021是数据库密码，输入 quit 退出 MySQL 命令行 1GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;LeDao@2021&#x27; WITH GRANT OPTION; 然后设置防火墙，连续输入下面两条命令： 12345#开放3306端口firewall-cmd \\--zone=public \\--add-port=3306/tcp \\--permanent#重启防火墙firewall-cmd \\--reload 配置默认编码为utf8修改 /etc/my.cnf 配置文件，在 [mysqld] 下添加编码配置，如下所示： 12character_set_server=utf8init_connect=&#x27;SET NAMES utf8&#x27; 打开 my.cnf 文件命令： 1vi /etc/my.cnf 重启mysql服务1systemctl restart mysqld 查看编码进入 MySQL 命令行 1mysql -uroot -p 在 MySQL 命令行查看编码 1show variables like &#x27;%character%&#x27;; SQLyog测试远程连接输入 CentOS7 的IP，MySQL 的用户名和密码 结果如下图","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"CentOS7安装和配置jre1.8","slug":"154","date":"2021-06-16T16:15:22.000Z","updated":"2022-04-14T02:37:44.765Z","comments":true,"path":"154.html","link":"","permalink":"https://blog.zoutl.cn/154.html","excerpt":"","text":"下载jre百度网盘链接 链接：https://pan.baidu.com/s/1aRzE9hdak3N_KtkYMYyRKQ 提取码：mbv3 上传上传jre到/home/data目录 解压 创建/home/java目录 12cd /homemkdir java 解压tar.gz压缩包 1tar -zxvf server-jre-8u131-linux-x64.tar.gz 把/home/data/下的jre剪切到/home/java/下 1mv /home/data/jdk1.8.0_131 /home/java 给jre目录以及子目录授予root权限 1chown root:root -R /home/java/jdk1.8.0_131/ 配置环境变量 编辑环境变量配置文件 1vi /etc/profile 在文件末尾加入下面代码（jdk名称根据实际情况填写），强制保存（wq!）退出 1234export JAVA_HOME=/home/javaexport JRE_HOME=/home/java/jdk1.8.0_131export CLASSPATH=$JRE_HOME/lib/rt.jar:$JRE_HOME/lib/extexport PATH=$PATH:$JRE_HOME/bin 使环境变量即时生效 1source /etc/profile 验证是否配置成功 1java -version 结果： java或者javac命令也可以验证","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"FTPRush向CentOS7上传文件和从CentOS7下载文件","slug":"153","date":"2021-06-16T08:31:59.000Z","updated":"2022-04-14T02:37:41.515Z","comments":true,"path":"153.html","link":"","permalink":"https://blog.zoutl.cn/153.html","excerpt":"","text":"下载和安装FTPRush百度网盘链接：https://pan.baidu.com/s/1TLBzFAs94nHdDHunPfSF3g 提取码：s3wr 配置输入密码按下回车键即可开始连接 上传文件在本地窗口中右键点击要上传的文件，选择传输 然后在远程窗口即可看到刚刚上传的文件（上传的文件在/home/data/） 下载文件在本地窗口选择下载保存的路径，在远程窗口右键点击要下载的文件，选择传输即可","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"CentOS7安装vsftp服务","slug":"152","date":"2021-06-16T07:56:35.000Z","updated":"2022-04-14T02:37:50.602Z","comments":true,"path":"152.html","link":"","permalink":"https://blog.zoutl.cn/152.html","excerpt":"","text":"概述我们需要向CentOS7操作系统的服务器上上传文件或者下载文件，这时候，有必要安装下ftp，我们选择主流的vsftp； 安装vsftp1yum install -y vsftpd 设置开机启动1systemctl enable vsftpd 启动ftp服务1systemctl start vsftpd.service 打开防火墙永久添加tcp 21端口 1firewall-cmd --zone=public --add-port=21/tcp --permanent 添加ftp服务 1firewall-cmd --permanent --zone=public --add-service=ftp 重启防火墙 1firewall-cmd --reload 添加用户新建java1234用户 添加到root组，但是不允许用户登录，仅仅可以ftp登录，ftp登录后的默认目录是/home/data 1useradd -g root -d /home/data -s /sbin/nologin java1234 设置用户密码1passwd java1234 设置权限1chown -R java1234:root /home/data 1setsebool -P ftpd_full_access on 修改vsftp配置文件，禁止匿名登录把：anonymous_enable=YES 改为： anonymous_enable=NO 1vi /etc/vsftpd/vsftpd.conf PS.来源：Centos7.3安装vsftp服务_Java开源博客系统-Powered by java1234","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"CentOS7常用命令总结","slug":"151","date":"2021-06-16T03:22:45.000Z","updated":"2022-04-14T02:37:53.187Z","comments":true,"path":"151.html","link":"","permalink":"https://blog.zoutl.cn/151.html","excerpt":"","text":"root代表当前登录用户，localhost代表主机名， ~代表当前主机目录，#代表用户权限（#表示超级用户，$表示普通用户） ls命令均可表示当前目录 1./和. 列出当前工作目录的内容（不包括隐藏文件） 1ls 列出root/ledao目录的内容 1ls root/ledao/ 列出当前工作目录的内容（包括隐藏文件） 1ls -a 列出当前工作目录的内容（查看详细信息） 1ls -l（或者ll） 列出当前工作目录的内容（按日期排序，降序） 1ls -lt 列出当前工作目录的内容（按日期排序，升序） 1ls -ltr 获取当前文件夹的文件个数 1ls -l | grep &quot;^-&quot; | wc -l cd命令回到根目录（根目录：[root@localhost /]） 1cd / 回到家目录（家目录：[root@localhost ~]） 1cd 或者 cd ~ 回到上一级目录 1cd .. 回到上两级目录 1cd ../.. 进入ledao目录 1cd ledao 进入ledao目录的11目录 1cd ledao/11 pwd命令打印当前所在目录 1pwd mkdir命令创建一个叫dir1的目录（文件夹） 1mkdir dir1 rmdir命令删除名为dir1的空目录（目录非空时则会提示删除失败） 1rmdir dir1 rm命令删除文件可以直接使用rm命令，若删除目录则必须配合选项”-r”，文件一旦通过rm命令删除，则无法恢复，所以必须格外小心地使用该命令。 删除文件1.txt 1rm 1.txt 删除目录dir1，如果是空目录则询问是否删除（输入y删除输入n不删除），是非空目录则先删除目录里的目录及文件 1rm -r dir1 强制删除dir1，即使不是空目录也可以直接删除 1rm -rf dir1或者rm -r -f dir1 删除当前目录的所有目录及文件 1rm -r * touch命令1.txt不存在则创建文件1.txt，存在则更改1.txt的时间属性为当前时间 1touch 1.txt 创建文件2.txt，3.txt（用于创建多个文件） 1touch 2.txt 3.txt &gt;命令1.txt不存在则创建文件1.txt，存在则直接覆盖原文件，不会有任何提示 1&gt;1.txt cp命令复制aa目录的所有目录及文件到bb目录 1cp aa/* bb 复制当前所在目录的3.txt文件到bb目录 1cp 3.txt bb vi命令打开1.txt进入命令模式，没有就新建文件（按下i键进入输入模式，按ESC退出输入模式进入命令模式，在命令模式下按下:（英文冒号）就进入了底线命令模式，按w保存，按q退出，按wq则保存后退出） 1vi 1.txt 详细介绍：Linux vi/vim | 菜鸟教程 查看ip1ip addr 重启网络服务1sudo service network restart mv命令例如：mv aaa bbb（将文件 aaa 改名为 bbb） 1mv source_file(文件) dest_file(文件) 例如：mv 1.txt dir1（将 1.txt 放入 dir1 目录中。注意，如果 dir1目录不存在，则该命令将 1.txt 改名为 dir1） 1mv source_file(文件) dest_directory(目录) 例如：mv /usr/runoob/* .（将 /usr/runoob 下的所有文件和目录移到当前目录下） 1mv source_directory(目录) dest_directory(目录) find命令查找所有目录中名称为mysql的文件 1find / -name mysql 查找/etc目录中名称为mysql的文件 1find /etc -name mysql 查找当前目录中名称为mysql的文件 1find -name mysql firewall-cmd开放端口：8889，开放后要更新防火墙配置才能生效 1firewall-cmd --zone=public --add-port=8889/tcp --permanent 删除端口：6666，删除后要更新防火墙配置才能生效 1firewall-cmd --zone=public --remove-port=6666/tcp --permanent 更新防火墙配置 1firewall-cmd --reload 查看端口：8889是否可用 1firewall-cmd --query-port=8889/tcp 列出所有开放的端口 1firewall-cmd --list-ports cat命令查看1.txt的内容（不进入文件） 1cat 1.txt 清空文件内容清空1.txt的内容 1echo &gt; 1.txt 查看运行日志比如Tomcat刚刚启动时，可以动态查看日志 1tail -f 日志文件 sh命令执行一个.sh文件 1sh mkdir.sh","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"Xshell连接CentOS7","slug":"150","date":"2021-06-16T02:36:23.000Z","updated":"2022-04-14T02:37:55.807Z","comments":true,"path":"150.html","link":"","permalink":"https://blog.zoutl.cn/150.html","excerpt":"","text":"新建连接 填写会话属性如果不知道CentOS7的ip，查看博客：查看虚拟机里的CentOS7的IP | LeDao的博客 (zoutl.cn) 为了方便辨认，名称和主机填CentOS7的ip，端口号填22 用户身份验证点击左侧菜单的用户身份验证，用户名和密码输入CentOS7的登陆用户名和密码，然后点击连接即可 结果","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"查看CentOS7的IP","slug":"149","date":"2021-06-15T21:14:23.000Z","updated":"2022-04-14T02:37:58.396Z","comments":true,"path":"149.html","link":"","permalink":"https://blog.zoutl.cn/149.html","excerpt":"","text":"查看IP命令1ip addr 修改ens33网卡的配置如果直接使用上面的命令无法查看，就要去修改ens33网卡的配置 查看网卡配置命令如下： 1vi /etc/sysconfig/network-scripts/ifcfg-ens33 下图中划红线处需要修改为ONBOOT=yes，按下i键进入编辑模式，修改后按ESC键退出编辑模式，输入 :wq保存并退出，最后按下回车键即可 最后输入命令ip addr查看IP地址","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"}]},{"title":"IntelliJ IDEA配置Tomcat","slug":"148","date":"2021-06-14T21:38:51.000Z","updated":"2022-04-14T02:45:44.688Z","comments":true,"path":"148.html","link":"","permalink":"https://blog.zoutl.cn/148.html","excerpt":"","text":"打开配置界面 添加服务 配置Tomcat安装路径 配置端口我的8080被占用了，我设置成80端口，项目配置文件的端口也要一致 配置Deployment","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"安装Tomcat","slug":"147","date":"2021-06-14T21:18:19.000Z","updated":"2022-04-14T02:40:50.441Z","comments":true,"path":"147.html","link":"","permalink":"https://blog.zoutl.cn/147.html","excerpt":"","text":"下载网站地址：https://tomcat.apache.org/download-90.cgi 下载第三（32位）或者第四个（64位），根据自己的电脑选择（解压版，无需安装） 解压然后解压到指定文件夹即可","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"}]},{"title":"IntelliJ IDEA从GitHub克隆项目","slug":"146","date":"2021-06-14T20:01:21.000Z","updated":"2022-04-14T02:45:50.303Z","comments":true,"path":"146.html","link":"","permalink":"https://blog.zoutl.cn/146.html","excerpt":"","text":"获取Git链接 开始克隆 分两种类型：①克隆别人或自己的项目②克隆自己的项目 克隆别人或自己的项目 克隆自己的项目","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"MySQL5.6的安装与配置（解压版）","slug":"145","date":"2021-06-14T18:52:02.000Z","updated":"2022-04-14T02:34:55.117Z","comments":true,"path":"145.html","link":"","permalink":"https://blog.zoutl.cn/145.html","excerpt":"","text":"下载百度网盘链接：https://pan.baidu.com/s/1Cqx8KPLHYgnKPSL21jBZZA 提取码：g37r 解压根据自己的需求解压到对应文件夹 修改 my-default 文件根据刚刚解压的路径修改，默认将它注释，可以不修改 安装 用管理员权限运行CMD，进入bin文件夹 用 mysqld -install 命令安装 用 net start mysql 命令启动服务 设置密码安装成功以后，关闭当前命令行，重启cmd.exe 输入： mysqladmin -u root -p password 回车， 出现“Enter password：”，直接回车，未设置密码时默认没有密码， 出现“New password：”，输入新的密码，回车即可， 出现“Confirm new password:”，输入确认密码，回车即可。 修改完密码以后，下次重新登录时，键入 mysql -u root -p 即可，接着输入设置后的密码即可登录。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"IntelliJ IDEA配置Maven","slug":"144","date":"2021-06-14T18:17:21.000Z","updated":"2022-04-14T02:45:57.169Z","comments":true,"path":"144.html","link":"","permalink":"https://blog.zoutl.cn/144.html","excerpt":"","text":"1处选择maven安装路径（即bin文件夹所在路径） 2处选择settings文件的路径（打勾Override） 3处选择本地仓库路径（打勾Override）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"安装Maven","slug":"143","date":"2021-06-14T18:09:37.000Z","updated":"2022-04-14T02:29:50.674Z","comments":true,"path":"143.html","link":"","permalink":"https://blog.zoutl.cn/143.html","excerpt":"","text":"下载网站链接：https://maven.apache.org/download.cgi 点击下图中的划红线的链接即可开始下载 解压在指定的位置解压刚刚下载的压缩包（不需要安装） 配置环境变量 配置MAVEN_HOME（bin文件夹所在路径） 1D:\\Java\\apache-maven-3.8.1-bin\\apache-maven-3.8.1 配置Path 1%MAVEN_HOME%\\bin 查看是否配置成功，运行CMD，输入mvn -version 修改settings文件 修改本地仓库路径（根据自己需要设置，在第53行） 1&lt;localRepository&gt;D:/Java/apache-maven-3.8.1-bin/apache-maven-3.8.1/repository&lt;/localRepository&gt; 修改jar包下载地址（放在mirrors节点内） 1234567&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 查看是否配置成功，运行CMD，输入mvn help:system","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"}]},{"title":"switch语句","slug":"142","date":"2021-06-13T08:39:47.000Z","updated":"2022-04-14T02:11:44.855Z","comments":true,"path":"142.html","link":"","permalink":"https://blog.zoutl.cn/142.html","excerpt":"","text":"概述switch语句将从与选项值相匹配的case标签处开始执行直到遇到break语句，或者执行到switch语句的结束处为止。如果没有相匹配的case标签，而有default子句，就执行这个子句。（必须严格执行每个case必须以break语句结束，不然程序会继续执行下去，直到遇到break语句或者执行到default语句） 正确的例子Java代码： 1234567891011121314public static void main(String[] args) &#123; int i = 1; switch (i) &#123; case 1: System.out.println(1); break; case 2: System.out.println(2); break; default: System.out.println(3); break; &#125;&#125; 结果： 错误的例子Java代码： 1234567891011121314public static void main(String[] args) &#123; int i = 1; switch (i) &#123; case 1: System.out.println(1); case 2: System.out.println(2); default: System.out.println(3); break; &#125;&#125; 结果： 结果分析在错误的例子中，即使只有条件1符合条件，但是由于没有break语句终止程序，程序会继续执行下去，直到遇到break语句或执行完程序。（如果条件2有break语句，那么控制台只输出1和2）","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Highcharts的使用","slug":"141","date":"2021-06-08T14:15:11.000Z","updated":"2022-04-10T14:49:06.572Z","comments":true,"path":"141.html","link":"","permalink":"https://blog.zoutl.cn/141.html","excerpt":"","text":"引入1&lt;script src=&quot;http://code.highcharts.com/highcharts.js&quot;&gt;&lt;/script&gt; HTML代码1&lt;div id=&quot;container&quot;&gt;&lt;/div&gt; JavaScript代码123456789101112131415161718192021222324252627282930313233343536373839404142$(document).ready(function () &#123; var chart = new Highcharts.Chart(&#123; chart: &#123; renderTo: &quot;container&quot;, type: &#x27;column&#x27;, events: &#123; load: function (event) &#123; $.post(&quot;/blog/highlight&quot;, function (result) &#123; var rows = result.rows; var xArr = new Array(); var yArr = new Array(); for (var i = 0; i &lt; rows.length; i++) &#123; xArr.push(rows[i].name); yArr.push(rows[i].num); &#125; chart.xAxis[0].categories = xArr; chart.series[0].setData(yArr); &#125;, &quot;json&quot;); &#125; &#125; &#125;, //标题 title: &#123; text: &#x27;剩余水果数量&#x27; &#125;, //X轴的意义 xAxis: &#123; title: &#x27;水果类型&#x27;, &#125;, //Y轴的意义 yAxis: &#123; title: &#123; text: &#x27;数量&#x27; &#125; &#125;, //数据列的意义 series: [&#123; name: &#x27;数量&#x27;, &#125;] &#125;);&#125;); Java代码Fruit实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ledao.entity;/** * @author LeDao * @company * @create 2021-06-08 21:28 */public class Fruit &#123; /** * id */ private Integer id; /** * 名称 */ private String name; /** * 数量 */ private Integer num; public Fruit() &#123; &#125; public Fruit(String name, Integer num) &#123; this.name = name; this.num = num; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getNum() &#123; return num; &#125; public void setNum(Integer num) &#123; this.num = num; &#125;&#125; 从后台获取数据1234567891011121314@ResponseBody@RequestMapping(&quot;/highlight&quot;)public Map highlight() &#123; Map resultMap = new HashMap&lt;&gt;(16); List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;(); fruitList.add(new Fruit(&quot;苹果&quot;,8)); fruitList.add(new Fruit(&quot;香蕉&quot;,2)); fruitList.add(new Fruit(&quot;梨&quot;,16)); fruitList.add(new Fruit(&quot;油桃&quot;,7)); fruitList.add(new Fruit(&quot;西瓜&quot;,13)); fruitList.add(new Fruit(&quot;橘子&quot;,5)); resultMap.put(&quot;rows&quot;, fruitList); return resultMap;&#125; 结果截图 PS.如果将上面的柱状图换成折线图，将JavaScript代码中的 type: ‘column’ 改为 type: ‘line’ 即可 使用了jQuery，请先引入jQuery Highcharts中文官网：兼容 IE6+、完美支持移动端、图表类型丰富的 HTML5 交互图表 | Highcharts","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Highcharts","slug":"Highcharts","permalink":"https://blog.zoutl.cn/tags/Highcharts/"}]},{"title":"jQuery发送Ajax请求","slug":"140","date":"2021-06-08T07:44:52.000Z","updated":"2022-04-14T01:50:39.659Z","comments":true,"path":"140.html","link":"","permalink":"https://blog.zoutl.cn/140.html","excerpt":"","text":"HTML代码123&lt;h2 id=&quot;url2&quot;&gt;看我看我&lt;/h2&gt;url:&lt;input type=&quot;text&quot; required=&quot;required&quot; id=&quot;url1&quot;&gt;&lt;a href=&quot;javascript:click()&quot;&gt;&lt;button&gt;点击&lt;/button&gt;&lt;/a&gt; JavaScript代码1234567891011121314151617function click() &#123; var urlStr = $(&quot;#url1&quot;).val(); if (urlStr == null || urlStr == &#x27;&#x27;) &#123; alert(&quot;请输入链接!!&quot;); return false; &#125; $.ajax(&#123; url: &quot;/blog/getJson&quot;, type: &quot;post&quot;, data: &#123;urlStr: urlStr&#125;, success: function (result) &#123; var obj = JSON.parse(result); $(&quot;#url2&quot;).html(obj.name + &quot; : &quot; + obj.url); $(&quot;#url2&quot;).attr(&quot;style&quot;, &quot;color:red&quot;); &#125;, &#125;);&#125; Java代码Link实体类：（已省略setter和getter方法） 1234567891011121314151617181920212223242526272829303132333435363738package com.ledao.entity;/** * 友情链接实体 * * @author LeDao * @company * @create 2021-02-03 17:54 */public class Link &#123; /** * 编号 */ private Integer id; /** * 名称 */ private String name; /** * 链接地址 */ private String url; /** * 排列序号 */ private Integer sortNum; @Override public String toString() &#123; return &quot;Link&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, sortNum=&quot; + sortNum + &#x27;&#125;&#x27;; &#125;&#125; 请求的方法getJson： 123456789101112@ResponseBody@RequestMapping(&quot;/getJson&quot;)public String getJson(String urlStr) &#123; Link link = new Link(); link.setId(1); link.setName(&quot;LeDao的博客&quot;); link.setUrl(urlStr); link.setSortNum(1); Gson gson = new Gson(); String jsonString = gson.toJson(link); return jsonString;&#125; 参数说明 序 号 参数 说明 1 url String 类型参数，发送请求的地址 2 type String 类型参数，设置请求方式（ GET、POST、PUT、DELETE ） 3 timeout Number类型参数，设置请求超时时间（毫秒） 4 async Boolean 类型参数，默认设置为 true，当为 true 表示发送异步请求，当为 false 表示发送同步请求 5 cache Boolean 类型参数，默认设置为 true 默认为 true（当 dataType 为 script 时，默认为 false ），设置为false将不会从浏览器缓存中加载请求信息 6 data Object 或 String 类型的参数，发送请求的参数，如果是 GET 方式则以 ? &amp; 形式拼接到 url 中，如果是 POST 方式则将数据放在 FormData 中 7 dataType String类型的参数，指定服务器返回的数据类型 xml：返回XML文档 html：返回纯文本HTML信息 script：返回纯文本JavaScript代码 json：返回JSON数据 jsonp：JSONP格式 text：返回纯文本字符串 8 beforeSend Function 类型参数，发送请求前可以修改 XMLHttpRequest 对象的函数，例如添加自定义 HTTP 头 9 complete Function 类型参数，请求完成后调用的回调函数（请求成功或失败时均调用） 10 success Function 类型参数，请求成功的回调函数 11 error Function 类型参数，请求失败的回调函数 12 contentType String 类型参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded” 13 dataFilter Function类型参数，给Ajax返回的原始数据进行预处理的函数。提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的dataType参数。函数返回的值将由jQuery进一步处理function(data, type){ //返回处理后的数据 return data; } 14 global Boolean 类型参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件 15 ifModified Boolean 类型参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息 16 jsonp String 类型参数，在一个jsonp请求中重写回调函数的名字。该值用来替代在”callback=?”这种GET或POST请求中URL参数里的”callback”部分，例如{jsonp:’onJsonPLoad’}会导致将”onJsonPLoad=?”传给服务器 17 username String 类型参数，用于响应HTTP访问认证请求的用户名 18 password String 类型参数，用于响应HTTP访问认证请求的密码 19 processData Boolean 类型参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型”application/x-www-form-urlencoded”。如果要发送DOM树信息或者其他不希望转换的信息，请设置为false 20 scriptCharset String 类型参数，只有当请求时dataType为”jsonp”或者”script”，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用 PS.来源：JQuery 中使用 Ajax 发送 GET、POST 请求_assiduous_me的博客-CSDN博客_ajax发送get请求","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.zoutl.cn/tags/jQuery/"}]},{"title":"Maven找依赖包或下载jar包","slug":"139","date":"2021-06-07T02:45:29.000Z","updated":"2022-04-14T02:29:53.311Z","comments":true,"path":"139.html","link":"","permalink":"https://blog.zoutl.cn/139.html","excerpt":"","text":"进入网站https://mvnrepository.com/ 搜索搜索要使用的依赖包（搜索gson） 选择版本选择要使用的版本，点击Version列的版本号 下载点击第一条红线处的jar链接即可下载jar包，第二条红线处选择maven就是pom.xml的引入代码","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"}]},{"title":"Java解析JSON的四种方式","slug":"138","date":"2021-06-07T02:30:17.000Z","updated":"2022-04-14T02:11:31.555Z","comments":true,"path":"138.html","link":"","permalink":"https://blog.zoutl.cn/138.html","excerpt":"","text":"Link实体类已省略setter和getter方法 1234567891011121314151617181920212223242526272829303132333435363738package com.ledao.entity;/** * 友情链接实体 * * @author LeDao * @company * @create 2021-02-03 17:54 */public class Link &#123; /** * 编号 */ private Integer id; /** * 名称 */ private String name; /** * 链接地址 */ private String url; /** * 排列序号 */ private Integer sortNum; @Override public String toString() &#123; return &quot;Link&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, url=&#x27;&quot; + url + &#x27;\\&#x27;&#x27; + &quot;, sortNum=&quot; + sortNum + &#x27;&#125;&#x27;; &#125;&#125; 利用传统方式pom.xml代码： 12345&lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20160810&lt;/version&gt;&lt;/dependency&gt; Java代码： 12345678910111213141516171819202122232425262728293031323334package com.ledao;import com.ledao.entity.Link;import org.json.JSONObject;/** * @author LeDao * @company * @create 2021-06-07 7:25 */public class Test &#123; public static void main(String[] args) &#123; Link link = new Link(); link.setId(1); link.setName(&quot;LeDao的博客&quot;); link.setUrl(&quot;http://www.zoutl.cn&quot;); link.setSortNum(1); //实体类转Json JSONObject jsonObject = new JSONObject(); jsonObject.put(&quot;id&quot;, link.getId()); jsonObject.put(&quot;name&quot;, link.getName()); jsonObject.put(&quot;url&quot;, link.getUrl()); jsonObject.put(&quot;sortNum&quot;, link.getSortNum()); System.out.println(jsonObject.toString()); //Json转实体类 Link link2 = new Link(); link2.setId((Integer) jsonObject.get(&quot;id&quot;)); link2.setName((String) jsonObject.get(&quot;name&quot;)); link2.setUrl((String) jsonObject.get(&quot;url&quot;)); link2.setSortNum((Integer) jsonObject.get(&quot;sortNum&quot;)); System.out.println(link2.toString()); &#125;&#125; 利用Jackson方式pom.xml代码： 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.12.3&lt;/version&gt;&lt;/dependency&gt; Java代码： 12345678910111213141516171819202122232425262728package com.ledao;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.ledao.entity.Link;/** * @author LeDao * @company * @create 2021-06-07 7:25 */public class Test &#123; public static void main(String[] args) throws JsonProcessingException &#123; Link link = new Link(); link.setId(1); link.setName(&quot;LeDao的博客&quot;); link.setUrl(&quot;http://www.zoutl.cn&quot;); link.setSortNum(1); //实体类转Json ObjectMapper objectMapper = new ObjectMapper(); String jsonString = objectMapper.writeValueAsString(link); System.out.println(jsonString); //Json转实体类 Link link2 = objectMapper.readValue(jsonString,Link.class); System.out.println(link2.toString()); &#125;&#125; 利用GSON方式pom.xml代码： 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.5&lt;/version&gt;&lt;/dependency&gt; Java代码： 12345678910111213141516171819202122232425262728package com.ledao;import com.fasterxml.jackson.core.JsonProcessingException;import com.google.gson.Gson;import com.ledao.entity.Link;/** * @author LeDao * @company * @create 2021-06-07 7:25 */public class Test &#123; public static void main(String[] args) throws JsonProcessingException &#123; Link link = new Link(); link.setId(1); link.setName(&quot;LeDao的博客&quot;); link.setUrl(&quot;http://www.zoutl.cn&quot;); link.setSortNum(1); //实体类转Json Gson gson = new Gson(); String jsonString = gson.toJson(link); System.out.println(jsonString); //Json转实体类 Link link2 = gson.fromJson(jsonString, Link.class); System.out.println(link2.toString()); &#125;&#125; 利用FastJSON方式pom.xml代码： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt;&lt;/dependency&gt; Java代码： 123456789101112131415161718192021222324252627package com.ledao;import com.alibaba.fastjson.JSON;import com.fasterxml.jackson.core.JsonProcessingException;import com.ledao.entity.Link;/** * @author LeDao * @company * @create 2021-06-07 7:25 */public class Test &#123; public static void main(String[] args) throws JsonProcessingException &#123; Link link = new Link(); link.setId(1); link.setName(&quot;LeDao的博客&quot;); link.setUrl(&quot;http://www.zoutl.cn&quot;); link.setSortNum(1); //实体类转Json Object jsonString = JSON.toJSON(link); System.out.println(jsonString.toString()); //Json转实体类 Link link2 = JSON.parseObject(jsonString.toString(), Link.class); System.out.println(link2.toString()); &#125;&#125; 结果 几种方式的比较 类型 简介 传统Json方式 复杂的Json数据转换成实体类存在缺陷，性能和功能不够完善 Jackson方式 复杂的Json数据转换成实体类存在缺陷，性能和功能优于传统方式 Gson方式 功能方面在几种方式中最优，性能方面不如Jackson方式 FastJson方式 复杂的实体类转换成Json数据存在缺陷，解析json的速度优于其他方式 PS.来源：Java解析JSON的四种方式_云恒子-CSDN博客_java解析json","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"JSON","slug":"JSON","permalink":"https://blog.zoutl.cn/tags/JSON/"}]},{"title":"Java截取两个字符串之间的字符串","slug":"137","date":"2021-06-07T01:17:21.000Z","updated":"2022-04-14T02:11:29.909Z","comments":true,"path":"137.html","link":"","permalink":"https://blog.zoutl.cn/137.html","excerpt":"","text":"使用的方法String.indexOf传入的数据类型为String，返回传入字符串第一次出现的位置（索引从0开始，返回字符串第一个字符的位置） String.substring传入数据类型为两个int，用于截取字符串（包括头，不包括尾） Java代码12345678910111213141516171819package com.ledao;/** * @author LeDao * @company * @create 2021-06-07 7:25 */public class Test &#123; public static void main(String[] args) &#123; String str = &quot;12345678923&quot;; int begin = str.indexOf(&quot;23&quot;); int last = str.indexOf(&quot;89&quot;); System.out.println(&quot;\\&quot;23\\&quot;第一次出现的位置为:&quot; + begin); System.out.println(&quot;\\&quot;89\\&quot;第一次出现的位置为:&quot; + last); String substring = str.substring(begin + 2, last); System.out.println(&quot;截取的结果为:&quot; + substring); &#125;&#125; 结果 PS.要截取什么样的字符串可根据String.substring包括头不包括尾的特性来灵活截取","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java实现HTTP请求","slug":"136","date":"2021-06-07T00:44:57.000Z","updated":"2022-04-14T02:11:26.384Z","comments":true,"path":"136.html","link":"","permalink":"https://blog.zoutl.cn/136.html","excerpt":"","text":"commons-httpclient引入依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-httpclient&lt;/groupId&gt; &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243package com.ledao.util;import org.apache.commons.httpclient.HttpClient;import org.apache.commons.httpclient.HttpException;import org.apache.commons.httpclient.methods.GetMethod;import org.apache.commons.httpclient.params.HttpMethodParams;import java.io.IOException;/** * Http请求工具类 * * @author LeDao * @company * @create 2021-06-07 7:47 */public class HttpClientUtil &#123; public static String sendGet(String urlParam) throws HttpException, IOException &#123; // 创建httpClient实例对象 HttpClient httpClient = new HttpClient(); // 设置httpClient连接主机服务器超时时间：15000毫秒 httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(15000); // 创建GET请求方法实例对象 GetMethod getMethod = new GetMethod(urlParam); // 设置post请求超时时间 getMethod.getParams().setParameter(HttpMethodParams.SO_TIMEOUT, 60000); getMethod.addRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;); httpClient.executeMethod(getMethod); String result = getMethod.getResponseBodyAsString(); getMethod.releaseConnection(); return result; &#125; public static void main(String[] args) throws IOException &#123; String ip = &quot;116.179.32.87&quot;; String url = &quot;http://ip.ws.126.net/ipquery?ip=&quot; + ip; String result = sendGet(url); System.out.println(result); &#125;&#125; 使用Hutool CKEDITOR.replace(\"content\");html12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.9&lt;/version&gt;&lt;/dependency&gt; Java代码123456public static void main(String[] args) &#123; String ip = &quot;116.179.32.87&quot;; String url = &quot;http://ip.ws.126.net/ipquery?ip=&quot; + ip; String str = HttpUtil.get(url); System.out.println(str);&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"使用CKEditor富文本编辑器","slug":"135","date":"2021-06-06T12:04:44.000Z","updated":"2022-04-14T02:11:24.529Z","comments":true,"path":"135.html","link":"","permalink":"https://blog.zoutl.cn/135.html","excerpt":"","text":"引入1&lt;script type=&quot;text/javascript&quot; src=&quot;/static/ckeditor/ckeditor.js&quot;&gt;&lt;/script&gt; HTML代码使用textarea标签 1&lt;textarea id=&quot;content&quot; name=&quot;content&quot; rows=&quot;30&quot; cols=&quot;80&quot;&gt;&lt;/textarea&gt; JavaScript代码123&lt;script type=&quot;text/javascript&quot;&gt; CKEDITOR.replace(&quot;content&quot;);&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CKEditor","slug":"CKEditor","permalink":"https://blog.zoutl.cn/tags/CKEditor/"}]},{"title":"EasyUI格式化网格数据","slug":"134","date":"2021-06-06T11:32:34.000Z","updated":"2022-04-14T01:40:39.853Z","comments":true,"path":"134.html","link":"","permalink":"https://blog.zoutl.cn/134.html","excerpt":"","text":"说明Blog实体类（博客实体）和BlogType实体类（博客类别实体），每个blog都有对应的blogType，博客类别实体有名称等属性，而我们只需要显示博客类别的名称，则格式化过程如下所示： Java代码Blog实体类：（博客实体，已省略setter和getter方法） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.ledao.entity;import java.util.Date;/** * 博客实体 * * @author LeDao * @company * @create 2020-09-11 00:08 */public class Blog &#123; /** * id */ private Integer id; /** * 标题 */ private String title; /** * 摘要 */ private String summary; /** * 内容 */ private String content; /** * 发布时间 */ private Date releaseDate; /** * 点击次数 */ private Integer click; /** * 博客类别id */ private Integer blogTypeId; /** * 博客类别 */ private BlogType blogType; /** * 博客里存在的第一张图片，主要用于列表展示的缩略图 */ private String imageName; /** * 博客数量 非博客实际属性 主要是 根据发布日期归档查询数量用到 */ private Integer blogCount; /** * 发布日期的字符串 只取年和月 */ private String releaseDateStr; /** * 该类型的博客数量 */ private Integer blogNum; /** * 用于判断当前IP是否点赞过这篇博客 */ private Integer isLike; /** * 点赞数 */ private Integer likeNum; /** * 是否是导航条文章（0或空代表不是，1代表是） */ private Integer isMenuBlog; /** * 设置成为导航条文章的时间 */ private Date setMenuBlogDate; &#125; BlogType实体类：（博客类别实体，已省略setter和getter方法） 1234567891011121314151617181920212223242526272829package com.ledao.entity;/** * 博客类别实体类 * * @author LeDao * @company * @create 2020-09-10 21:22 */public class BlogType &#123; /** * id */ private Integer id; /** * 博客类别名称 */ private String name; /** * 排列数字 */ private Integer sortNum; /** * 该类别的博客数量 */ private Long blogNum; &#125; HTML代码12345678910111213&lt;table id=&quot;dg&quot; title=&quot;博客管理&quot; class=&quot;easyui-datagrid&quot; striped=&quot;true&quot; fitColumns=&quot;true&quot; pagination=&quot;true&quot; rownumbers=&quot;true&quot; url=&quot;/admin/blog/list&quot; fit=&quot;true&quot; toolbar=&quot;#tb&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th field=&quot;cb&quot; checkbox=&quot;true&quot; align=&quot;center&quot;&gt;&lt;/th&gt; &lt;th field=&quot;id&quot; width=&quot;20&quot; align=&quot;center&quot;&gt;编号&lt;/th&gt; &lt;th field=&quot;title&quot; width=&quot;200&quot; align=&quot;center&quot; formatter=&quot;formatTitle&quot;&gt;标题&lt;/th&gt; &lt;th field=&quot;releaseDate&quot; width=&quot;50&quot; align=&quot;center&quot;&gt;发布日期&lt;/th&gt; &lt;th field=&quot;blogType&quot; width=&quot;50&quot; align=&quot;center&quot; formatter=&quot;formatType&quot;&gt;博客类型&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt;&lt;/table&gt; JavaScript代码123function formatType(val, row) &#123; return val.name;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"EasyUI","slug":"EasyUI","permalink":"https://blog.zoutl.cn/tags/EasyUI/"}]},{"title":"title标签加图标","slug":"133","date":"2021-06-03T14:49:59.000Z","updated":"2022-04-10T05:02:29.178Z","comments":true,"path":"133.html","link":"","permalink":"https://blog.zoutl.cn/133.html","excerpt":"","text":"HTML代码1&lt;link rel=&quot;short icon&quot; href=&quot;/static/images/favicon.ico&quot;&gt; 效果 PS.如果是Vue项目，要将图片放在static文件夹下面，上面的代码放在index.html里面","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"jQuery让鼠标定位到指定输入框","slug":"132","date":"2021-06-02T23:06:33.000Z","updated":"2022-04-14T01:50:48.800Z","comments":true,"path":"132.html","link":"","permalink":"https://blog.zoutl.cn/132.html","excerpt":"","text":"HTML代码1&lt;input type=&quot;text&quot; id=&quot;codeStyle&quot; class=&quot;easyui-validatebox&quot; required=&quot;true&quot; style=&quot;width: 200px&quot;&gt; JavaScript代码1$(&quot;#codeStyle&quot;).get(0).focus(); PS.来源：用jquery让鼠标定位输入框_白不懂黑的静的专栏-CSDN博客","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://blog.zoutl.cn/tags/jQuery/"}]},{"title":"给highlight.js代码高亮加行号","slug":"131","date":"2021-06-02T16:47:36.000Z","updated":"2022-04-14T02:00:19.413Z","comments":true,"path":"131.html","link":"","permalink":"https://blog.zoutl.cn/131.html","excerpt":"","text":"CSS代码12345678910111213141516171819202122232425262728293031323334353637383940.hljsln &#123; position: relative; display: block; padding-left: 3em !important;&#125;.hljsln .ln-bg &#123; position: absolute; z-index: 1; top: 0; left: 0; width: 2.2em; height: 100%; border-right: 1px solid #555; background: rgba(255, 255, 255, 0.18);&#125;.hljsln .ln-num &#123; position: relative; display: inline-block; height: 1em; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125;.hljsln .ln-num::before &#123; position: absolute; z-index: 2; top: 0; right: 0; margin-right: 1em; color: #777; font-style: normal; font-weight: normal; content: attr(data-num);&#125; JavaScript代码将JavaScript代码保存为文件 highlight.line-numbers.js 123456789101112131415161718192021222324252627282930313233343536373839(function (w, d) &#123; w.hljsln = &#123; initLineNumbersOnLoad: initLineNumbersOnLoad, addLineNumbersForCode: addLineNumbersForCode &#125;; function initLineNumbersOnLoad() &#123; if (d.readyState === &#x27;interactive&#x27; || d.readyState === &#x27;complete&#x27;) &#123; documentReady(); &#125; else &#123; w.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123; documentReady(); &#125;); &#125; &#125; function addLineNumbersForCode(html) &#123; var num = 1; html = &#x27;&lt;span class=&quot;ln-num&quot; data-num=&quot;&#x27; + num + &#x27;&quot;&gt;&lt;/span&gt;&#x27; + html; html = html.replace(/\\r\\n|\\r|\\n/g, function (a) &#123; num++; return a + &#x27;&lt;span class=&quot;ln-num&quot; data-num=&quot;&#x27; + num + &#x27;&quot;&gt;&lt;/span&gt;&#x27;; &#125;); html = &#x27;&lt;span class=&quot;ln-bg&quot;&gt;&lt;/span&gt;&#x27; + html; return html; &#125; function documentReady() &#123; var elements = d.querySelectorAll(&#x27;pre code&#x27;); for (var i = 0; i &lt; elements.length; i++) &#123; if (elements[i].className.indexOf(&#x27;hljsln&#x27;) == -1) &#123; var html = elements[i].innerHTML; html = addLineNumbersForCode(html); elements[i].innerHTML = html; elements[i].className += &#x27; hljsln&#x27;; &#125; &#125; &#125;&#125;(window, document)); 加载并执行初始化如下1234&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/androidstudio.min.css&quot;&gt;&lt;script th:src=&quot;@&#123;/static/js/highlight.line-numbers.js&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();hljsln.initLineNumbersOnLoad();&lt;/script&gt; 结果如下图 可以看到第1和8行是空行，但是也显示了行号，为了让它不显示，将上面JavaScript代码中的addLineNumbersForCode方法修改成下面的代码即可：（修改后结果如下图所示） JavaScript代码： 1234567891011121314151617181920function addLineNumbersForCode(html) &#123; var num = 0; var max = 0; html = html.replace(/\\r\\n|\\r|\\n/g, function (b) &#123; max++; if (max != 0) &#123; return b; &#125; &#125;); html = html.replace(/\\r\\n|\\r|\\n/g, function (a) &#123; num++; if (num != 0 &amp;&amp; num != max) &#123; return a + &#x27;&lt;span class=&quot;ln-num&quot; data-num=&quot;&#x27; + num + &#x27;&quot;&gt;&lt;/span&gt;&#x27;; &#125;else if (num != 0 &amp;&amp; num == max) &#123; return a + &#x27; &#x27;; &#125; &#125;); html = &#x27;&lt;span class=&quot;ln-bg&quot; style=&quot;margin-left: 1px&quot;&gt;&lt;/span&gt;&#x27; + html; return html;&#125; 图片： PS.来源：自己写 highlight.js 行号插件 | 天角星","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"highlight.js","slug":"highlight-js","permalink":"https://blog.zoutl.cn/tags/highlight-js/"}]},{"title":"highlight.js代码样式名称","slug":"130","date":"2021-06-01T01:46:06.000Z","updated":"2022-04-14T02:00:22.867Z","comments":true,"path":"130.html","link":"","permalink":"https://blog.zoutl.cn/130.html","excerpt":"","text":"使用说明本博客系统专用或者和本站引用同一个网站的cdn加速 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/androidstudio.min.css&quot;&gt; 常用语言类型HTML, XML，Bash，CSS，Java，JavaScript，JSON，SQL 代码样式名称更换代码样式直接修改link标签的css文件名，例如：将androidstudio改为github就行了 androidstudio agate github idea ascetic brown-paper codepen-embed color-brewer dark docco far foundation gml googlecode gradient-dark gradient-light grayscale hybrid ir-black isbl-editor-dark isbl-editor-light lioshi magula mono-blue monokai monokai-sublime night-owl nnfx-dark nnfx-light pojoaque purebasic rainbow routeros school-book shades-of-purple srcery stackoverflow-dark stackoverflow-light sunburst tomorrow-night-blue tomorrow-night-bright vs xcode an-old-hope atelier-forest-light atom-one-dark-reasonable atom-one-dark atom-one-light color-brewer darcula docco dracula github-gist gml PS.更多样式去官网查看：highlight.js demo","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"highlight.js","slug":"highlight-js","permalink":"https://blog.zoutl.cn/tags/highlight-js/"}]},{"title":"MySQL获取时间差","slug":"129","date":"2021-06-01T00:06:14.000Z","updated":"2022-04-14T02:34:59.283Z","comments":true,"path":"129.html","link":"","permalink":"https://blog.zoutl.cn/129.html","excerpt":"","text":"DATEDIFF函数只可以计算天数 SQL语句： 1SELECT DATEDIFF (&quot;2021-04-25 23:23:12&quot;,&quot;2021-04-21 23:23:12&quot;) AS days; 结果： TIMESTAMPDIFF函数可以根据自己的需求计算天数、小时、分钟、秒钟 SQL语句： 1234SELECT TIMESTAMPDIFF (DAY,&quot;2021-04-21 23:23:12&quot;,&quot;2021-04-25 23:23:12&quot;) AS &quot;天&quot;;SELECT TIMESTAMPDIFF (HOUR,&quot;2021-04-21 23:23:12&quot;,&quot;2021-04-25 23:23:12&quot;) AS &quot;时&quot;;SELECT TIMESTAMPDIFF (MINUTE,&quot;2021-04-21 23:23:12&quot;,&quot;2021-04-25 23:23:12&quot;) AS &quot;分&quot;;SELECT TIMESTAMPDIFF (SECOND,&quot;2021-04-21 23:23:12&quot;,&quot;2021-04-25 23:23:12&quot;) AS &quot;秒&quot;; 结果：（图片从上到下与上面的SQL语句从上到下一一对应） PS.来源：mysql 比较两个日期的时间差 - 未确定 - 博客园","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"HTML+JavaScript动态获取当前时间","slug":"128","date":"2021-05-31T23:50:46.000Z","updated":"2022-03-27T15:59:30.627Z","comments":true,"path":"128.html","link":"","permalink":"https://blog.zoutl.cn/128.html","excerpt":"","text":"HTML代码12&lt;p id=&quot;tipForTime&quot; style=&quot;color: #00B0E8;text-align: center&quot;&gt;&lt;/p&gt;&lt;p&gt;当前时间:&amp;nbsp;&lt;span id=&quot;time&quot; style=&quot;color: grey&quot;&gt;&lt;/span&gt;&lt;/p&gt; JavaScript代码12345678910111213141516171819202122232425262728293031323334353637//获取当前时间window.onload = function () &#123; window.requestAnimationFrame(getDate)&#125;function getDate() &#123; window.setTimeout(function () &#123; window.requestAnimationFrame(getDate) &#125;, 1000 / 2) var d = new Date(); var year = d.getFullYear() //获取年 var month = d.getMonth() + 1; //获取月，从 Date 对象返回月份 (0 ~ 11)，故在此处+1 var day = d.getDay() //获取日 var days = d.getDate() //获取日期 var hour = d.getHours() //获取小时 var minute = d.getMinutes() //获取分钟 var second = d.getSeconds() //获取秒 if (month &lt; 10) month = &quot;0&quot; + month if (days &lt; 10) days = &quot;0&quot; + days if (hour &lt; 10) hour = &quot;0&quot; + hour if (minute &lt; 10) minute = &quot;0&quot; + minute if (second &lt; 10) second = &quot;0&quot; + second if (hour &gt;= 6 &amp;&amp; hour &lt; 12) &#123; $(&quot;#tipForTime&quot;).html(&quot;早上好!&quot;); &#125; else if (hour &gt;= 12 &amp;&amp; hour &lt; 19) &#123; $(&quot;#tipForTime&quot;).html(&quot;下午好!&quot;); &#125; else if (hour &gt;= 19 &amp;&amp; hour &lt; 23) &#123; $(&quot;#tipForTime&quot;).html(&quot;晚上好!&quot;); &#125; else &#123; $(&quot;#tipForTime&quot;).html(&quot;夜深了!请注意休息!!!&quot;); &#125; var week = new Array(&quot;星期日&quot;, &quot;星期一&quot;, &quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;) var Tools = document.getElementById(&quot;time&quot;) var time = year + &quot;-&quot; + month + &quot;-&quot; + days + &quot; &quot; + hour + &quot;:&quot; + minute + &quot;:&quot; + second+&quot; &quot;+week[day] $(&quot;#time&quot;).html(time);&#125; 结果如下图 PS.来源：HTML+JS动态获取当前时间_公众号：【C you again】-CSDN博客_js显示当前时间","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"一套绝佳的图标字体库和CSS框架：Font Awesome图标","slug":"127","date":"2021-05-31T21:37:38.000Z","updated":"2022-03-27T16:02:05.658Z","comments":true,"path":"127.html","link":"","permalink":"https://blog.zoutl.cn/127.html","excerpt":"","text":"概述Font Awesome是一套绝佳的图标字体库和CSS框架。 Font Awesome字体为您提供可缩放矢量图标,它可以被定制大小、颜色、阴影以及任何可以用CSS的样式。 引入1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt; 使用1&lt;i class=&quot;fa fa-car&quot;&gt;&lt;/i&gt; 代码12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;i class=&quot;fa fa-car&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car&quot; style=&quot;font-size:48px;&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car&quot; style=&quot;font-size:60px;color:red;&quot;&gt;&lt;/i&gt; &lt;/body&gt;&lt;/html&gt; PS.查看更多图标以及来源：Font Awesome 图标 | 菜鸟教程","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"highlight.js实现代码高亮","slug":"126","date":"2021-05-30T16:53:39.000Z","updated":"2022-04-14T02:00:31.616Z","comments":true,"path":"126.html","link":"","permalink":"https://blog.zoutl.cn/126.html","excerpt":"","text":"引入更换代码样式直接修改link标签的css文件名，例如：将androidstudio改为github就行了，更多样式名称查看：highlight.js代码样式名称 123&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/androidstudio.min.css&quot;&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 代码块外围代码code标签的class内填代码类型，不填也可以，会自动检测 12345&lt;pre&gt; &lt;code class=&quot;HTML&quot;&gt; &lt;/code&gt;&lt;/pre&gt; 特别地，上面的格式会让代码块和上面的元素空出一行，如果不想空出一行，让&lt;code&gt;头标签顶格就行，如下所示： 12345&lt;pre&gt;&lt;code class=&quot;HTML&quot;&gt;&lt;/code&gt;&lt;/pre&gt; 转义HTML代码HTML代码转义网站：HTML转义工具-前端开发转换工具 | WEB前端开发 填写代码在code标签内填入要展示的代码 PS.highlight.js官网：highlight.js","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"highlight.js","slug":"highlight-js","permalink":"https://blog.zoutl.cn/tags/highlight-js/"}]},{"title":"MyBatis的关联（association）元素","slug":"125","date":"2021-05-26T04:33:42.000Z","updated":"2022-04-14T01:44:38.618Z","comments":true,"path":"125.html","link":"","permalink":"https://blog.zoutl.cn/125.html","excerpt":"","text":"关联（association）元素处理“有一个”类型的关系。 比如，在示例中，每个博客有一个作者 1234567&lt;resultMap id=&quot;blogResult&quot; type=&quot;Blog&quot;&gt; &lt;association property=&quot;author&quot; column=&quot;author_id&quot; javaType=&quot;Author&quot; select=&quot;selectAuthor&quot;/&gt;&lt;/resultMap&gt; &lt;select id=&quot;selectAuthor&quot; resultType=&quot;Author&quot;&gt; SELECT * FROM AUTHOR WHERE ID = #&#123;id&#125;&lt;/select&gt;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"MyBatis动态SQL示例","slug":"124","date":"2021-05-26T04:27:05.000Z","updated":"2022-04-14T01:44:46.271Z","comments":true,"path":"124.html","link":"","permalink":"https://blog.zoutl.cn/124.html","excerpt":"","text":"if123456789101112131415161718192021222324252627&lt;select id=&quot;list&quot; parameterType=&quot;map&quot; resultMap=&quot;BlogResult&quot;&gt; select * from t_blog &lt;where&gt; &lt;if test=&quot;title != null and title != &#x27;&#x27;&quot;&gt; and title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;blogTypeId != null&quot;&gt; and blogTypeId = #&#123;blogTypeId&#125; &lt;/if&gt; &lt;if test=&quot;isMenuBlog != null&quot;&gt; and isMenuBlog = #&#123;isMenuBlog&#125; &lt;/if&gt; &lt;if test=&quot;isMenuBlogKey != null&quot;&gt; and isMenuBlog != 1 &lt;/if&gt; &lt;if test=&quot;releaseDateStr != null and releaseDateStr != &#x27;&#x27;&quot;&gt; and date_format(releaseDate, &#x27;%Y年%m月&#x27;) = #&#123;releaseDateStr&#125; &lt;/if&gt; &lt;/where&gt; &lt;if test=&quot;sortByReleaseDate == null&quot;&gt; order by releaseDate desc &lt;/if&gt; &lt;if test=&quot;start != null and size != null&quot;&gt; limit #&#123;start&#125;,#&#123;size&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise123456789101112131415&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; trim、where、set123456789101112131415161718192021222324252627282930&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt; ...&lt;/trim&gt;&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test=&quot;state != null&quot;&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test=&quot;title != null&quot;&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null and author.name != null&quot;&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt; update Author &lt;set&gt; &lt;if test=&quot;username != null&quot;&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test=&quot;password != null&quot;&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=&quot;bio != null&quot;&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; foreach123456789&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; script1234567891011@Update(&#123;&quot;&lt;script&gt;&quot;, &quot;update Author&quot;, &quot; &lt;set&gt;&quot;, &quot; &lt;if test=&#x27;username != null&#x27;&gt;username=#&#123;username&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;password != null&#x27;&gt;password=#&#123;password&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;email != null&#x27;&gt;email=#&#123;email&#125;,&lt;/if&gt;&quot;, &quot; &lt;if test=&#x27;bio != null&#x27;&gt;bio=#&#123;bio&#125;&lt;/if&gt;&quot;, &quot; &lt;/set&gt;&quot;, &quot;where id=#&#123;id&#125;&quot;, &quot;&lt;/script&gt;&quot;&#125;)void updateAuthorValues(Author author); bind12345&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot; /&gt; SELECT * FROM BLOG WHERE title LIKE #&#123;pattern&#125;&lt;/select&gt;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"MyBatis的增删改查示例（XML映射器）","slug":"123","date":"2021-05-26T03:31:18.000Z","updated":"2022-04-14T01:44:48.615Z","comments":true,"path":"123.html","link":"","permalink":"https://blog.zoutl.cn/123.html","excerpt":"","text":"增加123&lt;insert id=&quot;add&quot; parameterType=&quot;BlogType&quot;&gt; insert into t_blogtype (name, sortNum) values (#&#123;name&#125;,#&#123;sortNum&#125;);&lt;/insert&gt; 删除123&lt;delete id=&quot;delete&quot; parameterType=&quot;integer&quot;&gt; delete from t_blogtype where id=#&#123;id&#125;&lt;/delete&gt; 修改123456789101112&lt;update id=&quot;update&quot; parameterType=&quot;BlogType&quot;&gt; update t_blogtype &lt;set&gt; &lt;if test=&quot;name != null and name != &#x27;&#x27;&quot;&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=&quot;sortNum != null&quot;&gt; sortNum=#&#123;sortNum&#125;, &lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; 查询123&lt;select id=&quot;findById&quot; parameterType=&quot;integer&quot; resultMap=&quot;BlogTypeResult&quot;&gt; select * from t_blogtype where id=#&#123;id&#125;&lt;/select&gt; PS.相关元素查看博客：mybatis的元素属性","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"MyBatis的结果映射","slug":"122","date":"2021-05-26T01:44:36.000Z","updated":"2022-04-14T01:44:51.260Z","comments":true,"path":"122.html","link":"","permalink":"https://blog.zoutl.cn/122.html","excerpt":"","text":"结果映射的作用resultMap 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC ResultSets 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 resultMap 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了 代码实体类（已经省略getter和setter方法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.ledao.entity; import java.util.Date; /** * 博客实体 * * @author LeDao * @company * @create 2020-09-11 00:08 */public class Blog &#123; /** * id */ private Integer id; /** * 标题 */ private String title; /** * 摘要 */ private String summary; /** * 内容 */ private String content; /** * 发布时间 */ private Date releaseDate; /** * 点击次数 */ private Integer click; /** * 博客类别id */ private Integer blogTypeId; /** * 博客类别 */ private BlogType blogType; /** * 博客里存在的第一张图片，主要用于列表展示的缩略图 */ private String imageName; /** * 博客数量 非博客实际属性 主要是 根据发布日期归档查询数量用到 */ private Integer blogCount; /** * 发布日期的字符串 只取年和月 */ private String releaseDateStr; /** * 该类型的博客数量 */ private Integer blogNum; /** * 用于判断当前IP是否点赞过这篇博客 */ private Integer isLike; /** * 点赞数 */ private Integer likeNum; /** * 是否是导航条文章（0或空代表不是，1代表是） */ private Integer isMenuBlog; /** * 设置成为导航条文章的时间 */ private Date setMenuBlogDate;&#125; XML文件中的结果映射代码（相关属性查看博客：mybatis的元素属性） 1234567891011&lt;resultMap id=&quot;BlogResult&quot; type=&quot;Blog&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt; &lt;result property=&quot;summary&quot; column=&quot;summary&quot;/&gt; &lt;result property=&quot;releaseDate&quot; column=&quot;releaseDate&quot;/&gt; &lt;result property=&quot;click&quot; column=&quot;click&quot;/&gt; &lt;result property=&quot;content&quot; column=&quot;content&quot;/&gt; &lt;result property=&quot;blogTypeId&quot; column=&quot;blogTypeId&quot;/&gt; &lt;result property=&quot;isMenuBlog&quot; column=&quot;isMenuBlog&quot;/&gt; &lt;result property=&quot;setMenuBlogDate&quot; column=&quot;setMenuBlogDate&quot;/&gt;&lt;/resultMap&gt;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"MyBatis的元素属性","slug":"121","date":"2021-05-26T01:33:03.000Z","updated":"2022-04-14T02:11:11.698Z","comments":true,"path":"121.html","link":"","permalink":"https://blog.zoutl.cn/121.html","excerpt":"","text":"Select 值 作用 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 resultType 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 resultMap 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 flushCache package com.ledao.service.impl; import com.ledao.entity.Blog;import com.ledao.mapper.BlogMapper;import com.ledao.service.BlogService;import org.springframework.stereotype.Service; import javax.annotation.Resource;import java.util.List;import java.util.Map; /** * 博客Service接口实现类 * * @author LeDao * @company * @create 2020-09-11 00:34 */@Service(“blogService”)public class BlogServiceImpl implements BlogService { @Resource private BlogMapper blogMapper; @Override public List list(Map map) { return blogMapper.list(map); } @Override public Long getCount(Map map) { return blogMapper.getCount(map); } @Override public Integer add(Blog blog) { return blogMapper.add(blog); } @Override public Integer update(Blog blog) { return blogMapper.update(blog); } @Override public Integer delete(Integer id) { return blogMapper.delete(id); } @Override public Blog findById(Integer id) { return blogMapper.findById(id); } @Override public List countList() { return blogMapper.countList(); } @Override public List findByBlogTypeId(Integer blogTypeId) { return blogMapper.findByBlogTypeId(blogTypeId); } @Override public Blog getPreviousBlog(Integer id) { return blogMapper.getPreviousBlog(id); } @Override public Blog getNextBlog(Integer id) { return blogMapper.getNextBlog(id); } @Override public List getMenuBlogList() { return blogMapper.getMenuBlogList(); }}java useCache 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 fetchSize 这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 resultSetType FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 resultOrdered 这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：false。 Insert, Update, Delete 值 作用 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 selectKey 值 作用 keyProperty selectKey 语句结果应该被设置到的目标属性。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn 返回结果集中生成列属性的列名。如果生成列不止一个，可以用逗号分隔多个属性名称。 resultType 结果的类型。通常 MyBatis 可以推断出来，但是为了更加准确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果生成列不止一个，则可以使用包含期望属性的 Object 或 Map。 order 可以设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它首先会生成主键，设置 keyProperty 再执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。 statementType 和前面一样，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 类型的映射语句，分别代表 Statement, PreparedStatement 和 CallableStatement 类型。 ResultMap 值 作用 id 当前命名空间中的一个唯一标识，用于标识一个结果映射。 type 类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。 autoMapping 如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）。 ResultMap子元素 ResultMap子元素Id和Result 值 作用 property 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 无论是哪一种情形，你都可以使用常见的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。 ResultMap子元素constructor 值 作用 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性中指定的列检索数据，作为参数传递给此 select 语句。具体请参考关联元素。 resultMap 结果映射的 ID，可以将嵌套的结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 将会将包含重复或部分数据重复的结果集。为了将结果集正确地映射到嵌套的对象树中，MyBatis 允许你 “串联”结果映射，以便解决嵌套结果集的问题。想了解更多内容，请参考下面的关联元素。 name 构造方法形参的名字。从 3.4.3 版本开始，通过指定具体的参数名，你可以以任意顺序写入 arg 元素。 ResultMap子元素association 值 作用 property 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 javaType 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 jdbcType JDBC 类型，所支持的 JDBC 类型参见这个表格之前的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 typeHandler 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型别名。 关联的嵌套Select 查询 column 数据库中的列名，或者是列的别名。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 select 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=&quot;&#123;prop1=col1,prop2=col2&#125;&quot; 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。 fetchType 可选的。有效值为 lazy 和 eager。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled，使用属性的值。 关联的嵌套结果映射 resultMap 结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 ResultSet。这样的 ResultSet 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。 columnPrefix 当连接多个表时，你可能会不得不使用列别名来避免在 ResultSet 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。 notNullColumn 默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。 autoMapping 如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 select 或 resultMap 元素使用。默认值：未设置（unset）。","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"Spring Boot引入MyBatis","slug":"120","date":"2021-05-26T01:22:21.000Z","updated":"2022-04-14T01:44:56.499Z","comments":true,"path":"120.html","link":"","permalink":"https://blog.zoutl.cn/120.html","excerpt":"","text":"引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; application.yml配置12345678#mybatis的相关配置mybatis: #mapper配置文件 mapper-locations: classpath:mybatis/mapper/*.xml type-aliases-package: com.ledao.entity #开启驼峰命名 configuration: map-underscore-to-camel-case: true 加入@MapperScan注解在项目的启动类中加入@MapperScan注解，这样就可以指定要扫描的Mapper类的包的路径了 项目代码示例以对一个博客类进行操作为例 Blog类已省略setter和getter方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.ledao.entity; import java.util.Date; /** * 博客实体 * * @author LeDao * @company * @create 2020-09-11 00:08 */public class Blog &#123; /** * id */ private Integer id; /** * 标题 */ private String title; /** * 摘要 */ private String summary; /** * 内容 */ private String content; /** * 发布时间 */ private Date releaseDate; /** * 点击次数 */ private Integer click; /** * 博客类别id */ private Integer blogTypeId; /** * 博客类别 */ private BlogType blogType; /** * 博客里存在的第一张图片，主要用于列表展示的缩略图 */ private String imageName; /** * 博客数量 非博客实际属性 主要是 根据发布日期归档查询数量用到 */ private Integer blogCount; /** * 发布日期的字符串 只取年和月 */ private String releaseDateStr; /** * 该类型的博客数量 */ private Integer blogNum; /** * 用于判断当前IP是否点赞过这篇博客 */ private Integer isLike; /** * 点赞数 */ private Integer likeNum; /** * 是否是导航条文章（0或空代表不是，1代表是） */ private Integer isMenuBlog; /** * 设置成为导航条文章的时间 */ private Date setMenuBlogDate;&#125; BlogMapper接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.ledao.mapper; import com.ledao.entity.Blog; import java.util.List;import java.util.Map; /** * 博客Mapper接口 * * @author LeDao * @company * @create 2020-09-11 00:11 */public interface BlogMapper &#123; /** * 分页分条件查询博客 * * @param map * @return */ List&lt;Blog&gt; list(Map map); /** * 获取记录数 * * @param map * @return */ Long getCount(Map map); /** * 添加博客 * * @param blog * @return */ Integer add(Blog blog); /** * 修改博客 * * @param blog * @return */ Integer update(Blog blog); /** * 根据id删除博客 * * @param id * @return */ Integer delete(Integer id); /** * 根据id查找博客 * * @param id * @return */ Blog findById(Integer id); /** * 根据日期分月分组查询 * * @return */ List&lt;Blog&gt; countList(); /** * 根据博客类型查询博客 * * @param blogTypeId * @return */ List&lt;Blog&gt; findByBlogTypeId(Integer blogTypeId); /** * 获取上一篇博客 * * @param id * @return */ Blog getPreviousBlog(Integer id); /** * 获取下一篇博客 * * @param id * @return */ Blog getNextBlog(Integer id); /** * 获取导航条文章（根据设置时间升序排列） * * @return */ List&lt;Blog&gt; getMenuBlogList();&#125; BlogMapper的XML文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--suppress ALL--&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.ledao.mapper.BlogMapper&quot;&gt; &lt;resultMap id=&quot;BlogResult&quot; type=&quot;Blog&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;title&quot; column=&quot;title&quot;/&gt; &lt;result property=&quot;summary&quot; column=&quot;summary&quot;/&gt; &lt;result property=&quot;releaseDate&quot; column=&quot;releaseDate&quot;/&gt; &lt;result property=&quot;click&quot; column=&quot;click&quot;/&gt; &lt;result property=&quot;content&quot; column=&quot;content&quot;/&gt; &lt;result property=&quot;blogTypeId&quot; column=&quot;blogTypeId&quot;/&gt; &lt;result property=&quot;isMenuBlog&quot; column=&quot;isMenuBlog&quot;/&gt; &lt;result property=&quot;setMenuBlogDate&quot; column=&quot;setMenuBlogDate&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;list&quot; parameterType=&quot;map&quot; resultMap=&quot;BlogResult&quot;&gt; select * from t_blog &lt;where&gt; &lt;if test=&quot;title != null and title != &#x27;&#x27;&quot;&gt; and title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;blogTypeId != null&quot;&gt; and blogTypeId = #&#123;blogTypeId&#125; &lt;/if&gt; &lt;if test=&quot;isMenuBlog != null&quot;&gt; and isMenuBlog = #&#123;isMenuBlog&#125; &lt;/if&gt; &lt;if test=&quot;isMenuBlogKey != null&quot;&gt; and isMenuBlog != 1 &lt;/if&gt; &lt;if test=&quot;releaseDateStr != null and releaseDateStr != &#x27;&#x27;&quot;&gt; and date_format(releaseDate, &#x27;%Y年%m月&#x27;) = #&#123;releaseDateStr&#125; &lt;/if&gt; &lt;/where&gt; &lt;if test=&quot;sortByReleaseDate == null&quot;&gt; order by releaseDate desc &lt;/if&gt; &lt;if test=&quot;start != null and size != null&quot;&gt; limit #&#123;start&#125;,#&#123;size&#125; &lt;/if&gt; &lt;/select&gt; &lt;select id=&quot;getCount&quot; parameterType=&quot;map&quot; resultType=&quot;java.lang.Long&quot;&gt; select count(*) from t_blog &lt;where&gt; &lt;if test=&quot;title != null and title != &#x27;&#x27;&quot;&gt; and title like #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;blogTypeId != null&quot;&gt; and blogTypeId = #&#123;blogTypeId&#125; &lt;/if&gt; &lt;if test=&quot;isMenuBlog != null&quot;&gt; and isMenuBlog = #&#123;isMenuBlog&#125; &lt;/if&gt; &lt;if test=&quot;isMenuBlogKey != null&quot;&gt; and isMenuBlog != 1 &lt;/if&gt; &lt;if test=&quot;releaseDateStr != null and releaseDateStr != &#x27;&#x27;&quot;&gt; and date_format(releaseDate, &#x27;%Y年%m月&#x27;) = #&#123;releaseDateStr&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Blog&quot;&gt; insert into t_blog (title, summary, content, releaseDate, click, blogTypeId,isMenuBlog) values (#&#123;title&#125;, #&#123;summary&#125;, #&#123;content&#125;, now(), 0, #&#123;blogTypeId&#125;,0); &lt;/insert&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Blog&quot;&gt; update t_blog &lt;set&gt; &lt;if test=&quot;title != null and title != &#x27;&#x27;&quot;&gt; title=#&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;summary != null and summary != &#x27;&#x27;&quot;&gt; summary=#&#123;summary&#125;, &lt;/if&gt; &lt;if test=&quot;content != null and content != &#x27;&#x27;&quot;&gt; content=#&#123;content&#125;, &lt;/if&gt; &lt;if test=&quot;click != null&quot;&gt; click=#&#123;click&#125;, &lt;/if&gt; &lt;if test=&quot;blogTypeId != null&quot;&gt; blogTypeId=#&#123;blogTypeId&#125;, &lt;/if&gt; &lt;if test=&quot;isMenuBlog != null&quot;&gt; isMenuBlog = #&#123;isMenuBlog&#125;, &lt;/if&gt; &lt;if test=&quot;setMenuBlogDate != null&quot;&gt; setMenuBlogDate=now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;integer&quot;&gt; delete from t_blog where id = #&#123;id&#125; &lt;/delete&gt; &lt;select id=&quot;findById&quot; parameterType=&quot;integer&quot; resultMap=&quot;BlogResult&quot;&gt; select * from t_blog where id = #&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;countList&quot; resultMap=&quot;BlogResult&quot;&gt; select date_format(releaseDate, &#x27;%Y年%m月&#x27;) as releaseDateStr, count(*) as blogCount from t_blog where isMenuBlog=0 group by date_format(releaseDate, &#x27;%Y年%m月&#x27;) order by date_format(releaseDate, &#x27;%Y年%m月&#x27;) desc &lt;/select&gt; &lt;select id=&quot;findByBlogTypeId&quot; parameterType=&quot;integer&quot; resultMap=&quot;BlogResult&quot;&gt; select * from t_blog where blogTypeId = #&#123;blogTypeId&#125; order by releaseDate desc &lt;/select&gt; &lt;select id=&quot;getPreviousBlog&quot; parameterType=&quot;integer&quot; resultType=&quot;com.ledao.entity.Blog&quot;&gt; SELECT * FROM t_blog WHERE id &amp;lt; #&#123;id&#125; ORDER BY id DESC LIMIT 1; &lt;/select&gt; &lt;select id=&quot;getNextBlog&quot; parameterType=&quot;integer&quot; resultType=&quot;com.ledao.entity.Blog&quot;&gt; SELECT * FROM t_blog WHERE id &amp;gt; #&#123;id&#125; ORDER BY id asc LIMIT 1; &lt;/select&gt; &lt;select id=&quot;getMenuBlogList&quot; resultMap=&quot;BlogResult&quot;&gt; select * from t_blog where isMenuBlog = 1 order by setMenuBlogDate asc &lt;/select&gt;&lt;/mapper&gt; BlogService接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.ledao.service; import com.ledao.entity.Blog; import java.util.List;import java.util.Map; /** * 博客Service接口 * * @author LeDao * @company * @create 2020-09-11 00:33 */public interface BlogService &#123; /** * 分页分条件查询博客 * * @param map * @return */ List&lt;Blog&gt; list(Map map); /** * 获取记录数 * * @param map * @return */ Long getCount(Map map); /** * 添加博客 * * @param blog * @return */ Integer add(Blog blog); /** * 修改博客 * * @param blog * @return */ Integer update(Blog blog); /** * 根据id删除博客 * * @param id * @return */ Integer delete(Integer id); /** * 根据id查找博客 * * @param id * @return */ Blog findById(Integer id); /** * 根据日期分月分组查询 * * @return */ List&lt;Blog&gt; countList(); /** * 根据博客类型查询博客 * * @param blogTypeId * @return */ List&lt;Blog&gt; findByBlogTypeId(Integer blogTypeId); /** * 获取上一篇博客 * * @param id * @return */ Blog getPreviousBlog(Integer id); /** * 获取下一篇博客 * * @param id * @return */ Blog getNextBlog(Integer id); /** * 获取导航条文章（根据设置时间升序排列） * * @return */ List&lt;Blog&gt; getMenuBlogList();&#125; BlogService接口的实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.ledao.service.impl; import com.ledao.entity.Blog;import com.ledao.mapper.BlogMapper;import com.ledao.service.BlogService;import org.springframework.stereotype.Service; import javax.annotation.Resource;import java.util.List;import java.util.Map; /** * 博客Service接口实现类 * * @author LeDao * @company * @create 2020-09-11 00:34 */@Service(&quot;blogService&quot;)public class BlogServiceImpl implements BlogService &#123; @Resource private BlogMapper blogMapper; @Override public List&lt;Blog&gt; list(Map map) &#123; return blogMapper.list(map); &#125; @Override public Long getCount(Map map) &#123; return blogMapper.getCount(map); &#125; @Override public Integer add(Blog blog) &#123; return blogMapper.add(blog); &#125; @Override public Integer update(Blog blog) &#123; return blogMapper.update(blog); &#125; @Override public Integer delete(Integer id) &#123; return blogMapper.delete(id); &#125; @Override public Blog findById(Integer id) &#123; return blogMapper.findById(id); &#125; @Override public List&lt;Blog&gt; countList() &#123; return blogMapper.countList(); &#125; @Override public List&lt;Blog&gt; findByBlogTypeId(Integer blogTypeId) &#123; return blogMapper.findByBlogTypeId(blogTypeId); &#125; @Override public Blog getPreviousBlog(Integer id) &#123; return blogMapper.getPreviousBlog(id); &#125; @Override public Blog getNextBlog(Integer id) &#123; return blogMapper.getNextBlog(id); &#125; @Override public List&lt;Blog&gt; getMenuBlogList() &#123; return blogMapper.getMenuBlogList(); &#125;&#125;","categories":[{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"}]},{"title":"Java格式化时间","slug":"119","date":"2021-05-16T21:01:33.000Z","updated":"2022-04-14T11:21:10.897Z","comments":true,"path":"119.html","link":"","permalink":"https://blog.zoutl.cn/119.html","excerpt":"","text":"概述Java格式化时间使用的类是SimpleDateFormat 方法格式有yyyy-MM-dd HH:mm:ss，yyyy年MM月dd日 HH时mm分ss秒等 12SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);simpleDateFormat.format(要格式化的时间) Java代码123456789public static void main(String[] args) &#123; Date date = new Date(); System.out.println(&quot;格式化前：&quot;+date); System.out.println(&quot;格式化后：&quot;); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); System.out.println(simpleDateFormat.format(date)); SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;); System.out.println(simpleDateFormat2.format(date));&#125; 结果截图","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"EasyUI自定义图标","slug":"118","date":"2021-04-26T16:08:31.000Z","updated":"2022-04-14T01:40:47.720Z","comments":true,"path":"118.html","link":"","permalink":"https://blog.zoutl.cn/118.html","excerpt":"","text":"下载图标百度网盘链接：https://pan.baidu.com/s/1Y0678vgcZbkHOTcdRr0hyQ 提取码：cv65 复制到项目中在EasyUI文件夹的themes文件夹中放入下载好的图片（文件名后缀改为.gif） 引用在EasyUI文件夹的themes文件夹的icon.css中添加图标代码 123.icon-setMenuBlog&#123; background:url(&#x27;usericons/setMenuBlog.gif&#x27;) no-repeat center center;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"EasyUI","slug":"EasyUI","permalink":"https://blog.zoutl.cn/tags/EasyUI/"}]},{"title":"commons-io常用方法","slug":"117","date":"2021-04-24T10:44:24.000Z","updated":"2022-04-14T02:11:05.480Z","comments":true,"path":"117.html","link":"","permalink":"https://blog.zoutl.cn/117.html","excerpt":"","text":"引入依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 常用方法writeStringToFile写入字符串到指定文件，直接覆盖掉 1234567891011121314151617import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;E://backup//a.txt&quot;); FileUtils.writeStringToFile(file,&quot;222&quot;,&quot;UTF-8&quot;); &#125;&#125; readFileToString指定编码表读取内容 123456789101112131415161718import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;E://backup//a.txt&quot;); String str=FileUtils.readFileToString(file,&quot;UTF-8&quot;); System.out.println(str); &#125;&#125; copyFile复制一个文件的内容到另一个文件，如果目标文件不存在那么会新建它 123456789101112131415161718import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File(&quot;E://backup//a.txt&quot;); File file2 = new File(&quot;E://backup//a2.txt&quot;); FileUtils.copyFile(file, file2); &#125;&#125; copyDirectory复制一个文件夹的内容到另一个文件夹，如果目标文件夹不存在那么会新建它 123456789101112131415161718import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File srcDir=new File(&quot;E://backup//1&quot;); File destDir=new File(&quot;E://backup//2&quot;); FileUtils.copyDirectory(srcDir, destDir); &#125;&#125; copyDirectoryToDirectory复制一个文件夹及其内容到另一个文件夹，如果目标文件夹不存在那么会新建它（注意：本方法和上一个方法存在差异） 123456789101112131415161718import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File srcDir=new File(&quot;E://backup//1&quot;); File destDir=new File(&quot;E://backup//2&quot;); FileUtils.copyDirectoryToDirectory(srcDir, destDir); &#125;&#125; forceDelete删除文件 1234567891011121314151617import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file=new File(&quot;E://backup//a.txt&quot;); FileUtils.forceDelete(file); &#125;&#125; deleteDirectory删除文件夹，文件夹不为空也可以删除 1234567891011121314151617import org.apache.commons.io.FileUtils;import java.io.File;import java.io.IOException;/** * @author LeDao * @company * @create 2021-06-21 12:38 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file=new File(&quot;E://backup//1&quot;); FileUtils.deleteDirectory(file); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"定时自动备份MySQL数据库","slug":"116","date":"2021-04-23T18:07:56.000Z","updated":"2022-04-14T02:35:01.366Z","comments":true,"path":"116.html","link":"","permalink":"https://blog.zoutl.cn/116.html","excerpt":"","text":"方法一、使用任务计划程序 Windows脚本代码备份MySQL数据库 Windows10使用任务计划程序 方法二、使用Quartz定时任务 Spring Boot引入Quartz定时任务 常用cron表达式 Java备份MySQL数据库","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"Windows10使用任务计划程序","slug":"115","date":"2021-04-23T17:34:51.000Z","updated":"2022-04-14T02:02:27.488Z","comments":true,"path":"115.html","link":"","permalink":"https://blog.zoutl.cn/115.html","excerpt":"","text":"打开任务计划程序打开控制面板，搜索管理工具–&gt;任务计划程序 创建基本任务 点击右侧的创建基本任务 输入名称和描述 选择触发时间 选择操作（选择启动程序） 选择自己的程序或脚本 查看","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"Java备份MySQL数据库","slug":"114","date":"2021-04-23T16:32:30.000Z","updated":"2022-04-14T02:10:59.914Z","comments":true,"path":"114.html","link":"","permalink":"https://blog.zoutl.cn/114.html","excerpt":"","text":"Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * @author LeDao * @company * @create 2021-04-23 21:39 */public class Backup &#123; /** * 数据库用户名 */ private String user_name; /** * 数据库密码 */ private String user_psw; /** * 需要备份的数据库名 */ private String db_name; /** * 主机IP */ private String host_ip; /** * 字符集 */ private String user_charset; /** * 存放备份文件的路径 */ private String backup_path; /** * 命令 */ private String stmt; public Backup(String user_name, String user_psw, String db_name, String host_ip, String user_charset, String backup_path) &#123; this.user_name = user_name; this.user_psw = user_psw; this.db_name = db_name; // 主机IP; if (host_ip == null || host_ip.equals(&quot;&quot;)) &#123; // 默认为本机 this.host_ip = &quot;localhost&quot;; &#125; else &#123; this.host_ip = host_ip; &#125; // 字符集 if (user_charset == null || user_charset.equals(&quot;&quot;)) &#123; // 默认为安装时设置的字符集 this.user_charset = &quot; &quot;; &#125; else &#123; this.user_charset = &quot; --default-character-set=&quot; + user_charset; &#125; this.backup_path = backup_path; this.stmt = &quot;C:\\\\Program Files\\\\MySQL\\\\MySQL Server 5.6\\\\bin\\\\mysqldump &quot; + this.db_name + &quot; -h &quot; + this.host_ip + &quot; -u&quot; + this.user_name + &quot; -p&quot; + this.user_psw + this.user_charset + &quot; --result-file=&quot; + this.backup_path; &#125; public boolean backup_run() &#123; boolean run_result = false; try &#123; Runtime.getRuntime().exec(this.stmt); run_result = true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return run_result; &#125; public static void main(String[] args) &#123; Backup backup = new Backup(&quot;root&quot;, &quot;123456&quot;, &quot;db_myblog&quot;, null, &quot;utf8&quot;, &quot;D:\\\\db_backup\\\\db_myblog.sql&quot;); boolean result = backup.backup_run(); if (result) &#123; System.out.println(&quot;备份成功&quot;); &#125; &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"Windows10脚本代码备份MySQL数据库","slug":"113","date":"2021-04-23T16:20:03.000Z","updated":"2022-04-14T02:02:31.597Z","comments":true,"path":"113.html","link":"","permalink":"https://blog.zoutl.cn/113.html","excerpt":"","text":"创建backdb.bat文件打开该文件，输入以下内容并保存 D盘创建名为db_backup文件夹，-u后的root是数据库连接时用户名，-p后的123456是密码，db_myblog是我的数据库名称 123456789101112131415161718192021222324252627echo 取日期、时间变量值set yy=%date:~0,4% set mm=%date:~5,2% set dd=%date:~8,2% if /i %time:~0,2% lss 10 set hh=0%time:~1,1% if /i %time:~0,2% geq 10 set hh=%time:~0,2% set mn=%time:~3,2% set ss=%time:~6,2% set date=%yy%%mm%%dd% set time=%hh%%mn%%ss% set filename=%date%_%time% &quot;C:/Program Files/MySQL/MySQL Server 5.6/bin/mysqldump.exe&quot; -uroot -p123456 --opt --default-character-set=utf8 -e --triggers -R --hex-blob --flush-logs -x --databases db_myblog &gt; D:/db_backup/db_myblog%filename%.sql echo 导出已经完成 #pause 查看结果","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"mysqldump命令备份数据库","slug":"112","date":"2021-04-23T16:06:12.000Z","updated":"2022-04-14T02:35:04.596Z","comments":true,"path":"112.html","link":"","permalink":"https://blog.zoutl.cn/112.html","excerpt":"","text":"命令1mysqldump -uroot -p123456 db_myblog&gt; D:/db_backup/db_myblog.sql -u后面接的是数据库用户名，-p后面接的是密码，然后是空格接上数据库名称（db_myblog是我的数据库名称），后面则是存储的位置以及存储后的文件名 操作步骤 在MySQL安装目录下bin文件夹中，打开CMD窗口 输入上述命令，然后查看对应位置是否生成该SQL文件 结果","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"SQLyog备份和导入MySQL数据库","slug":"111","date":"2021-04-23T15:52:02.000Z","updated":"2022-04-14T02:35:07.178Z","comments":true,"path":"111.html","link":"","permalink":"https://blog.zoutl.cn/111.html","excerpt":"","text":"备份 右键点击要备份的数据库，选中（备份数据库，转储到SQL） 第二条红线处选择存储的位置，然后点击导出即可 恢复 右键点击要恢复的数据库，选中（执行SQL脚本） 选择对应的SQL文件，点击执行即可","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"部落冲突攻略","slug":"110","date":"2021-03-26T17:09:34.000Z","updated":"2022-04-10T14:42:03.085Z","comments":true,"path":"110.html","link":"","permalink":"https://blog.zoutl.cn/110.html","excerpt":"","text":"指导网站https://www.cocservice.top/ 配兵超级女巫 8848流 视频教程链接：https://www.youtube.com/watch?v=GNKpNH5Img4 超级女巫+女巫 视频教程链接：https://www.youtube.com/watch?v=wzVR0pPbbYU 冰冻龙流攻城机器用滚木车 视频教程链接：https://www.youtube.com/watch?v=2_oV7ws49t4 天女超法皮卡流 视频教程链接：https://www.bilibili.com/video/BV1My4y1b7kK 常用数据城墙等级和炸弹人数量 传奇联赛胜利奖杯 部落冲突联赛奖励图","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"部落冲突","slug":"部落冲突","permalink":"https://blog.zoutl.cn/tags/%E9%83%A8%E8%90%BD%E5%86%B2%E7%AA%81/"}]},{"title":"Spring Boot引入Quartz定时任务","slug":"109","date":"2021-03-16T12:56:45.000Z","updated":"2022-04-14T02:10:52.079Z","comments":true,"path":"109.html","link":"","permalink":"https://blog.zoutl.cn/109.html","excerpt":"","text":"引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt;&lt;/dependency&gt; Java代码12345678910111213141516171819202122232425262728package com.ledao.quartz; import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.EnableScheduling;import org.springframework.scheduling.annotation.Scheduled; import javax.annotation.Resource;import java.util.*; /** * 每天23点自动删除已被删除文章中的图片 * * @author LeDao * @company * @create 2020-09-23 11:27 */@Configuration@EnableSchedulingpublic class DeleteInvalidImage &#123; @Resource private BlogService blogService; @Scheduled(cron = &quot;0 0 23 * * ?&quot;) public void work() &#123; //这里填入定时执行的代码 &#125;&#125; PS.常用cron表达式：常用cron表达式","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"}]},{"title":"鼠标移入div显示查看更多","slug":"108","date":"2021-03-14T19:19:44.000Z","updated":"2022-03-27T16:29:04.989Z","comments":true,"path":"108.html","link":"","permalink":"https://blog.zoutl.cn/108.html","excerpt":"","text":"HTML代码1234567891011&lt;div class=&#x27;box&#x27;&gt;&lt;div class=&#x27;image&#x27;&gt; &lt;img src=&#x27;https://photo.tuchong.com/316540/f/6406791.jpg&#x27; width=&#x27;100%&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;mask&#x27;&gt; &lt;a class=&#x27;link&#x27; href=&#x27;https://blog.csdn.net/Hreticent/article/details/85109668&#x27;&gt; 查看更多 &lt;/a&gt;&lt;/div&gt;&lt;/div&gt; CSS代码12345678910111213141516171819202122232425262728293031323334.mask &#123; background-color:rgb(255, 0, 116); width: 300px; height: 200px; position: absolute; top: 0; z-index: 99; display: none&#125; .image &#123; width: 300px; height: 200px;&#125; .box &#123; position: relative; width: 300px;&#125; .box:hover .mask &#123; display: block;&#125; .box:hover .link &#123; width: 120px; height: 40px; display: block; background: #FFF; line-height: 40px; text-align: center; margin: 80px auto; color: #ff00a5&#125; PS.来源：鼠标移入div显示查看更多demo_Hey-CSDN博客","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"给网页添加背景图片（网页缩小放大都不受影响）","slug":"107","date":"2021-03-14T19:15:14.000Z","updated":"2022-03-27T16:31:03.169Z","comments":true,"path":"107.html","link":"","permalink":"https://blog.zoutl.cn/107.html","excerpt":"","text":"HTML代码1&lt;div class=&quot;bjimg&quot;&gt;&lt;/div&gt; CSS代码1234567891011121314151617.bjimg &#123; position: fixed; top: 0; left: 0; width: 100%; height: 100%; min-width: 1000px; z-index: -10; zoom: 1; background-color: #fff; background-image: url(../static/images/background.png); background-repeat: no-repeat; background-size: cover; -webkit-background-size: cover; -o-background-size: cover; background-position: center 0;&#125; PS.来源：给网页添加背景图片 html+css_北极光之夜。-CSDN博客","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"解决：Tomcat运行项目时Quartz定时任务执行两次","slug":"106","date":"2021-03-14T17:51:21.000Z","updated":"2022-04-14T02:40:52.712Z","comments":true,"path":"106.html","link":"","permalink":"https://blog.zoutl.cn/106.html","excerpt":"","text":"原因在Tomcat的配置文件conf/server.xml中： 1234&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;/test&quot; /&gt;&lt;/Host&gt; 其中&lt;Host&gt;告诉Tomcat，在启动的时候加载webapps下的所有项目工程文件，&lt;Context&gt;又让Tomcat再加载了一遍（一般情况下配置&lt;Context&gt;，主要是由于想域名访问时将工程名去掉的原因配置），这种情况下会导致工程中的quartz定时被两次触发，执行两次 解决办法将Tomcat的配置文件conf/server.xml修改为： 1234&lt;Host name=&quot;localhost&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;false&quot; deployOnStartup=&quot;false&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;/test&quot;/&gt;&lt;/Host&gt; autoDeploy：是否允许自动部署，默认值是true，即表示 Tomcat 会自动检测appBase目录下面的文件变化从而自动应用到正在运行的 Web 应用程序deployOnStartup=”false”，表示Tomcat服务器启动时, 不会自动发布appBase目录下所有的Web应用 会出现的问题但是这样虽然解决了Quartz的执行两次的问题，但也存在另一个问题——无法解压war包。就是war包放到webapps目录下，不会自动解压生成项目文件夹，你所看到的项目文件夹是历史文件夹。所以，这是一个不断修改conf/server.xml的过程。当需要解压文件夹的时候，修改成true，解压完成后，改成false，记得重启Tomcat PS.来源：【Java Web】Quartz定时任务执行两次的解决方法_Yngz_Miao的博客-CSDN博客","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"}]},{"title":"实现鼠标移入文字向右移动效果","slug":"105","date":"2021-03-14T14:41:04.000Z","updated":"2022-03-27T16:33:02.446Z","comments":true,"path":"105.html","link":"","permalink":"https://blog.zoutl.cn/105.html","excerpt":"","text":"HTML代码1&lt;div id=&#x27;div1&#x27;&gt;&gt;&gt;&gt;鼠标移入此行会缓慢向右路移动&lt;&lt;&lt;&lt;/div&gt; CSS代码123456789#div1 &#123; -webkit-transition: margin-left .8s; -moz-transition: margin-left .8s; -o-transition: margin-left .8s; &#125;#div1:hover &#123; margin-left: 5px;&#125; PS.来源：鼠标移入文字上向右移动效果 - Crazy丶迷恋 - 博客园","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"根据ip地址获取真实地址","slug":"104","date":"2021-03-13T04:11:14.000Z","updated":"2022-04-14T02:10:42.482Z","comments":true,"path":"104.html","link":"","permalink":"https://blog.zoutl.cn/104.html","excerpt":"","text":"pom.xml引入12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.9&lt;/version&gt;&lt;/dependency&gt; Java代码123456789101112131415161718192021222324package com.ledao.util; import cn.hutool.http.HttpUtil; /** * 根据IP获取真实地址 * * @author LeDao * @company * @create 2021-03-13 11:18 */public class AddressUtil &#123; public static String getAddress(String ip) &#123; String result1 = HttpUtil.get(&quot;https://www.ip138.com/iplookup.asp?ip=&quot; + ip + &quot;&amp;action=2&quot;); String result = result1.split(&quot;\\&quot;ASN归属地\\&quot;:\\&quot;&quot;)[1].split(&quot;\\&quot;, \\&quot;iP段\\&quot;:&quot;)[0]; return result; &#125; public static void main(String[] args) &#123; String ip = &quot;180.136.86.160&quot;; System.out.println(getAddress(ip)); &#125;&#125; 结果 原理找到一个查ip的网站，随便查一个ip，然后将地址栏中的链接复制下来，链接中的ip之后在Java代码中可以动态拼接 通过Hutool工具包的HttpUtil.get方法获取查某个ip得到结果后的网站源码 通过Java的String.split方法截取网站源码中的真实地址 PS.另一种方法：java-通过ip获取地址 - 公众号/架构师与哈苏 - 博客园","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"制作网站logo","slug":"103","date":"2021-03-12T14:39:30.000Z","updated":"2022-03-27T16:35:25.614Z","comments":true,"path":"103.html","link":"","permalink":"https://blog.zoutl.cn/103.html","excerpt":"","text":"网站地址http://www.uugai.com/ 输入logo的名称进入网站后，输入logo的名称，然后点击开始设计 设计文案下方的拼音（我称之为副标题）不删除的话最近的logo图片会有两行字（副标题可以根据自己的需要输入，如果不需要两行字就把下面的副标题删除即可），然后提交文案 选择字体 选择logo图案 生成logo下载也可在下方选择字体的颜色（小字体即前面说的副标题）","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"MySQL数据库中text字段长度不够","slug":"102","date":"2021-03-12T12:42:40.000Z","updated":"2022-04-14T02:35:10.104Z","comments":true,"path":"102.html","link":"","permalink":"https://blog.zoutl.cn/102.html","excerpt":"","text":"问题描述text类型是可变长度的字符串，最多65535个字符，有时候会超过其长度 解决办法可以把字段类型改成MEDIUMTEXT（最多存放16777215个字符）或者LONGTEXT（最多存放4294967295个字符）","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"解决：关于CKEditor的代码高亮","slug":"101","date":"2021-03-12T11:45:29.000Z","updated":"2022-04-14T01:39:35.002Z","comments":true,"path":"101.html","link":"","permalink":"https://blog.zoutl.cn/101.html","excerpt":"","text":"获取HTML代码 去代码在线高亮网站获得高亮后的HTML代码：（网站如下图所示） 地址：https://c.runoob.com/front-end/5536 ①处填入要高亮的原始代码，②处是高亮后的HTML代码（是我们需要的），③处是高亮后的代码的效果预览 复制到CKEditor 点击CKEditor富文本编辑器左上角的源码选项，进入编辑源码状态，在对应的位置将刚刚得到的HTML代码复制进去即可 PS. 利用highlight.js实现代码高亮：highlight.js实现代码高亮","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CKEditor","slug":"CKEditor","permalink":"https://blog.zoutl.cn/tags/CKEditor/"}]},{"title":"一个非常好用的Java工具包：HulTool","slug":"100","date":"2021-03-11T20:15:27.000Z","updated":"2022-04-14T02:10:37.656Z","comments":true,"path":"100.html","link":"","permalink":"https://blog.zoutl.cn/100.html","excerpt":"","text":"官方网站https://www.hutool.cn/ 介绍Hutool是一个Java工具包类库，对文件、流、加密解密、转码、正则、线程、XML等JDK方法进行封装，组成各种Util工具类 主要功能日期工具：通过DateUtil类，提供高度便捷的日期访问、处理和转换方式 HTTP客户端：通过HttpUtil对HTTP客户端的封装，实现便捷的HTTP请求，并简化文件上传操作 转换工具：通过Convert类中的相应静态方法，提供一整套的类型转换解决方案，并通过ConverterRegistry工厂类自定义转换 配置文件工具：通过Setting对象，提供兼容Properties文件的更加强大的配置文件工具，用于解决中文、分组等JDK配置文件存在的诸多问题 日志工具：Hutool的日志功能，通过抽象Log接口，提供对Slf4j、LogBack、Log4j、JDK-Logging的全面兼容支持 JDBC工具类：通过db模块，提供对MySQL、Oracle等关系型数据库的JDBC封装，借助ActiveRecord思想，大大简化数据库操作 更多功能：官方参考文档 使用引入依赖后就可以直接使用了 12345&lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.5.9&lt;/version&gt;&lt;/dependency&gt;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"解决：关于百度文库等网站无法复制","slug":"99","date":"2021-03-11T20:01:56.000Z","updated":"2022-04-10T05:03:45.003Z","comments":true,"path":"99.html","link":"","permalink":"https://blog.zoutl.cn/99.html","excerpt":"","text":"安装插件以最新版Edge浏览器浏览器为例，安装SuperCopy扩展，微软中国官方扩展商店地址如下： https://microsoftedge.microsoft.com/addons/Microsoft-Edge-Extensions-Home 使用插件搜索并安装该扩展，安装完成后打开百度文库的文档，然后点击浏览器菜单栏的该扩展图标，在出现的框框中点击中间的图片使之编成蓝色，再刷新该网站即可复制文档的内容","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"实现文字闪烁效果","slug":"98","date":"2021-03-11T18:42:33.000Z","updated":"2022-03-27T16:41:12.493Z","comments":true,"path":"98.html","link":"","permalink":"https://blog.zoutl.cn/98.html","excerpt":"","text":"HTML代码1&lt;div class=&quot;box&quot;&gt;闪烁效果&lt;/div&gt; CSS代码12345678910111213141516171819202122232425262728293031323334/*文字闪烁*/.box1&#123; color:red; animation: changeshadow 6s ease-in infinite ; -webkit-animation: changeshadow 6s linear infinite; -moz-animation: changeshadow 6s linear infinite; -ms-animation: changeshadow 6s linear infinite; -o-animation: changeshadow 6s linear infinite;&#125;@keyframes changeshadow &#123; 0%&#123; text-shadow: 0 0 4px red&#125; 50%&#123; text-shadow: 0 0 40px red&#125; 100%&#123; text-shadow: 0 0 4px red&#125;&#125;@-webkit-keyframes changeshadow &#123; 0%&#123; text-shadow: 0 0 4px red&#125; 50%&#123; text-shadow: 0 0 40px red&#125; 100%&#123; text-shadow: 0 0 4px red&#125;&#125;@-moz-keyframes changeshadow &#123; 0%&#123; text-shadow: 0 0 4px red&#125; 50%&#123; text-shadow: 0 0 40px red&#125; 100%&#123; text-shadow: 0 0 4px red&#125;&#125;@-ms-keyframes changeshadow &#123; 0%&#123; text-shadow: 0 0 4px red&#125; 50%&#123; text-shadow: 0 0 40px red&#125; 100%&#123; text-shadow: 0 0 4px red&#125;&#125;@-o-keyframes changeshadow &#123; 0%&#123; text-shadow: 0 0 4px red&#125; 50%&#123; text-shadow: 0 0 40px red&#125; 100%&#123; text-shadow: 0 0 4px red&#125;&#125; PS.来源：一些有趣的 html/css 特效","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"给网站添加雪花特效","slug":"97","date":"2021-03-11T17:38:36.000Z","updated":"2022-04-05T15:42:09.138Z","comments":true,"path":"97.html","link":"","permalink":"https://blog.zoutl.cn/97.html","excerpt":"","text":"HTML代码放在&lt;body&gt;标签前 1&lt;div id=&quot;snowMask&quot;&gt;&lt;/div&gt; CSS代码1234567891011121314151617181920212223242526272829303132333435/*网站雪花特效*/@-webkit-keyframes snow &#123; 0% &#123; background-position: 0 0, 0 0 &#125; 100% &#123; background-position: 500px 500px, 1000px 500px &#125;&#125; @keyframes snow &#123; 0% &#123; background-position: 0 0, 0 0 &#125; 100% &#123; background-position: 500px 500px, 1000px 500px &#125;&#125; .container &#123; box-shadow: 0 0 4px 3px rgba(0, 0, 0, .05);&#125; #snowMask &#123; position: fixed; left: 0; top: 0; width: 100%; height: 100%; background: url(/static/images/snow1.png), url(/static/images/snow2.png); -webkit-animation: 10s snow linear infinite; animation: 10s snow linear infinite; pointer-events: none; z-index: 9999;&#125; 雪花图片网盘链接百度网盘链接：https://pan.baidu.com/s/1A3LP21J-Xf-D_Ol2DQrhbw 提取码：9e1g PS.来源：纯CSS添加雪花网站动态背景特效兼容性好！-西德SEO","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"给网站添加鼠标点击弹出指定汉字特效","slug":"96","date":"2021-03-11T16:25:18.000Z","updated":"2022-03-27T16:43:04.623Z","comments":true,"path":"96.html","link":"","permalink":"https://blog.zoutl.cn/96.html","excerpt":"","text":"JavaScript代码12345678910111213141516171819202122232425262728/* 鼠标特效 */var a_idx = 0;jQuery(document).ready(function ($) &#123; $(&quot;body&quot;).click(function (e) &#123; var a = new Array(&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;); var $i = $(&quot;&quot;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css(&#123; &quot;z-index&quot;: 999999999999999999999999999999999999999999999999999999999999999999999, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#ff6651&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 &#125;, 1500, function () &#123; $i.remove(); &#125;); &#125;);&#125;); 效果 PS.来源：给网站添加鼠标点击弹出指定汉字特效_无耳貂的博客-CSDN博客","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"实现鼠标移动到div块时自动加阴影效果","slug":"95","date":"2021-03-11T14:35:31.000Z","updated":"2022-03-27T16:44:33.873Z","comments":true,"path":"95.html","link":"","permalink":"https://blog.zoutl.cn/95.html","excerpt":"","text":"HTML代码123&lt;div class=&quot;shadow&quot;&gt; //已省略无关代码&lt;/div&gt; CSS代码1234567891011.shadow &#123; float: left; margin-left: 20px; transition-duration: 0.5s; /*停留时间显示*/&#125; .shadow:hover &#123; -webkit-box-shadow: #337ab7 0px 10px 10px; -moz-box-shadow: #337ab7 0px 10px 10px; box-shadow: #337ab7 0px 5px 5px;&#125; 效果 PS.来源：css怎么实现鼠标移动到div块时自动加阴影效果？_tenggeer0789的博客-CSDN博客","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"遍历HashMap的四种方法","slug":"94","date":"2021-02-22T13:41:58.000Z","updated":"2022-04-14T02:10:30.788Z","comments":true,"path":"94.html","link":"","permalink":"https://blog.zoutl.cn/94.html","excerpt":"","text":"创建HashMap集合1234HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;&gt;(16);hashMap.put(1, &quot;a&quot;);hashMap.put(2, &quot;b&quot;);hashMap.put(3, &quot;c&quot;); 遍历keySet()使用keySet()方法，先遍历键，再取出值 123for (Integer key : hashMap.keySet()) &#123; System.out.println(&quot;key=&quot; + key + &quot;,value=&quot; + hashMap.get(key));&#125; values()使用values()方法，直接遍历值 123for (String value : hashMap.values()) &#123; System.out.println(value);&#125; entrySet()使用entrySet()方法，然后通过getKey()和getValue()分别取键和值 123for (Map.Entry entry : hashMap.entrySet()) &#123; System.out.println(&quot;key=&quot; + entry.getKey() + &quot;,value=&quot; + entry.getValue());&#125; ForEach()通过ForEach()方法直接遍历 1hashMap.forEach((key, value) -&gt; System.out.println(key + &quot;,&quot; + value));","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"实现鼠标移到图片改变，移出图片恢复原来图片","slug":"93","date":"2021-02-18T05:08:17.000Z","updated":"2022-04-10T05:03:55.444Z","comments":true,"path":"93.html","link":"","permalink":"https://blog.zoutl.cn/93.html","excerpt":"","text":"HTML代码1234&lt;a class=&quot;imgdiv&quot; href=&quot;#gotop&quot; title=&quot;返回顶部&quot;&gt; &lt;img th:src=&quot;@&#123;/static/images/top2.png&#125;&quot; id=&quot;gotop&quot; alt=&quot;&quot; class=&quot;imgsrc&quot; style=&quot;position: fixed;bottom: 10%;display: none;height: 40px;margin-left: 96%&quot;&gt;&lt;/a&gt; JavaScript代码12345678$(document).ready(function () &#123; $(&quot;.imgdiv&quot;).mouseover(function()&#123; $(&quot;.imgsrc&quot;).attr(&quot;src&quot;,&quot;/static/images/top4.png&quot;); &#125;); $(&quot;.imgdiv&quot;).mouseout(function()&#123; $(&quot;.imgsrc&quot;).attr(&quot;src&quot;,&quot;/static/images/top2.png&quot;); &#125;);&#125;); PS.来源：JQuery鼠标移到图片改变，移出图片恢复原来图片_u014599700的专栏-CSDN博客","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"IntelliJ IDEA版本更新","slug":"92","date":"2021-02-13T00:33:57.000Z","updated":"2022-04-14T02:46:43.619Z","comments":true,"path":"92.html","link":"","permalink":"https://blog.zoutl.cn/92.html","excerpt":"","text":"下载JetBrains: 软件开发人员和团队的必备工具 卸载 //返回顶部图标出现或者消失$(function () { $(function () { $(window).scroll(function () { if ($(window).scrollTop() &gt; 100) { $(“#gotop”).fadeIn(1000);//一秒渐入动画 } else { $(“#gotop”).fadeOut(1000);//一秒渐隐动画 } }); $(“#gotop”).click(function () { $(‘body,html’).animate({scrollTop: 0}, 1000); }); });});javascript 找到idea安装目录下的bin文件夹的Uninstall.exe并点击开始卸载 勾选下图中的选项，只勾选划红线的第一个选项，不要勾选第二个（不然新版本安装后无法读取原来配置和插件），然后开始卸载等待完成即可 安装 选择安装路径 配置，然后点击下一步安装即可 导入配置","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"前端实现返回顶部","slug":"91","date":"2021-02-08T04:43:39.000Z","updated":"2022-04-10T14:35:23.236Z","comments":true,"path":"91.html","link":"","permalink":"https://blog.zoutl.cn/91.html","excerpt":"","text":"HTML代码123&lt;a href=&quot;#gotop&quot; title=&quot;返回顶部&quot;&gt; &lt;img th:src=&quot;@&#123;/static/images/top2.png&#125;&quot; id=&quot;gotop&quot; alt=&quot;&quot; style=&quot;position: fixed;bottom: 10%;display: none;height: 40px;margin-left: 96%&quot;&gt;&lt;/a&gt; JavaScript代码12345678910111213141516//返回顶部图标出现或者消失$(function () &#123; $(function () &#123; $(window).scroll(function () &#123; if ($(window).scrollTop() &gt; 100) &#123; $(&quot;#gotop&quot;).fadeIn(1000);//一秒渐入动画 &#125; else &#123; $(&quot;#gotop&quot;).fadeOut(1000);//一秒渐隐动画 &#125; &#125;); $(&quot;#gotop&quot;).click(function () &#123; $(&#x27;body,html&#x27;).animate(&#123;scrollTop: 0&#125;, 1000); &#125;); &#125;);&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Thymeleaf常用属性总结","slug":"90","date":"2021-02-07T03:11:38.000Z","updated":"2022-04-14T01:48:20.269Z","comments":true,"path":"90.html","link":"","permalink":"https://blog.zoutl.cn/90.html","excerpt":"","text":"th:text用于显示转义后的文本（不尊重我们的HTML标记而对其进行转义） 1th:text=&quot;$&#123;blog.title&#125;&quot; 截取字符串1th:text=&quot;$&#123;#strings.abbreviate(blog.title,18)&#125;&quot; 格式化时间1th:text=&quot;$&#123;#dates.format(blog.releaseDate,&#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot; th:utext用于显示未转义的文本（尊重我们的HTML标记而不对其进行转义） 1th:utext=&quot;$&#123;blog.content&#125;&quot; th:if条件判断，条件成立则在页面中显示，不成立则不显示 1th:if=&quot;$&#123;blog!=null&#125;&quot; th:each循环语句，如果要显示一个List集合的所有内容则使用循环遍历，下面代码中blogList代表要循环遍历的集合，blog则代表集合中的每个元素（或实体） 123&lt;div th:each=&quot;blog:$&#123;blogList&#125;&quot;&gt; &lt;/div&gt; th:hrefa标签的href链接、或者是HTML头文件的link引入地址 12th:href=&quot;@&#123;&#x27;/?page=1&amp;articleTypeId=&#x27;+$&#123;articleType.id&#125;&#125;&quot;&lt;link rel=&quot;stylesheet&quot; th:href=&quot;@&#123;/static/vendor/bootstrap/css/bootstrap.min.css&#125;&quot;&gt; th:srcimg标签的图片链接、或者是HTML头文件的script引入地址 12th:src=&quot;@&#123;&#x27;/static/images/userImage/&#x27;+$&#123;comment.user.imageName&#125;&#125;&quot;&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js&#125;&quot;&gt;&lt;/script&gt; th:title描述了元素的额外信息 (作为工具条使用)，当页面上无法显示全部文本时，可通过title实现鼠标悬停实现查看全部文本信息 1th:title=&quot;$&#123;blog.title&#125;&quot; th:style行内样式，可以结合条件表达式实现动态选择（满足条件表达式则选择第一个结果，不满足则选择第二种结果） 1th:style=&quot;$&#123;articleTypeId == &#x27;&#x27;+articleType.id+&#x27;&#x27;?&#x27;margin-left: 6px;color:red;float: left&#x27;:&#x27;margin-left: 6px;float: left;color:#1e9fff&#x27;&#125;&quot; th:value1th:value=&quot;$&#123;goodsTypeId&#125;&quot; 只需要List的部分元素当一个集合中的元素数量超过我们需要显示的元素数量时，可使用……Stat.count和th:if（省略号处根据具体情况填写） 123&lt;div th:each=&quot;recommendBlog:$&#123;recommendBlogList&#125;&quot; th:if=&quot;$&#123;recommendBlogStat.count&lt;=10&#125;&quot;&gt; &lt;/div&gt; 获取随机数1$&#123;#numbers.formatDecimal(T(java.lang.Math).floor(T(java.lang.Math).random()*3)+1,1,0)&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://blog.zoutl.cn/tags/Thymeleaf/"}]},{"title":"Java从键盘输入的三种方法","slug":"89","date":"2021-02-07T02:33:57.000Z","updated":"2022-04-14T02:10:17.324Z","comments":true,"path":"89.html","link":"","permalink":"https://blog.zoutl.cn/89.html","excerpt":"","text":"System.in的read方法这种方式极其简单，但是只能读入一个字符，且必须是字符类型，输出该字符的ASCII码。（如果输入字符串，则指能读入第一个字符，在下面的截图中可以看到：输入ab时输出了97，那么我们可以判断出只能读入第一个字符，因为a的ASCII码是97） 1234public static void main(String[] args) throws IOException &#123; int i = System.in.read(); System.out.println(i);&#125; InputStreamReader和BufferedReader方法这种方式可以读取一个字符串，但是如果需要读取int，float等类型仍需要自己转换 123456public static void main(String[] args) throws IOException &#123; InputStreamReader is = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(is); String name = br.readLine(); System.out.println(name);&#125; Scanner类这种方式使用java5之后添加的Scanner类，Scanner类提供了读取int，float及字符串的方法，使用十分方便。同时，Scanner不仅可以读取键盘输入值，也可以读取文件内容，只需要将构造方法中的数据来源切换成该文件即可 如果先读取int，float，再读取字符串，要让指针移到下一行开头，不然读取不了字符串，反过来读取就没问题 123456789public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int i = sc.nextInt(); float f = sc.nextFloat(); String s = sc.nextLine(); System.out.println(i); System.out.println(f); System.out.println(s);&#125; PS.来源：java 读取键盘输入_呼延十-CSDN博客_java读取键盘输入","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Spring Boot引入Thymeleaf","slug":"88","date":"2021-02-03T13:43:56.000Z","updated":"2022-04-14T01:48:23.367Z","comments":true,"path":"88.html","link":"","permalink":"https://blog.zoutl.cn/88.html","excerpt":"","text":"引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; application.yml配置123spring: thymeleaf: cache: false HMTL页面修改找到html标签头部&lt;html&gt;，一般在.html文件第二行 修改前1&lt;html lang=&quot;en&quot;&gt; 修改后1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; 为了让HTML代码页面变得美观，可加入&lt;!--suppress ALL--&gt;抑制所有警告（html标签头部&lt;html&gt;前加入即可） 至此，Spring Boot引入Thymeleaf的操作已完成","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://blog.zoutl.cn/tags/Thymeleaf/"}]},{"title":"JavaScript实现点击图片查看原图","slug":"87","date":"2021-02-03T05:48:18.000Z","updated":"2022-03-27T16:52:59.446Z","comments":true,"path":"87.html","link":"","permalink":"https://blog.zoutl.cn/87.html","excerpt":"","text":"代码html代码:1234567&lt;div id=&quot;outerdiv&quot; style=&quot;position:fixed;top:0;left:0;background:rgba(0,0,0,0.7);z-index:2;width:100%;height:100%;display:none;&quot;&gt; &lt;div id=&quot;innerdiv&quot; style=&quot;position:absolute;&quot;&gt; &lt;img id=&quot;bigimg&quot; style=&quot;border:5px solid #fff;&quot; src=&quot;&quot;/&gt; &lt;/div&gt; &lt;h1 style=&quot;color: yellow;text-align: center&quot;&gt;************************点击图片外任何区域即可关闭图片************************&lt;/h1&gt;&lt;/div&gt; JavaScript代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//使所有图片都生效 $(document).ready(function () &#123; $(&quot;img&quot;).addClass(&quot;pimg&quot;);&#125;);//图片放大$(function () &#123; $(&quot;.pimg&quot;).click(function () &#123; var _this = $(this);//将当前的pimg元素作为_this传入函数 imgShow(&quot;#outerdiv&quot;, &quot;#innerdiv&quot;, &quot;#bigimg&quot;, _this); &#125;);&#125;); function imgShow(outerdiv, innerdiv, bigimg, _this) &#123; var src = _this.attr(&quot;src&quot;);//获取当前点击的pimg元素中的src属性 $(bigimg).attr(&quot;src&quot;, src);//设置#bigimg元素的src属性 /*获取当前点击图片的真实大小，并显示弹出层及大图*/ $(&quot;&lt;img/&gt;&quot;).attr(&quot;src&quot;, src).load(function () &#123; var windowW = $(window).width(); //获取当前窗口宽度 var windowH = $(window).height(); //获取当前窗口高度 var realWidth = this.width; //获取图片真实宽度 var realHeight = this.height; //获取图片真实高度 var imgWidth, imgHeight; var scale = 0.8; //缩放尺寸，当图片真实宽度和高度大于窗口宽度和高度时进行缩放 if (realHeight &gt; windowH * scale) &#123; //判断图片高度 imgHeight = windowH * scale; //如大于窗口高度，图片高度进行缩放 imgWidth = imgHeight / realHeight * realWidth; //等比例缩放宽度 if (imgWidth &gt; windowW * scale) &#123; //如宽度扔大于窗口宽度 imgWidth = windowW * scale; //再对宽度进行缩放 &#125; &#125; else if (realWidth &gt; windowW * scale) &#123; //如图片高度合适，判断图片宽度 imgWidth = windowW * scale; //如大于窗口宽度，图片宽度进行缩放 imgHeight = imgWidth / realWidth * realHeight; //等比例缩放高度 &#125; else &#123; //如果图片真实高度和宽度都符合要求，高宽不变 imgWidth = realWidth; imgHeight = realHeight; &#125; $(bigimg).css(&quot;width&quot;, imgWidth); //以最终的宽度对图片缩放 var w = (windowW - imgWidth) / 2; //计算图片与窗口左边距 var h = (windowH - imgHeight) / 2; //计算图片与窗口上边距 $(innerdiv).css(&#123;&quot;top&quot;: h, &quot;left&quot;: w&#125;); //设置#innerdiv的top和left属性 $(outerdiv).fadeIn(&quot;fast&quot;); //淡入显示#outerdiv及.pimg &#125;); $(outerdiv).click(function () &#123; //再次点击淡出消失弹出层 $(this).fadeOut(&quot;fast&quot;); &#125;);&#125; 结果 PS.来源：点击小图查看原图 - 素衣居士 - 博客园","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":":hover实现鼠标悬停效果","slug":"86","date":"2021-01-31T11:57:14.000Z","updated":"2022-04-10T14:33:33.069Z","comments":true,"path":"86.html","link":"","permalink":"https://blog.zoutl.cn/86.html","excerpt":"","text":"概述:hover选择器用于选择鼠标指针浮动在上面的元素 代码HTML代码1&lt;a herf=&quot;#&quot; class=&quot;test&quot;&gt;&lt;/a&gt; css代码123a.test:hover &#123; font-size: 15px;&#125; 效果鼠标悬停在a标签上时会将字体大小设置为15px","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"使用天气插件","slug":"85","date":"2021-01-30T17:39:06.000Z","updated":"2022-03-27T16:56:09.641Z","comments":true,"path":"85.html","link":"","permalink":"https://blog.zoutl.cn/85.html","excerpt":"进入网址天气预报代码_天气预报插件_免费天气预报代码(插件)调用——天气网 选择天气样式代码","text":"进入网址天气预报代码_天气预报插件_免费天气预报代码(插件)调用——天气网 选择天气样式代码 修改代码1&lt;iframe width=&quot;400&quot; height=&quot;100&quot; frameborder=&quot;0&quot; scrolling=&quot;no&quot; hspace=&quot;0&quot; src=&quot;https://i.tianqi.com/?c=code&amp;a=getcode&amp;id=35&amp;py=chongqing&amp;site=34&amp;icon=1&quot;&gt;&lt;/iframe&gt; 如果要获取某一城市的天气，修改py的值即可（py的值为该城市的拼音且全部是小写），如果根据用户地址获取天气则将&amp;py=chongqing删除","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"二元运算符连接两个值","slug":"84","date":"2021-01-29T02:55:09.000Z","updated":"2022-04-14T02:10:09.520Z","comments":true,"path":"84.html","link":"","permalink":"https://blog.zoutl.cn/84.html","excerpt":"","text":"当用一个二元运算符连接两个值时（例如a+b，a是整数，b是浮点数），先要将两个操作数转换成同一种类型，然后再进行计算 如果两个数中有一个是double类型，则另一个会转换成double类型（不满足当前条件则向下判断） 否则，如果两个数中有一个是float类型，则另一个会转换成float类型 否则，如果两个数中有一个是long类型，则另一个会转换成long类型 否则，两个数都被转换成int类型","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"IntelliJ IDEA Debug循环跳到指定次数","slug":"83","date":"2021-01-24T07:15:10.000Z","updated":"2022-04-14T02:46:38.366Z","comments":true,"path":"83.html","link":"","permalink":"https://blog.zoutl.cn/83.html","excerpt":"","text":"打开循环设置 开始前先关闭程序(或终止循环)，右键点击红色圆圈●，然后点击蓝色字体链接More或者按下图中指定快捷键 设置循环次数 勾选Pass count，输入目标循环次数，点击右下角的Done按钮，然后开始该循环即可 测试 如图，循环一开始就到了第15次，即i=14","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"解决：Windows10左下角电池图标不见了","slug":"82","date":"2021-01-22T05:19:07.000Z","updated":"2022-04-14T02:02:42.698Z","comments":true,"path":"82.html","link":"","permalink":"https://blog.zoutl.cn/82.html","excerpt":"","text":"打开计算机管理 打开此电脑，选择管理 找到电池选项 点击左边菜单的设备管理器，然后找到电池 禁用再启用 分别对电池下的两个选项右键点击，然后禁用设备，再启用设备即可","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算某年某月有多少天","slug":"81","date":"2021-01-21T18:30:04.000Z","updated":"2022-04-14T02:10:05.149Z","comments":true,"path":"81.html","link":"","permalink":"https://blog.zoutl.cn/81.html","excerpt":"","text":"概述可快速计算某年是否是闰年，因为可以知道了二月有多少天 Java代码12345678910111213141516public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; String str = sc.nextLine(); int year = Integer.parseInt(str.split(&quot; &quot;)[0]); int mouth = Integer.parseInt(str.split(&quot; &quot;)[1]); Calendar calendar=Calendar.getInstance(); //设置年份 calendar.set(Calendar.YEAR, year); //设置月份 calendar.set(Calendar.MONTH, mouth-1); //获得该年该月份的最大天数 int lastDay=calendar.getActualMaximum(Calendar.DAY_OF_MONTH); System.out.println(lastDay); &#125;&#125; 结果2008 229","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java保留两位小数","slug":"80","date":"2021-01-21T12:46:31.000Z","updated":"2022-04-14T02:10:03.482Z","comments":true,"path":"80.html","link":"","permalink":"https://blog.zoutl.cn/80.html","excerpt":"","text":"String的format方法12float a=12.3333f;System.out.println(String.format(&quot;%.2f&quot;,a)); DecimalFormat的format方法123float a=12.3333f;DecimalFormat decimalFormat = new DecimalFormat(&quot;#.00&quot;);System.out.println(decimalFormat.format(a)); Java代码123456public static void main(String[] args) &#123; float a=12.3333f; System.out.println(String.format(&quot;%.2f&quot;,a)); DecimalFormat decimalFormat = new DecimalFormat(&quot;#.00&quot;); System.out.println(decimalFormat.format(a));&#125; 结果12.3312.33","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"最终结果不用科学计数","slug":"79","date":"2021-01-21T12:20:32.000Z","updated":"2022-04-14T02:10:00.889Z","comments":true,"path":"79.html","link":"","permalink":"https://blog.zoutl.cn/79.html","excerpt":"","text":"Java代码123456public static void main(String[] args) &#123; System.out.println(&quot;科学计数:&quot;); System.out.println(20*3.156*10*10*10*10*10*10*10); System.out.println(&quot;不是科学计数:&quot;); System.out.println(new BigDecimal(20*3.156*10*10*10*10*10*10*10));&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java域宽","slug":"78","date":"2021-01-20T02:41:01.000Z","updated":"2022-04-14T02:09:58.863Z","comments":true,"path":"78.html","link":"","permalink":"https://blog.zoutl.cn/78.html","excerpt":"","text":"简介用于存放输出数据的宽度称为“域宽” Java代码123456789101112public static void main(String[] args) &#123; //数字4代表域宽为4 System.out.printf(&quot;%4d&quot;,1); System.out.println(); System.out.printf(&quot;%4d&quot;,12); System.out.println(); System.out.printf(&quot;%4d&quot;,123); System.out.println(); System.out.printf(&quot;%4d&quot;,1234); System.out.println(); System.out.printf(&quot;%4d&quot;,12345);&#125; 结果 分析确定域宽为4 输出1时，前面有3个空格； 输出12时，前面有2个空格； 输出123时，前面有1个空格； 输出1234时，前面有0个空格； 输出12345时，此时长度超过域宽则直接输出；","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java进制转换","slug":"77","date":"2021-01-20T02:14:53.000Z","updated":"2022-04-14T02:09:56.953Z","comments":true,"path":"77.html","link":"","permalink":"https://blog.zoutl.cn/77.html","excerpt":"","text":"十进制转换成其它进制二进制1Integer.toBinaryString(100) 八进制1Integer.toOctalString(100) 十六进制1Integer.toHexString(100) Java代码12345678public static void main(String[] args) &#123; //十进制转换成二进制 1100100 System.out.println(Integer.toBinaryString(100)); //十进制转换成八进制 144 System.out.println(Integer.toOctalString(100)); //十进制转换成十六进制 64 System.out.println(Integer.toHexString(100));&#125; 结果110010014464 各种进制转换成十进制1Integer.parseInt(&quot;1100100&quot;, 2) 第一个参数为要转换成十进制的数（它是几进制数由第二个参数决定），第二个参数是说明第一个参数是几进制数 Java代码12345678public static void main(String[] args) &#123; //二进制转换成十进制 System.out.println(Integer.parseInt(&quot;1100100&quot;, 2)); //八进制转换成十进制 System.out.println(Integer.parseInt(&quot;144&quot;, 8)); //十六进制转换成十进制 System.out.println(Integer.parseInt(&quot;4096&quot;, 16));&#125; 结果10010016534 十进制转换成任意进制Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main &#123; public static void main(String[] args) &#123; //10进制数转换成15进制数 System.out.println(getResult(getSting(26,15))); //10进制数转换成7进制数 System.out.println(getResult(getSting(26,7))); &#125; /** * 根据除n取余法获得基本的进制数(余数10没有用A表示,11没有用B表示,以此类推...) * * @param num 要转换的十进制数 * @param radix 要转换成多少进制数 * @return */ public static String getSting(int num, int radix) &#123; StringBuffer sb = new StringBuffer(); while (num != 0) &#123; sb.append(num % radix).append(&quot;,&quot;); num = num / radix; &#125; return sb.toString(); &#125; /**获得最终结果(余数10用A表示,11用B表示,以此类推...) * @param str * @return */ public static String getResult(String str) &#123; StringBuffer sb = new StringBuffer(); String[] arr = str.split(&quot;,&quot;); String[] arr2 = new String[arr.length]; int j=0; for (int i = arr.length - 1; i &gt;= 0; i--) &#123; arr2[j] = arr[i]; j++; &#125; for (String s : arr2) &#123; if (Integer.parseInt(s) &gt; 9) &#123; sb.append((char)(Integer.parseInt(s) + 55)); &#125; else &#123; sb.append(s); &#125; &#125; return sb.toString(); &#125;&#125; 结果1B35 PS.除X取余法查看博客：进制（第一张图片便是除2取余法）","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"资源分享平台","slug":"76","date":"2021-01-17T14:00:14.000Z","updated":"2022-03-26T10:03:56.131Z","comments":true,"path":"76.html","link":"","permalink":"https://blog.zoutl.cn/76.html","excerpt":"","text":"项目地址GitHub地址：https://github.com/a6678696/InformationSharing 使用的技术本项目核心技术采用Spring Boot+Mybatis；开发工具idea；数据库MySQL5.6；模版引擎采用的是Thymeleaf；安全框架采用SpringSecurity；在线编辑器CKEditor；Lucene全文检索；Quartz定时任务；基于JavaMail实现用QQ邮箱发送邮件 功能介绍用户功能注册、登录、找回密码（通过邮箱获取验证码）、查看发布的资源、下载资源、Lucene全文搜索资源、发表评论、修改个人信息、管理个人资源、查看自己的资源下的评论、查看自己的下载信息、查看属于自己的消息 管理员功能用户管理（添加，修改，删除，查询，封禁或解禁用户，切换用户身份，给用户加积分和减积分）、资源类别管理（添加，修改，删除，查询）、资源管理（查看，删除，审核通过和不通过，设置热门与否，设置有效与否）、友情链接管理（添加，修改，删除，查询）、评论管理（删除，查询，审核通过和不通过）、下载信息管理（删除，查询）、消息管理（删除，查询，给用户发消息）、安全退出 图片展示前台首页 Lucene全文搜索资源 查看资源详情 下载资源 登录 注册 找回密码 用户中心页面 查看个人信息 修改个人信息 发布资源 资源管理 失效资源管理 查看下载信息 评论管理 查看系统消息 后台登录 首页 用户管理 资源类别管理 资源管理 友情链接管理 评论管理 下载信息管理 消息管理 安全退出","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"MySQL删除主表时删除从表的数据","slug":"75","date":"2021-01-14T21:42:57.000Z","updated":"2022-04-14T02:34:13.836Z","comments":true,"path":"75.html","link":"","permalink":"https://blog.zoutl.cn/75.html","excerpt":"","text":"概述有外键关联的两个表，要想实现删除主表的数据，然后删除从表中与之关联的数据，我们可以将两表的外键删除关系设置为CASCADE 设置CASCADE删除时：删除主表数据时自动删除从表数据；删除从表，主表不变 表结果及关系 设置删除关系双击上图中的线，然后设置删除时的关系为CASCADE 然后我们的需求就可以实现了！！ PS.我用的是SQLyog","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"List集合删除某个元素","slug":"74","date":"2021-01-14T11:06:20.000Z","updated":"2022-04-14T02:09:50.989Z","comments":true,"path":"74.html","link":"","permalink":"https://blog.zoutl.cn/74.html","excerpt":"","text":"创建List集合12345List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(&quot;a&quot;);stringList.add(&quot;a&quot;);stringList.add(&quot;b&quot;);stringList.add(&quot;c&quot;); 删除for循环 正向删除 每删除一次必须进行一次i--，因为stringList.size()在减少，否则List集合中连着的两个元素都相同的话，删除这个相同的元素时就只能删除一个。因为删除第一个元素时下一个以及之后的元素的索引会在原来的基础上-1，而i的值经过一次循环后就+1了，由于下一个元素的索引变成了被删除元素的索引，所以循环会跳过要删除的第二个元素，那么会出现等于要删除的值的元素删不完的情况 123456for (int i = 0; i &lt; stringList.size(); i++) &#123; if (stringList.get(i).equals(&quot;a&quot;)) &#123; stringList.remove(i); i--; &#125;&#125; 反向删除 可以直接删除，不需要进行其他的操作 12345for (int i = stringList.size() - 1; i &gt;= 0; i--) &#123; if (stringList.get(i).equals(&quot;a&quot;)) &#123; stringList.remove(i); &#125;&#125; 迭代器123456Iterator iterator=stringList.iterator();while (iterator.hasNext()) &#123; if (iterator.next().equals(&quot;a&quot;)) &#123; iterator.remove(); &#125;&#125; Stream得到新的List集合就是去掉目标元素的集合 1List&lt;String&gt; stringList1=stringList.stream().filter(s -&gt; !s.equals(&quot;a&quot;)).collect(Collectors.toList()); PS.不能使用foreach循环，用foreach删除list元素的时候只有删除倒数第二个元素时不会报错 详细原因查看：foreach遍历list删除元素一定会报错？","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"遍历List集合的三种方法","slug":"73","date":"2021-01-14T08:43:57.000Z","updated":"2022-04-14T02:09:48.761Z","comments":true,"path":"73.html","link":"","permalink":"https://blog.zoutl.cn/73.html","excerpt":"","text":"创建List集合12345List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(&quot;1&quot;);stringList.add(&quot;2&quot;);stringList.add(&quot;3&quot;);stringList.add(&quot;4&quot;); 遍历for循环123for (int i = 0; i &lt; stringList.size(); i++) &#123; System.out.print(stringList.get(i)+&quot; &quot;);&#125; foreach循环123for (String s : stringList) &#123; System.out.print(s+&quot; &quot;);&#125; 迭代器1234Iterator iterator = stringList.iterator();while (iterator.hasNext()) &#123; System.out.print(iterator.next() + &quot; &quot;);&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Iterator的使用","slug":"72","date":"2021-01-14T08:34:16.000Z","updated":"2022-04-14T02:09:46.852Z","comments":true,"path":"72.html","link":"","permalink":"https://blog.zoutl.cn/72.html","excerpt":"","text":"方法hasNext()如果迭代具有更多的元素，则返回true next()返回迭代中的下一个元素 remove()从底层集合中删除此迭代器返回的最后一个元素 Java代码12345678910111213141516171819202122public static void main(String[] args) &#123; List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add(&quot;1&quot;); stringList.add(&quot;2&quot;); stringList.add(&quot;3&quot;); stringList.add(&quot;4&quot;); Iterator iterator = stringList.iterator(); while (iterator.hasNext()) &#123; //获取下一个元素 String s = (String) iterator.next(); //如果下一个元素的值是2 if (s.equals(&quot;2&quot;)) &#123; //删除下一个元素 iterator.remove(); &#125; &#125; System.out.println(&quot;结果:&quot;); //遍历 for (String s : stringList) &#123; System.out.print(s+&quot; &quot;); &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"MD5加密","slug":"71","date":"2021-01-12T21:23:55.000Z","updated":"2022-04-14T02:09:45.115Z","comments":true,"path":"71.html","link":"","permalink":"https://blog.zoutl.cn/71.html","excerpt":"","text":"Java代码12345678910111213141516171819202122232425262728293031323334353637383940package com; import java.math.BigInteger;import java.security.MessageDigest; /** * @author LeDao * @company * @create 2021-01-13 5:15 */public class Md5 &#123; public static final String KEY_MD5 = &quot;MD5&quot;; public static String getResult(String inputStr) &#123; System.out.println(&quot;=======加密前的数据:&quot;+inputStr); BigInteger bigInteger=null; try &#123; MessageDigest md = MessageDigest.getInstance(KEY_MD5); byte[] inputData = inputStr.getBytes(); md.update(inputData); bigInteger = new BigInteger(md.digest()); &#125; catch (Exception e) &#123;e.printStackTrace();&#125; System.out.println(&quot;MD5加密后:&quot; + bigInteger.toString(16)); return bigInteger.toString(16); &#125; public static void main(String[] args) &#123; try &#123; String inputStr = &quot;123456&quot;; getResult(inputStr); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"jackson的配置属性","slug":"70","date":"2021-01-12T20:41:17.000Z","updated":"2022-04-14T02:09:43.065Z","comments":true,"path":"70.html","link":"","permalink":"https://blog.zoutl.cn/70.html","excerpt":"","text":"配置date-format指定日期格式，比如yyyy-MM-dd HH:mm:ss，或者具体的格式化类的全限定名 deserialization是否开启Jackson的反序列化 generator是否开启json的generators joda-date-time-format指定Joda date/time的格式，比如yyyy-MM-ddHH:mm:ss). 如果没有配置的话，dateformat会作为backup locale指定json使用的Locale mapper是否开启Jackson通用的特性 parser是否开启jackson的parser特性 property-naming-strategy指定PropertyNamingStrategy(CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES)或者指定PropertyNamingStrategy子类的全限定类名 serialization是否开启jackson的序列化 serialization-inclusion指定序列化时属性的inclusion方式，具体查看JsonInclude.Include枚举 time-zone指定日期格式化时区，比如America/Los_Angeles或者GMT+10 PS.来源：springboot之jackson的两种配置方式","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"SQL里面的排序语句DESC和ASC","slug":"69","date":"2021-01-12T20:06:09.000Z","updated":"2022-04-14T02:34:11.938Z","comments":true,"path":"69.html","link":"","permalink":"https://blog.zoutl.cn/69.html","excerpt":"","text":"DESC用 DESC表示按倒序排序（即：从大到小排序）—降序排列 例如： 1ORDER BY DATE DESC ACS用 ASC表示按正序排序（即：从小到大排序）—升序排列，由于ASC是默认的，所以可以省略 例如： 1ORDER BY DATE ASC","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"点击超链接时确认后再跳转","slug":"68","date":"2021-01-08T17:00:48.000Z","updated":"2022-04-14T02:09:39.160Z","comments":true,"path":"68.html","link":"","permalink":"https://blog.zoutl.cn/68.html","excerpt":"","text":"概述用户要删除某条数据时，先询问用户是否真的删除，用户确认后就马上删除 HTML代码1&lt;a href=&quot;javascript:deleteArticle(id)&quot;&gt;删除&lt;/a&gt; JavaScript代码123456function deleteArticle(id) &#123; if (confirm(&quot;您确定要删除这个资源吗?&quot;)) &#123; window.location.href = &quot;/article/delete?id=&quot; + id; alert(&quot;删除成功!&quot;); &#125;&#125; 结果","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"form标签onsubmit事件","slug":"67","date":"2021-01-07T11:20:55.000Z","updated":"2022-04-10T14:17:34.084Z","comments":true,"path":"67.html","link":"","permalink":"https://blog.zoutl.cn/67.html","excerpt":"","text":"概述onsubmit 事件会在表单中的确认按钮被点击时发生，如果结果返回false就不提交 HTML代码123&lt;form action=&quot;/user/save&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;return checkUpdateMessageValue()&quot;&gt; ....&lt;/form&gt; JavaScript代码12345678910111213function checkUpdateMessageValue() &#123; var password = $(&quot;#passwordUpdateMessage&quot;).val(); var password2 = $(&quot;#password2UpdateMessage&quot;).val(); if (password.length &lt; 6) &#123; alert(&quot;密码长度要大于5!&quot;); return false; &#125; if (password != password2) &#123; alert(&quot;密码和确认密码不相同,请重新输入!&quot;); return false; &#125; return true;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"GitHub搜索技巧","slug":"66","date":"2021-01-05T13:55:56.000Z","updated":"2022-04-14T01:54:09.501Z","comments":true,"path":"66.html","link":"","permalink":"https://blog.zoutl.cn/66.html","excerpt":"","text":"根据star和fork数筛选语法： 关键字 stars:&gt;= 数量 forks:&gt;=数量 例子： springboot stars:&gt;=5000 //搜索springboot有关star数&gt;=5000的内容 springboot stars:&gt;=5000 forks:&gt;=5000//搜索springboot 的star&gt;=5000，且fork数&gt;=5000的内容 可单独搜索，也可组合搜索，中间用空格隔开，是&amp;（且）的关系 in搜索关键字在GitHub上发布的位置 name （发布的仓库名称） description（指的是文章的摘要部分） Readme (说明文档) 语法 ：关键字 in: 例子 ：netty in:name //查找名称中包含netty的内容 netty in:name,description //逗号分隔，是 || (或)的关系，指的是查询名称，或者描述中包含netty的内容 awesome+关键字一般是指的学习，书籍，工具类，插件类相关的系列的集合。可以有效节约时间，找到别人收集好的内容 例如： awesome springboot 关键词 location:地区 language:语言搜索某个语言，某个地区的大佬 例如：springboot location:Beijing language:java user:某位用户查询某位用户的相关内容 例如：user:a6678696 PS.来源：github实用的搜索小技巧 - 夕阳下飞奔的猪 - 博客园","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"JavaScript获取验证码倒计时","slug":"65","date":"2021-01-04T13:31:06.000Z","updated":"2022-03-26T09:27:31.790Z","comments":true,"path":"65.html","link":"","permalink":"https://blog.zoutl.cn/65.html","excerpt":"","text":"HTML代码1&lt;input type=&quot;button&quot; class=&quot;layui-btn layui-btn-warm&quot; style=&quot;margin-top: 12px&quot; value=&quot;获取验证码&quot; onclick=&quot;setTime(this);&quot;&gt; JavaScript代码点击获取验证码按钮后，将按钮设置为不可用，60秒时间到了之后将按钮设置为可用 1234567891011121314151617181920212223&lt;script type=&quot;text/javascript&quot;&gt; //倒计时 var countdown = 60; function setTime(val) &#123; if (countdown == 0) &#123; val.removeAttribute(&quot;disabled&quot;); val.className = &#x27;obtain generate_code layui-btn layui-btn-warm&#x27;; val.value = &quot;获取验证码&quot;; countdown = 60; return false; &#125; else &#123; val.setAttribute(&quot;disabled&quot;, true); val.className = &#x27;obtain generate_code layui-btn layui-btn-warm layui-btn-disabled&#x27;; val.value = &quot;重新发送(&quot; + countdown + &quot;)&quot;; countdown--; &#125; setTimeout(function () &#123; setTime(val); &#125;, 1000); &#125;&lt;/script&gt; 结果","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Java基于JavaMail实现用QQ邮箱发送邮件","slug":"64","date":"2021-01-04T10:09:04.000Z","updated":"2022-04-14T02:09:35.481Z","comments":true,"path":"64.html","link":"","permalink":"https://blog.zoutl.cn/64.html","excerpt":"","text":"引入Maven依赖123456&lt;!-- email邮件 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 开启POP3/SMTP服务位置：QQ邮箱首页-&gt;设置-&gt;账户，然后会得到一个授权码 application.yml文件配置*****处根据自己的实际情况填写 12345678910111213141516171819spring: # QQ邮箱发送配置 mail: # host不配置会注入失败 host: smtp.qq.com #自己的邮箱 username: ****@qq.com #授权码 password: **** default-encoding: utf-8 protocol: smtp properties: mail: smtp: connectiontimeout: 5000 timeout: 3000 writetimeout: 5000 ssl: enable: true #一定要开启ssl,不然会503 验证失败的（开启加密验证） Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.ledao.controller;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSender;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.annotation.Resource;/** * @author LeDao * @company * @create 2021-07-16 9:08 */@Controllerpublic class MyController &#123; @Resource private JavaMailSender javaMailSender; /** * 首页 * * @return */ @ResponseBody @RequestMapping(&quot;/&quot;) public String root() &#123; return &quot;&lt;h1 style=&#x27;text-align: center&#x27;&gt;&lt;a href=&#x27;/sendMail&#x27;&gt;点我发送邮件&lt;/a&gt;&lt;/h1&gt;&quot;; &#125; /** * 发送邮件测试 * * @return */ @ResponseBody @RequestMapping(&quot;/sendMail&quot;) public String sendMail() &#123; SimpleMailMessage message = new SimpleMailMessage(); //发件人QQ邮箱 message.setFrom(&quot;******@qq.com&quot;); //收件人QQ邮箱 message.setTo(&quot;******@qq.com&quot;); //主题 message.setSubject(&quot;发送邮件测试&quot;); //内容 message.setText(&quot;111&quot;); //发送邮件 javaMailSender.send(message); return &quot;&lt;h2 style=&#x27;color:red;text-align: center&#x27;&gt;发送成功,请到收件人邮箱查收!!&lt;/h2&gt;&quot;; &#125;&#125; 测试与结果运行项目后，点击发送邮件链接，之后目标邮箱就可以收到邮件了","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"IntelliJ IDEA导出配置和导入配置","slug":"63","date":"2021-01-02T07:08:40.000Z","updated":"2022-04-14T02:46:33.268Z","comments":true,"path":"63.html","link":"","permalink":"https://blog.zoutl.cn/63.html","excerpt":"","text":"导出配置 导入配置","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IntelliJ IDEA上传项目到GitHub","slug":"62","date":"2021-01-01T19:58:36.000Z","updated":"2022-04-14T02:46:27.045Z","comments":true,"path":"62.html","link":"","permalink":"https://blog.zoutl.cn/62.html","excerpt":"","text":"创建本地仓库 创建本地仓库，如果找不到则按两下shift键搜索create git repository 选择对应项目文件夹 选择要上传的项目，点击OK后项目文件会变红 添加项目链接 添加GitHub项目链接 提交到本地仓库 提交到本地仓库，右击项目工程文件-&gt;git-&gt;commit（或者快捷键Ctrl+K），提交到本地git，项目文件从暂存区进入版本库，文件颜色变白，在红圈区域输入文件内容描述，点击Commit，在之后的弹出框再次点击Commit即可 上传到GitHub 开始上传到GitHub（或者快捷键Ctrl+Shift+K）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"GitHub生成token","slug":"61","date":"2021-01-01T19:32:15.000Z","updated":"2022-04-14T01:54:22.450Z","comments":true,"path":"61.html","link":"","permalink":"https://blog.zoutl.cn/61.html","excerpt":"","text":"打开设置 进入GitHub首页，点击右上角的个人头像，然后再点击Settings 点击左侧菜单的Developer settings 点击左侧菜单的Personal access tokens 生成 点击Generate new token Note随便填入描述，下面的选项全部打勾（token的用途），再点击最下面的绿色按钮（Generate token）即可","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"GitHub新建仓库","slug":"60","date":"2021-01-01T18:40:35.000Z","updated":"2022-04-14T01:54:27.397Z","comments":true,"path":"60.html","link":"","permalink":"https://blog.zoutl.cn/60.html","excerpt":"","text":"点击新建按钮 来到GitHub首页,点击左侧的NEW按钮 填写仓库信息 输入名称、描述、选择仓库类型（公开或私有） 点击最下方的创建按钮即可创建成功","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"IntelliJ IDEA创建自己的Live Templates","slug":"59","date":"2021-01-01T17:26:59.000Z","updated":"2022-04-14T02:46:20.435Z","comments":true,"path":"59.html","link":"","permalink":"https://blog.zoutl.cn/59.html","excerpt":"","text":"打开对应设置打开设置，并找到Live Templates（File-&gt;Settings或者快捷键Ctrl+Alt+S） 添加点击右侧的+号并选择第二个选项 选择刚刚创建的组，再次点击右侧的+号，选择第一项开始添加 Abbreviation处填关键字（比如我填pi，那么我在敲代码时键入pi时就会出现提示），Description处填提示描述，Template text填自动补全的代码内容 选中Java，然后点击OK键即可 效果","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IntelliJ IDEA创建自己的xml模板","slug":"58","date":"2021-01-01T17:00:37.000Z","updated":"2022-04-14T02:46:16.052Z","comments":true,"path":"58.html","link":"","permalink":"https://blog.zoutl.cn/58.html","excerpt":"","text":"打开对应设置打开设置，并找到Live Templates（File-&gt;Settings或者快捷键Ctrl+Alt+S） 添加找到文件和代码模板设置，并点击+号添加，如下图 Name处填模板的名称，Extension处填类型，被圈住的地方填内容，最后点击下方的OK键即可","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"Scanner的hasNext()方法","slug":"57","date":"2020-12-17T16:50:20.000Z","updated":"2022-04-14T02:09:27.700Z","comments":true,"path":"57.html","link":"","permalink":"https://blog.zoutl.cn/57.html","excerpt":"","text":"概述这个方法用来检查用户是否键入内容 连续输入当我们想键入多个内容时，就可以使用这个方法和while循环（连续输入，不会终止） 1234567public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); while(sc.hasNext())&#123; int mouth=sc.nextInt(); System.out.println(mouth); &#125;&#125; 停止输入当我们想停止输入时，可在该方法的括号内加入用来终止的字符（键入这个字符，按下回车就会终止） 12345678public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); //当用户没有输入#号时，可以连续输入 while(!sc.hasNext(&quot;#&quot;))&#123; int mouth=sc.nextInt(); System.out.println(mouth); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"HTML去掉a标签的下划线","slug":"56","date":"2020-12-06T08:23:59.000Z","updated":"2022-04-10T05:07:58.929Z","comments":true,"path":"56.html","link":"","permalink":"https://blog.zoutl.cn/56.html","excerpt":"","text":"给该标签添加行内样式text-decoration: none（使用属性style进行定义），示例代码如下： 1&lt;a href=&quot;http://www.zoutl.cn&quot; style=&quot;text-decoration: none&quot;&gt;LeDao的博客&lt;/a&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"QuickLook不能预览office的解决方法","slug":"55","date":"2020-12-05T07:11:34.000Z","updated":"2022-04-07T12:58:32.337Z","comments":true,"path":"55.html","link":"","permalink":"https://blog.zoutl.cn/55.html","excerpt":"","text":"下载插件下载地址：https://github.com/QL-Win/QuickLook.Plugin.OfficeViewer/releases ，点击划红线的链接即可下载 安装插件找到下载好的插件，鼠标左键单击选中该插件文件，再按下空格键，点击安装，重启QuickLook即可","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"QuickLook","slug":"QuickLook","permalink":"https://blog.zoutl.cn/tags/QuickLook/"}]},{"title":"重写与重载的区别","slug":"54","date":"2020-12-04T03:26:48.000Z","updated":"2022-04-14T02:09:22.670Z","comments":true,"path":"54.html","link":"","permalink":"https://blog.zoutl.cn/54.html","excerpt":"","text":"重写(Override)从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的 Java代码 123456789101112131415161718192021public class Father &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Son s = new Son(); s.sayHello(); &#125; public void sayHello() &#123; System.out.println(&quot;Hello&quot;); &#125;&#125; class Son extends Father&#123; @Override public void sayHello() &#123; // TODO Auto-generated method stub System.out.println(&quot;hello by &quot;); &#125;&#125; 总结 发生在父类与子类之间 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private) 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 重载(Overload)在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，所以不能通过返回类型是否相同来判断重载 Java代码 123456789101112131415161718public class Father &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Father s = new Father(); s.sayHello(); s.sayHello(&quot;wintershii&quot;); &#125; public void sayHello() &#123; System.out.println(&quot;Hello&quot;); &#125; public void sayHello(String name) &#123; System.out.println(&quot;Hello&quot; + &quot; &quot; + name); &#125;&#125; 总结 重载Overload是一个类中多态性的一种表现 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准 PS.搬运地址：Java—重写与重载的区别_wintershii的博客-CSDN博客_重载和重写的区别","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"二进制位运算---左移(<<)右移(>>)","slug":"53","date":"2020-12-04T03:02:33.000Z","updated":"2022-04-14T02:09:20.751Z","comments":true,"path":"53.html","link":"","permalink":"https://blog.zoutl.cn/53.html","excerpt":"","text":"左移（&lt;&lt;）一般来说，向左移动几位就乘以2的几次幂；但是，如果要左移的数化成二进制后的最高位不是0而是1时，前面的结论就不成立了，就要化成二进制后再运算了（去掉最高位的1，最低位补0） 右移（&gt;&gt;）一般来说，向右移动几位就除以2的几次幂；但是，如果要右移的数化成二进制后的最低位不是0而是1时，前面的结论就不成立了，就要化成二进制后再运算了（去掉最低位的1，最高位补0） Java代码1234567891011121314151617181920public static void main(String[] args) &#123; //向左移动几位就乘以2的几次幂 /*去掉最高位,最低位补零,左边为二进制，右边为十进制 1100=12 12&lt;&lt;1的结果:11000=24 12&lt;&lt;2的结果:110000=48 */ System.out.println(12 &lt;&lt; 1); System.out.println(12 &lt;&lt; 2); //向右移动几位就除以2的几次幂 /*去掉最低位,最高位补零,左边为二进制，右边为十进制 1100=12 12&gt;&gt;1的结果:110=6 12&gt;&gt;2的结果:11=3 12&gt;&gt;3的结果:1=1 */ System.out.println(12 &gt;&gt; 1); System.out.println(12 &gt;&gt; 2); System.out.println(12 &gt;&gt; 3);&#125; 运行结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"自加（++）自减（--）运算","slug":"52","date":"2020-12-04T02:38:58.000Z","updated":"2022-04-14T02:09:19.285Z","comments":true,"path":"52.html","link":"","permalink":"https://blog.zoutl.cn/52.html","excerpt":"","text":"单独使用时放在操作数的前面和后面效果一样，这种用法是我们比较常见的 参与运算使用时在操作数的前面放在操作数的前面，先自增或者自减，然后再参与运算 在操作数的后面放在操作数的后面，先参与运算，再自增或者自减 Java代码123456789101112public static void main(String[] args) &#123; int a=10; int b=10; int c=10; a=b++;//a=10,b=11 c=--a;//c=9,a=9 b=++a;//b=10,a=10 a=c--;//a=9,c=8 System.out.println(&quot;a=&quot;+a); System.out.println(&quot;b=&quot;+b); System.out.println(&quot;c=&quot;+c);&#125; 运行结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Windows10获取锁屏壁纸","slug":"51","date":"2020-11-12T17:00:56.000Z","updated":"2022-04-14T02:02:50.243Z","comments":true,"path":"51.html","link":"","permalink":"https://blog.zoutl.cn/51.html","excerpt":"","text":"找到壁纸文件首先打开文件资源管理器，或者随便打开一个文件夹，在地址栏输入下面的路径后回车进入Assets文件夹 1C:\\Users\\%username%\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\LocalState\\Assets 修改扩展名这个文件夹就是锁屏壁纸的存放文件夹了，不过系统去掉了这些文件的扩展名，所以看到的全都是不能打开的文件，也不能设置为桌面背景。我们要修改这些文件的扩展名为png或jpg，让它们变成图片文件，才能设为壁纸。我们首先将这个文件夹复制到桌面，然后点击开始菜单，输入cmd，打开命令提示符，输入下面的命令: 1Ren C:\\Users\\%username%\\Desktop\\Assets\\*.* *.png","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"}]},{"title":"大小写转换","slug":"50","date":"2020-11-12T06:10:26.000Z","updated":"2022-04-14T02:09:16.295Z","comments":true,"path":"50.html","link":"","permalink":"https://blog.zoutl.cn/50.html","excerpt":"","text":"字符小写转大写12char c1 = &#x27;a&#x27;;c1=Character.toUpperCase(c1); 大写转小写12char c2 = &#x27;B&#x27;; c2 = Character.toLowerCase(c2); 字符串全部转换成小写12String str = &quot;aBcD&quot;;str=str.toLowerCase(); 全部转换成大写12String str = &quot;aBcD&quot;;str=str.toUpperCase(); Java代码12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; char c1 = &#x27;a&#x27;; char c2 = &#x27;B&#x27;; System.out.println(&quot;字符大小写转换:&quot;); System.out.println(&quot;转换前:c1=&quot;+c1); c1=Character.toUpperCase(c1); System.out.println(&quot;转换后:c1=&quot;+c1); System.out.println(&quot;转换前:c2=&quot;+c2); c2 = Character.toLowerCase(c2); System.out.println(&quot;转换后:c2=&quot;+c2); System.out.println(&quot;字符串全部转换成大写或小写&quot;); String str = &quot;aBcD&quot;; System.out.println(&quot;转换前:&quot; + str); System.out.println(&quot;转换后:&quot;); System.out.println(&quot;全部转换成小写:&quot;+str.toLowerCase()); System.out.println(&quot;全部转换成大写:&quot;+str.toUpperCase()); System.out.println(&quot;字符串大写变小写,小写变大写:&quot;); StringBuffer stringBuffer = new StringBuffer(str); System.out.println(&quot;转换前:&quot;+stringBuffer); char[] arr = new char[stringBuffer.length()]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = stringBuffer.charAt(i); if (65&lt;=arr[i]&amp;&amp;arr[i]&lt;=90) &#123; arr[i] = Character.toLowerCase(arr[i]); &#125; else if (97&lt;=arr[i]&amp;&amp;arr[i]&lt;=122) &#123; arr[i] = Character.toUpperCase(arr[i]); &#125; &#125; stringBuffer.delete(0, stringBuffer.length()); for (int i = 0; i &lt; arr.length; i++) &#123; stringBuffer.append(arr[i]); &#125; System.out.println(&quot;转换后:&quot;+stringBuffer);&#125; 运行结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"ASCII码","slug":"49","date":"2020-11-12T05:24:41.000Z","updated":"2022-04-10T14:06:57.956Z","comments":true,"path":"49.html","link":"","permalink":"https://blog.zoutl.cn/49.html","excerpt":"","text":"ASCII码的组成第一部分是：ASCII非打印控制字符 第二部分是：ASCII打印字符 第三部分是：扩展ASCII打印字符 各组成部分ASCII非打印控制字符ASCII表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。例如，12代表换页/新页功能。此命令指示打印机跳到下一页的开头。（参详ASCII码表中0-31） ASCII打印字符 Bin Dec 缩写/字符 解释 00000000 0 NUL(null) 空字符 00000001 1 SOH(start of headling) 标题开始 00000010 2 STX (start of text) 正文开始 00000011 3 ETX (end of text) 正文结束 00000100 4 EOT (end of transmission) 传输结束 00000101 5 ENQ (enquiry) 请求 00000110 6 ACK (acknowledge) 收到通知 00000111 7 BEL (bell) 响铃 00001000 8 BS (backspace) 退格 00001001 9 HT (horizontal tab) 水平制表符 00001010 10 LF (NL line feed, new line) 换行键 00001011 11 VT (vertical tab) 垂直制表符 00001100 12 FF (NP form feed, new page) 换页键 00001101 13 CR (carriage return) 回车键 00001110 14 SO (shift out) 不用切换 00001111 15 SI (shift in) 启用切换 00010000 16 DLE (data link escape) 数据链路转义 00010001 17 DC1 (device control 1) 设备控制1 00010010 18 DC2 (device control 2) 设备控制2 00010011 19 DC3 (device control 3) 设备控制3 00010100 20 DC4 (device control 4) 设备控制4 00010101 21 NAK (negative acknowledge) 拒绝接收 00010110 22 SYN (synchronous idle) 同步空闲 00010111 23 ETB (end of trans. block) 传输块结束 00011000 24 CAN (cancel) 取消 00011001 25 EM (end of medium) 介质中断 00011010 26 SUB (substitute) 替补 00011011 27 ESC (escape) 溢出 00011100 28 FS (file separator) 文件分割符 00011101 29 GS (group separator) 分组符 00011110 30 RS (record separator) 记录分离符 00011111 31 US (unit separator) 单元分隔符 00100000 32 (space) 空格 00100001 33 ! 00100010 34 “ 00100011 35 # 00100100 36 $ 00100101 37 % 00100110 38 &amp; 00100111 39 ‘ 00101000 40 ( 00101001 41 ) 00101010 42 * 00101011 43 + 00101100 44 , 00101101 45 - 00101110 46 . 00101111 47 / 00110000 48 0 00110001 49 1 00110010 50 2 00110011 51 3 00110100 52 4 00110101 53 5 00110110 54 6 00110111 55 7 00111000 56 8 00111001 57 9 00111010 58 : 00111011 59 ; 00111100 60 &lt; 00111101 61 = 00111110 62 &gt; 00111111 63 ? 01000000 64 @ 01000001 65 A 01000010 66 B 01000011 67 C 01000100 68 D 01000101 69 E 01000110 70 F 01000111 71 G 01001000 72 H 01001001 73 I 01001010 74 J 01001011 75 K 01001100 76 L 01001101 77 M 01001110 78 N 01001111 79 O 01010000 80 P 01010001 81 Q 01010010 82 R 01010011 83 S 01010100 84 T 01010101 85 U 01010110 86 V 01010111 87 W 01011000 88 X 01011001 89 Y 01011010 90 Z 01011011 91 [ 01011100 92 \\ 01011101 93 ] 01011110 94 ^ 01011111 95 _ 01100000 96 ` 01100001 97 a 01100010 98 b 01100011 99 c 01100100 100 d 01100101 101 e 01100110 102 f 01100111 103 g 01101000 104 h 01101001 105 i 01101010 106 j 01101011 107 k 01101100 108 l 01101101 109 m 01101110 110 n 01101111 111 o 01110000 112 p 01110001 113 q 01110010 114 r 01110011 115 s 01110100 116 t 01110101 117 u 01110110 118 v 01110111 119 w 01111000 120 x 01111001 121 y 01111010 122 z 01111011 123 { 01111100 124 | 01111101 125 } 01111110 126 ~ 01111111 127 DEL (delete) 删除 扩展ASCII打印字符扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。即使有了这些更多的字符，许多语言还是包含无法压缩到256个字符中的符号。因此，出现了一些ASCII的变体来囊括地区性字符和符号。例如，许多软件程序把ASCII表（又称作ISO8859-1）用于北美、西欧、澳大利亚和非洲的语言。","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Java跳转语句","slug":"48","date":"2020-11-03T04:57:11.000Z","updated":"2022-04-14T02:09:11.906Z","comments":true,"path":"48.html","link":"","permalink":"https://blog.zoutl.cn/48.html","excerpt":"","text":"概述Java语言中，有三种跳转语句：break、continue和return break语句用于终止循环的操作，break语句在for、while、do…while循环语句中用于强制退出当前循环 123456789public static void main(String[] args) &#123; for (int i=1;i&lt;=10;i++)&#123; if (i==4)&#123; //直接结束，后面的不执行 break; &#125; System.out.print(i+&quot; &quot;); &#125;&#125; continue语句continue也可以放在循环语句中，它与break语句具有相反的效果，它的作用是用于执行下依次循环（跳过满足条件的当次循环），而不是退出当前循环 123456789public static void main(String[] args) &#123; for (int i=1;i&lt;=10;i++)&#123; if (i==4)&#123; //跳出本次循环，后面的继续循环 continue; &#125; System.out.print(i+&quot; &quot;); &#125;&#125; return语句return语句可以从一个方法返回，并把控制权交给调用它的语句 1234567891011public static void main(String[] args) &#123; for (int i=1;i&lt;=10;i++)&#123; if (i==4)&#123; //结束方法（main方法） return; &#125; System.out.print(i+&quot; &quot;); &#125; //该语句不执行 System.out.println(&quot;111111111111&quot;);&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"==和equals的区别","slug":"47","date":"2020-10-25T09:48:14.000Z","updated":"2022-04-14T02:09:09.287Z","comments":true,"path":"47.html","link":"","permalink":"https://blog.zoutl.cn/47.html","excerpt":"","text":"==基本类型：比较的就是值是否相同 引用类型：比较的就是地址值是否相同 equals引用类型：默认情况下，比较的是地址值，重写该方法后比较对象的成员变量值是否相同 本质上就是==，主要看它有没有被重写，没有被重写就和==一样 PS.基本类型： 引用类型： 除掉这四类八种基本类型，其它的都是对象，也就是引用类型，包括数组。","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"十大经典排序算法之基数排序","slug":"46","date":"2020-10-22T15:41:34.000Z","updated":"2022-04-14T02:09:06.730Z","comments":true,"path":"46.html","link":"","permalink":"https://blog.zoutl.cn/46.html","excerpt":"","text":"概述基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前 算法描述 取得数组中的最大数，并取得位数 arr为原始数组，从最低位开始取每个位组成radix数组 对radix进行计数排序（利用计数排序适用于小范围数的特点） 动图演示 算法实现Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 基数排序 * * @author LeDao */public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;63, 157, 189, 51, 101, 47, 141, 121, 157, 156,194, 117, 98, 139, 67, 133, 181, 12, 28, 0, 109&#125;; System.out.println(&quot;排序前:&quot;); for (int i : arr) &#123; System.out.print(i+&quot; &quot;); &#125; System.out.println(); radixSort(arr); System.out.println(&quot;排序后:&quot;); for (int i : arr) &#123; System.out.print(i+&quot; &quot;); &#125; &#125; /** * 高位优先法 * * @param arr 待排序列，必须为自然数 */ private static void radixSort(int[] arr) &#123; //待排序列最大值 int max = arr[0]; //指数 int exp; //计算最大值 for (int anArr : arr) &#123; if (anArr &gt; max) &#123; max = anArr; &#125; &#125; //从个位开始，对数组进行排序 for (exp = 1; max / exp &gt; 0; exp *= 10) &#123; //存储待排元素的临时数组 int[] temp = new int[arr.length]; //分桶个数 int[] buckets = new int[10]; //将数据出现的次数存储在buckets中 for (int value : arr) &#123; //(value / exp) % 10 :value的最底位(个位) buckets[(value / exp) % 10]++; &#125; //更改buckets[i] for (int i = 1; i &lt; 10; i++) &#123; buckets[i] += buckets[i - 1]; &#125; //将数据存储到临时数组temp中 for (int i = arr.length - 1; i &gt;= 0; i--) &#123; temp[buckets[(arr[i] / exp) % 10] - 1] = arr[i]; buckets[(arr[i] / exp) % 10]--; &#125; //将有序元素temp赋给arr System.arraycopy(temp, 0, arr, 0, arr.length); &#125; &#125;&#125; 运行结果 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之桶排序","slug":"45","date":"2020-10-22T14:55:49.000Z","updated":"2022-04-14T02:09:04.241Z","comments":true,"path":"45.html","link":"","permalink":"https://blog.zoutl.cn/45.html","excerpt":"","text":"概述桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排） 算法描述 设置一个定量的数组当作空桶 遍历输入数据，并且把数据一个一个放到对应的桶里去 对每个不是空的桶进行排序 从不是空的桶里把排好序的数据拼接起来 图片演示 算法实现Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.ledao;import java.util.*;/** * 桶排序 * * @author LeDao */public class Test &#123; public static void main(String[] args) &#123; // 输入元素均在 [0, 10) 这个区间内 float[] arr = new float[]&#123;0.12f, 2.2f, 8.8f, 7.6f, 7.2f, 6.3f, 9.0f, 1.6f, 5.6f, 2.4f&#125;; bucketSort(arr); printArray(arr); &#125; public static void bucketSort(float[] arr) &#123; // 新建一个桶的集合 ArrayList&lt;LinkedList&lt;Float&gt;&gt; buckets = new ArrayList&lt;LinkedList&lt;Float&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; // 新建一个桶，并将其添加到桶的集合中去。 // 由于桶内元素会频繁的插入，所以选择 LinkedList 作为桶的数据结构 buckets.add(new LinkedList&lt;Float&gt;()); &#125; // 将输入数据全部放入桶中并完成排序 for (float data : arr) &#123; int index = getBucketIndex(data); insertSort(buckets.get(index), data); &#125; // 将桶中元素全部取出来并放入 arr 中输出 int index = 0; for (LinkedList&lt;Float&gt; bucket : buckets) &#123; for (Float data : bucket) &#123; arr[index++] = data; &#125; &#125; &#125; /** * 计算得到输入元素应该放到哪个桶内 */ public static int getBucketIndex(float data) &#123; // 这里例子写的比较简单，仅使用浮点数的整数部分作为其桶的索引值 // 实际开发中需要根据场景具体设计 return (int) data; &#125; /** * 我们选择插入排序作为桶内元素排序的方法 每当有一个新元素到来时，我们都调用该方法将其插入到恰当的位置 */ public static void insertSort(List&lt;Float&gt; bucket, float data) &#123; ListIterator&lt;Float&gt; it = bucket.listIterator(); boolean insertFlag = true; while (it.hasNext()) &#123; if (data &lt;= it.next()) &#123; it.previous(); // 把迭代器的位置偏移回上一个位置 it.add(data); // 把数据插入到迭代器的当前位置 insertFlag = false; break; &#125; &#125; if (insertFlag) &#123; bucket.add(data); // 否则把数据插入到链表末端 &#125; &#125; public static void printArray(float[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot;, &quot;); &#125; System.out.println(); &#125;&#125; 运行结果 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之计数排序","slug":"44","date":"2020-10-22T14:43:19.000Z","updated":"2022-04-14T02:09:01.760Z","comments":true,"path":"44.html","link":"","permalink":"https://blog.zoutl.cn/44.html","excerpt":"","text":"概述计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数 算法描述 找出待排序的数组中最大和最小的元素 统计数组中每个值为i的元素出现的次数，存入数组C的第i项 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1 动图演示 算法实现Java代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * 计数排序 * * @author LeDao */public class Test &#123; public static void main(String[] args) &#123; int[] A=new int[]&#123;2,5,3,0,2,3,0,3&#125;; int[] B=countSort(A, 5); System.out.println(&quot;排序前:&quot;); for (int i : A) &#123; System.out.print(i+&quot; &quot;); &#125; System.out.println(); System.out.println(&quot;排序后:&quot;); for (int i : B) &#123; System.out.print(i+&quot; &quot;); &#125; &#125; private static int[] countSort(int[] array,int k) &#123; //构造C数组 int[] C=new int[k+1]; //获取A数组大小用于构造B数组 int length=array.length,sum=0; //构造B数组 int[] B=new int[length]; for(int i=0;i=0;i--) &#123; //将A中该元素放到排序后数组B中指定的位置 B[C[array[i]]-1]=array[i]; //将C中该元素-1，方便存放下一个同样大小的元素 C[array[i]]--; &#125; //将排序好的数组返回，完成排序 return B; &#125;&#125; 运行结果 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之堆排序","slug":"43","date":"2020-10-22T14:31:26.000Z","updated":"2022-04-14T02:08:59.869Z","comments":true,"path":"43.html","link":"","permalink":"https://blog.zoutl.cn/43.html","excerpt":"","text":"概述堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n] 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完 动图演示 算法实现Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 堆排序 * * @author LeDao */public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;16, 7, 3, 20, 17, 8&#125;; System.out.println(&quot;排序前:&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; System.out.println(); heapSort(arr); System.out.println(&quot;排序后:&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; /** * 创建堆 * * @param arr 待排序列 */ private static void heapSort(int[] arr) &#123; //创建堆 for (int i = (arr.length - 1) / 2; i &gt;= 0; i--) &#123; //从第一个非叶子结点从下至上，从右至左调整结构 adjustHeap(arr, i, arr.length); &#125; //调整堆结构+交换堆顶元素与末尾元素 for (int i = arr.length - 1; i &gt; 0; i--) &#123; //将堆顶元素与末尾元素进行交换 int temp = arr[i]; arr[i] = arr[0]; arr[0] = temp; //重新对堆进行调整 adjustHeap(arr, 0, i); &#125; &#125; /** * 调整堆 * * @param arr 待排序列 * @param parent 父节点 * @param length 待排序列尾元素索引 */ private static void adjustHeap(int[] arr, int parent, int length) &#123; //将temp作为父节点 int temp = arr[parent]; //左孩子 int lChild = 2 * parent + 1; while (lChild &lt; length) &#123; //右孩子 int rChild = lChild + 1; // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点 if (rChild &lt; length &amp;&amp; arr[lChild] &lt; arr[rChild]) &#123; lChild++; &#125; // 如果父结点的值已经大于孩子结点的值，则直接结束 if (temp &gt;= arr[lChild]) &#123; break; &#125; // 把孩子结点的值赋给父结点 arr[parent] = arr[lChild]; //选取孩子结点的左孩子结点,继续向下筛选 parent = lChild; lChild = 2 * lChild + 1; &#125; arr[parent] = temp; &#125;&#125; 运行结果 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之快速排序","slug":"42","date":"2020-10-22T14:07:31.000Z","updated":"2022-04-14T02:08:57.374Z","comments":true,"path":"42.html","link":"","permalink":"https://blog.zoutl.cn/42.html","excerpt":"","text":"概述快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot） 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序 动图演示 算法实现Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 快速排序 * * @author LeDao */public class Test &#123; public static void main(String[] args)&#123; int[] arr = &#123;10,7,2,4,7,62,3,4,2,1,8,9,19&#125;; System.out.println(&quot;排序前:&quot;); for (int i : arr) &#123; System.out.print(i+&quot; &quot;); &#125; System.out.println(); quickSort(arr, 0, arr.length-1); System.out.println(&quot;排序后:&quot;); for (int i : arr) &#123; System.out.print(i+&quot; &quot;); &#125; &#125; public static void quickSort(int[] arr,int low,int high)&#123; int i,j,temp,t; if(low&gt;high)&#123; return; &#125; i=low; j=high; //temp就是基准位 temp = arr[low]; while (i&lt;j) &#123; //先看右边，依次往左递减 while (temp&lt;=arr[j]&amp;&amp;i&lt;j) &#123; j--; &#125; //再看左边，依次往右递增 while (temp&gt;=arr[i]&amp;&amp;i&lt;j) &#123; i++; &#125; //如果满足条件则交换 if (i&lt;j) &#123; t = arr[j]; arr[j] = arr[i]; arr[i] = t; &#125; &#125; //最后将基准为与i和j相等位置的数字交换 arr[low] = arr[i]; arr[i] = temp; //递归调用左半数组 quickSort(arr, low, j-1); //递归调用右半数组 quickSort(arr, j+1, high); &#125;&#125; 运行结果 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之归并排序","slug":"41","date":"2020-10-22T13:55:44.000Z","updated":"2022-04-14T02:08:55.329Z","comments":true,"path":"41.html","link":"","permalink":"https://blog.zoutl.cn/41.html","excerpt":"","text":"概述归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列 对这两个子序列分别采用归并排序 将两个排序好的子序列合并成一个最终的排序序列 动图演示 算法实现Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*** 归并排序** @author LeDao*/public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;11,44,23,67,88,65,34,48,9,12&#125;; System.out.println(&quot;排序前:&quot;); for (int i : arr) &#123; System.out.print(i+&quot; &quot;); &#125; System.out.println(); //新建一个临时数组存放 int[] tmp = new int[arr.length]; mergeSort(arr,0,arr.length-1,tmp); System.out.println(&quot;排序后:&quot;); for (int i : arr) &#123; System.out.print(i+&quot; &quot;); &#125; &#125; public static void merge(int[] arr,int low,int mid,int high,int[] tmp)&#123; int i = 0; //左边序列和右边序列起始索引 int j = low,k = mid+1; while(j &lt;= mid &amp;&amp; k &lt;= high)&#123; if(arr[j] &lt; arr[k])&#123; tmp[i++] = arr[j++]; &#125;else&#123; tmp[i++] = arr[k++]; &#125; &#125; //若左边序列还有剩余，则将其全部拷贝进tmp[]中 while(j &lt;= mid)&#123; tmp[i++] = arr[j++]; &#125; while(k &lt;= high)&#123; tmp[i++] = arr[k++]; &#125; for(int t=0;t&lt;i;t++)&#123; arr[low+t] = tmp[t]; &#125; &#125; public static void mergeSort(int[] arr,int low,int high,int[] tmp)&#123; if(low&lt;high)&#123; int mid = (low+high)/2; //对左边序列进行归并排序 mergeSort(arr,low,mid,tmp); //对右边序列进行归并排序 mergeSort(arr,mid+1,high,tmp); //合并两个有序序列 merge(arr,low,mid,high,tmp); &#125; &#125; &#125; 运行结果 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之希尔排序","slug":"40","date":"2020-10-22T13:00:19.000Z","updated":"2022-04-14T02:08:52.554Z","comments":true,"path":"40.html","link":"","permalink":"https://blog.zoutl.cn/40.html","excerpt":"","text":"概述1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1 按增量序列个数k，对序列进行k 趟排序 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度 动图演示 算法实现Java代码1234567891011121314151617181920212223242526272829303132333435/** * 希尔排序 * * @author LeDao */public class Test &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;11, 3, 45, 2, 1, 7&#125;; System.out.println(&quot;排序前:&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; System.out.println(); shellSort(arr); System.out.println(&quot;排序后:&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; public static void shellSort(int[] arr) &#123; for (int step = arr.length / 2; step &gt; 0; step /= 2) &#123; for (int i = step; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; while (j - step &gt;= 0 &amp;&amp; arr[j - step] &gt; temp) &#123; arr[j] = arr[j - step]; j = j - step; &#125; arr[j] = temp; &#125; &#125; &#125;&#125; 运行结果 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之插入排序","slug":"39","date":"2020-10-22T05:29:53.000Z","updated":"2022-04-14T02:08:47.605Z","comments":true,"path":"39.html","link":"","permalink":"https://blog.zoutl.cn/39.html","excerpt":"","text":"概述插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 动图演示 算法实现Java代码12345678910111213141516171819public static void main(String[] args) &#123; int[] number = &#123;11, 3, 45, 2, 1, 7&#125;; System.out.println(&quot;排序前：&quot;); for (int i : number) &#123; System.out.print(i + &quot; &quot;); &#125; int temp, j; for (int i = 1; i &lt; number.length; i++) &#123; temp = number[i]; for (j = i - 1; j &gt;= 0 &amp;&amp; number[j] &gt; temp; j--) &#123; number[j + 1] = number[j]; &#125; number[j + 1] = temp; &#125; System.out.println(&quot;\\n排序后：&quot;); for (int i : number) &#123; System.out.print(i + &quot; &quot;); &#125;&#125; 运行结果 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之选择排序","slug":"38","date":"2020-10-22T04:29:27.000Z","updated":"2022-04-14T02:08:44.853Z","comments":true,"path":"38.html","link":"","permalink":"https://blog.zoutl.cn/38.html","excerpt":"","text":"概述选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区 n-1趟结束，数组有序化了 动图演示 算法实现Java代码12345678910111213141516171819202122232425262728293031323334353637/** * 选择排序 * * @author LeDao */public class Test &#123; public static void main(String[] args) &#123; int[] arr = &#123;11, 3, 45, 2, 1, 7&#125;; System.out.println(&quot;交换之前：&quot;); for (int num : arr) &#123; System.out.print(num + &quot; &quot;); &#125; // 做第i趟排序 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int k = i; // 选最小的记录 for (int j = k + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[k]) &#123; //记下目前找到的最小值所在的位置 k = j; &#125; &#125; //在内层循环结束，也就是找到本轮循环的最小的数以后，再进行交换 //交换a[i]和a[k] if (i != k) &#123; int temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; &#125; System.out.println(); System.out.println(&quot;交换后：&quot;); for (int num : arr) &#123; System.out.print(num + &quot; &quot;); &#125; &#125;&#125; 运行结果 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法之冒泡排序","slug":"37","date":"2020-10-22T03:50:51.000Z","updated":"2022-04-14T02:08:42.778Z","comments":true,"path":"37.html","link":"","permalink":"https://blog.zoutl.cn/37.html","excerpt":"","text":"概述冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数 针对所有的元素重复以上的步骤，除了最后一个 重复步骤1~3，直到排序完成 动图演示 算法实现Java代码1234567891011121314151617181920212223242526272829/** * 冒泡排序 * * @author LeDao */public class Test &#123; public static void main(String[] args) &#123; int[] arr = new int[]&#123;11, 3, 45, 2, 1, 7&#125;; BubbleSort(arr); System.out.println(&quot;排序后:&quot;); for (int i : arr) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; public static void BubbleSort(int[] arr) &#123; //临时变量,用于交换两个数 int temp; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 运行结果 PS.搬运地址: 十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"十大经典排序算法","slug":"36","date":"2020-10-21T18:31:56.000Z","updated":"2022-04-14T02:08:40.052Z","comments":true,"path":"36.html","link":"","permalink":"https://blog.zoutl.cn/36.html","excerpt":"","text":"算法分类十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序 算法复杂度 相关概念不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数 PS.博客搬运地址：十大经典排序算法（动图演示） - 一像素 - 博客园 (cnblogs.com)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"短路与&&和逻辑与&、短路或||和逻辑或|的区别","slug":"35","date":"2020-10-20T08:31:37.000Z","updated":"2022-04-14T02:08:31.684Z","comments":true,"path":"35.html","link":"","permalink":"https://blog.zoutl.cn/35.html","excerpt":"","text":"短路&amp;&amp;和逻辑&amp;相同点有假则为假，全真则为真（有假必假，全真为真） 区别逻辑与&amp;的判断方式是：从左到右依次判断，直到结尾（逻辑全程运算） 短路与&amp;&amp;的判断方式是：从左到右依次判断，直到出现false为止将不再判断，直接得到结果为false（短路遇false就停） 示例 逻辑与&amp; 短路与&amp;&amp; 短路||和逻辑|共同点有真则为真，全假则为假（有真必真，全假为假） 区别逻辑或|的判断方式是：从左到右依次判断，直到结尾 短路或||的判断方式是：从左到右依次判断，直到出现true为止将不再判断，直接得到结果为true（短路遇true就停止） 示例 逻辑或| 短路或|| PS.开发的时候用短路与&amp;&amp;和短路或||，可以减少程序运行时间","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"基本数据类型之间的转换（显式转换和隐式转换）","slug":"34","date":"2020-10-20T06:49:43.000Z","updated":"2022-04-14T02:08:29.567Z","comments":true,"path":"34.html","link":"","permalink":"https://blog.zoutl.cn/34.html","excerpt":"","text":"显式转换从表示范围大的类型转换为表示范围小的类型，需要强制转换，称为显式转换。强制类型转换的语法格式就是加一个括号，然后给出想要转换的目标类型。 例如： 12345678public static void main(String[] args) &#123; //int类型300转换成2进制为00000000 00000000 00000001 00101100 //转换成byte去掉前3个8位：00101100 //32+8+4=44 byte b1=(byte)300; //控制台输出44 System.out.println(b1);&#125; 隐式转换从表示范围小的类型转换为表示范围大的类型，可以直接转换，称为隐式转换。隐式类型转换又可以称为自动类型转换，就是由系统自动完成的类型转换 例如： 12345678910111213public static void main(String[] args) &#123; //数据类型转换之隐式转换（小的赋值给大的） //4个字节，占4个8位，int类型转换成byte时，去掉前3个8位（3个字节） int x=3; //1个字节，占1个8位，byte类型转换成int时，在前面添加3个8位（3个字节） byte b=4; /*小的数据类型和大的数据类型转换时，会将小的数据类型转换成大的数据类型， 然后再进行运算，本程序中将byte类型转换成int类型,最终结果是int类型*/ x=x+b; //控制台输出7 System.out.println(x);&#125; PS.自动类型转换规则：二元运算符连接两个值 | LeDao的博客 (zoutl.cn)","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"基本数据类型","slug":"33","date":"2020-10-20T06:30:04.000Z","updated":"2022-04-14T02:08:27.904Z","comments":true,"path":"33.html","link":"","permalink":"https://blog.zoutl.cn/33.html","excerpt":"","text":"概述在Java中一共有八种基本数据类型，他们分别是 byte、short、int、long、float、double、char、boolean 整型其中byte、short、int、long都是表示整数的，只不过他们的取值范围不一样 byte的取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1） short的取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1） int的取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1） long的取值范围为（-9223372036854774808~9223372036854774807），占用8个字节（-2的63次方到2的63次方-1） 浮点型float和double是表示浮点型的数据类型，他们之间的区别在于他们的精确度不同 float 3.402823e+38 ~ 1.401298e-45（e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方）占用4个字节 double 1.797693e+308~ 4.9000000e-324 占用8个字节 double型比float型存储范围更大，精度更高，所以通常的浮点型的数据在不声明的情况下都是double型的，如果要表示一个数据是float型的，可以在数据后面加上F。 浮点型的数据是不能完全精确的，所以有的时候在计算的时候可能会在小数点最后几位出现浮动，这是正常的。 boolean型（布尔型）这个类型只有两个值，true和false（真和非真） 12boolean t = true；boolean f = false； char型（文本型）用于存放字符的数据类型，占用2个字节，采用unicode编码，它的前128字节编码与ASCII兼容","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"EasyUI标签页右键单击事件添加","slug":"32","date":"2020-10-19T05:19:00.000Z","updated":"2022-04-14T01:40:57.307Z","comments":true,"path":"32.html","link":"","permalink":"https://blog.zoutl.cn/32.html","excerpt":"","text":"代码HTML代码123456789&lt;div id=&quot;menu&quot; class=&quot;easyui-menu&quot;&gt; &lt;div id=&quot;mm-tabrefresh&quot; data-options=&quot;name:&#x27;1&#x27;,iconCls:&#x27;icon-refresh&#x27;&quot;&gt; 刷新当前标签页&lt;/div&gt; &lt;div class=&quot;menu-sep&quot;&gt;&lt;/div&gt; &lt;div id=&quot;mm-tabclose&quot; data-options=&quot;name:&#x27;2&#x27;,iconCls:&#x27;icon-closetab&#x27;&quot;&gt;关闭当前标签页&lt;/div&gt; &lt;div id=&quot;mm-tabcloseall&quot; data-options=&quot;name:&#x27;3&#x27;,iconCls:&#x27;icon-closealltab&#x27;&quot;&gt;关闭全部标签页&lt;/div&gt; &lt;div id=&quot;mm-tabcloseother&quot; data-options=&quot;name:&#x27;4&#x27;,iconCls:&#x27;icon-closeothertab&#x27;&quot;&gt;关闭其他标签页&lt;/div&gt; &lt;div id=&quot;mm-tabcloseright&quot; data-options=&quot;name:&#x27;5&#x27;,iconCls:&#x27;icon-closerighttab&#x27;&quot;&gt;关闭右侧标签页&lt;/div&gt; &lt;div id=&quot;mm-tabcloseleft&quot; data-options=&quot;name:&#x27;6&#x27;,iconCls:&#x27;icon-closelefttab&#x27;&quot;&gt;关闭左侧标签页&lt;/div&gt;&lt;/div&gt; JavaScript代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677$(document).ready(function () &#123; // 监听右键事件，创建右键菜单 $(&#x27;#tabs&#x27;).tabs(&#123; onContextMenu: function (e, title, index) &#123; e.preventDefault(); if (index &gt; 0) &#123; $(&#x27;#menu&#x27;).menu(&#x27;show&#x27;, &#123; left: e.pageX, top: e.pageY &#125;).data(&quot;tabTitle&quot;, title); &#125; &#125; &#125;); // 右键菜单click $(&quot;#menu&quot;).menu(&#123; onClick: function (item) &#123; closeTab(this, item.name); &#125; &#125;); function closeTab(menu, type) &#123; var allTabs = $(&quot;#tabs&quot;).tabs(&#x27;tabs&#x27;); var allTabtitle = []; $.each(allTabs, function (i, n) &#123; var opt = $(n).panel(&#x27;options&#x27;); if (opt.closable) allTabtitle.push(opt.title); &#125;); var curTabTitle = $(menu).data(&quot;tabTitle&quot;); var curTabIndex = $(&quot;#tabs&quot;).tabs(&quot;getTabIndex&quot;, $(&quot;#tabs&quot;).tabs(&quot;getTab&quot;, curTabTitle)); switch (type) &#123; case &quot;1&quot;: // 刷新当前标签页 var currentTab = $(&#x27;#tabs&#x27;).tabs(&#x27;getSelected&#x27;); var url = $(currentTab.panel(&#x27;options&#x27;)).attr(&#x27;href&#x27;); $(&#x27;#tabs&#x27;).tabs(&#x27;update&#x27;, &#123; tab: currentTab, options: &#123; href: url &#125; &#125;); currentTab.panel(&#x27;refresh&#x27;); // var panel = $(&quot;#tabs&quot;).tabs(&quot;getTab&quot;, curTabTitle).panel(&quot;refresh&quot;); break; case &quot;2&quot;: // 关闭当前标签页 $(&quot;#tabs&quot;).tabs(&quot;close&quot;, curTabIndex); return false; break; case &quot;3&quot;: // 关闭全部标签页 for (var i = 0; i &lt; allTabtitle.length; i++) &#123; $(&#x27;#tabs&#x27;).tabs(&#x27;close&#x27;, allTabtitle[i]); &#125; break; case &quot;4&quot;: // 关闭其他标签页 for (var i = 0; i &lt; allTabtitle.length; i++) &#123; if (curTabTitle != allTabtitle[i]) $(&#x27;#tabs&#x27;).tabs(&#x27;close&#x27;, allTabtitle[i]); &#125; $(&#x27;#tabs&#x27;).tabs(&#x27;select&#x27;, curTabTitle); break; case &quot;5&quot;: // 关闭右侧标签页 for (var i = curTabIndex; i &lt; allTabtitle.length; i++) &#123; $(&#x27;#tabs&#x27;).tabs(&#x27;close&#x27;, allTabtitle[i]); &#125; $(&#x27;#tabs&#x27;).tabs(&#x27;select&#x27;, curTabTitle); break; case &quot;6&quot;: // 关闭左侧标签页 for (var i = 0; i &lt; curTabIndex - 1; i++) &#123; $(&#x27;#tabs&#x27;).tabs(&#x27;close&#x27;, allTabtitle[i]); &#125; $(&#x27;#tabs&#x27;).tabs(&#x27;select&#x27;, curTabTitle); break; &#125; &#125;&#125;); 结果截图","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"EasyUI","slug":"EasyUI","permalink":"https://blog.zoutl.cn/tags/EasyUI/"}]},{"title":"IntelliJ IDEA中Git版本回退","slug":"31","date":"2020-10-17T18:07:49.000Z","updated":"2022-04-14T02:43:34.361Z","comments":true,"path":"31.html","link":"","permalink":"https://blog.zoutl.cn/31.html","excerpt":"","text":"查看历史版本右键点击项目，选择Git的Show History 选择目标版本右键点击要回退的目标代码版本，选择Copy Revision Number（复制代码版本的版本号） 目标版本代码的版本号：a9431f9ccc6eceb67693ad0f706877dd54347bde 当前版本代码的版本号：573161acd112e954813933bccee221ca3e6f5aec 开始回退右键点击项目，依次选中Git-&gt;Repository-&gt;Reset HEAD Reset Type选择Hard，To Commit输入要回退的目标版本号，然后点击Reset即可回退到目标代码版本","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"}]},{"title":"IntelliJ IDEA彻底删除一个项目","slug":"30","date":"2020-10-17T17:15:10.000Z","updated":"2022-04-14T02:44:52.072Z","comments":true,"path":"30.html","link":"","permalink":"https://blog.zoutl.cn/30.html","excerpt":"","text":"删除Module在idea的project栏中右键点击项目,选择Remove Module 在确认框中点击Remove，删除后项目文件还会有残余 删除文件右键点击pom.xml，然后选择Show in Explorer（为了快速找到项目文件的文件夹），把文件夹中的文件都删除掉即可（在手动删除文件之前，先选择 IDEA 的 File 菜单，选择Close Project关闭项目,然后在项目所在路径删除项目的文件夹）","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IntelliJ IDEA连接MySQL数据库","slug":"29","date":"2020-10-17T16:41:37.000Z","updated":"2022-04-14T02:43:30.913Z","comments":true,"path":"29.html","link":"","permalink":"https://blog.zoutl.cn/29.html","excerpt":"","text":"选择数据库类型 填写配置信息URL填：jdbc:mysql://localhost:3306/db_myblog?serverTimezone=UTC 测试是否连接成功点击上图的Test Connection按钮测试是否可以成功连接,成功后点击OK即可","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"IntelliJ IDEA创建Spring Boot项目","slug":"28","date":"2020-10-17T16:02:11.000Z","updated":"2022-04-14T02:43:26.408Z","comments":true,"path":"28.html","link":"","permalink":"https://blog.zoutl.cn/28.html","excerpt":"","text":"选择项目的类别 选择环境 选择技术选择项目开发需要用到的技术 填写项目的名称填写项目的名称以及项目路径，即可完成Spring Boot项目的创建","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"MySQL单表查询","slug":"27","date":"2020-10-16T17:18:33.000Z","updated":"2022-04-14T02:34:41.586Z","comments":true,"path":"27.html","link":"","permalink":"https://blog.zoutl.cn/27.html","excerpt":"","text":"查询全部表数据12#可以不按顺序SELECT id,stuName,age,sex,gradeName FROM t_student; 1SELECT * FROM t_student; 查询指定表数据1SELECT stuName,gradeName FROM t_student; 查询表数据语句： 12#id为1SELECT * FROM t_student WHERE id=1; 12#年龄大于24SELECT * FROM t_student WHERE age&gt;24; 12#年龄是21，23，24的SELECT * FROM t_student WHERE age IN(21,23,24); 12#年龄不是21，23，24的SELECT * FROM t_student WHERE age NOT IN(21,23,24); 12#年龄在21和24之间的，包括SELECT * FROM t_student WHERE age BETWEEN 21 AND 24; 12#年龄不在21和24之间的，包括SELECT * FROM t_student WHERE age NOT BETWEEN 21 AND 24;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL对表数据进行增删改查","slug":"26","date":"2020-10-16T17:08:47.000Z","updated":"2022-04-14T02:34:44.056Z","comments":true,"path":"26.html","link":"","permalink":"https://blog.zoutl.cn/26.html","excerpt":"","text":"插入1INSERT INTO `db_student`.`t_student` (`id`, `stuName`, `age`, `sex`, `gradeName`)VALUES(&#x27;15&#x27;,&#x27;tom&#x27;, &#x27;22&#x27;, &#x27;男&#x27;, &#x27;大四&#x27;); 删除1DELETE FROM `db_student`.`t_student` WHERE `id`=&#x27;16&#x27;; 修改1UPDATE `db_student`.`t_student` SET `sex`=&#x27;男&#x27;,`gradeName`=&#x27;大四&#x27; WHERE `id`=&#x27;16&#x27;; 查找1SELECT * FROM db_miaosha.`t_user` WHERE id=14;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"MySQL创建表语句","slug":"25","date":"2020-10-16T17:04:14.000Z","updated":"2022-04-14T02:34:48.777Z","comments":true,"path":"25.html","link":"","permalink":"https://blog.zoutl.cn/25.html","excerpt":"","text":"创建表主键：primary key，自增：auto_increment 123456789CREATE TABLE t_bookType( id INT PRIMARY KEY AUTO_INCREMENT, bookTypeName VARCHAR(20), bookTypeDesc VARCHAR(200) ); 123456789101112131415CREATE TABLE t_book( id INT PRIMARY KEY AUTO_INCREMENT, bookName VARCHAR(20), author VARCHAR(10), price DECIMAL(6,2), bookTypeId INT, CONSTRAINT `fk` FOREIGN KEY (`bookTypeId`) REFERENCES `t_bookType`(`id`) ); 查看表结构1DESC 表名; 查看表的创建语句1SHOW CREATE TABLE 表名; 修改表名1ALTER TABLE t_book RENAME t_book2; 修改字段更改后的名字 数据类型（长度） 1ALTER TABLE t_book CHANGE bookName bookName2 VARCHAR(20); 在第一行添加字段1ALTER TABLE t_book ADD test INT FIRST; 在某个字段后添加字段1ALTER TABLE t_book ADD test1 INT after author; 删除字段1ALTER TABLE t_book DROP test; 删除表有外键约束的要先删除完子表，才能删除主表 1DROP TABLE t_book;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"}]},{"title":"cmd命令操作MySQL数据库","slug":"24","date":"2020-10-16T17:00:01.000Z","updated":"2022-04-14T02:34:51.708Z","comments":true,"path":"24.html","link":"","permalink":"https://blog.zoutl.cn/24.html","excerpt":"","text":"进入数据库命令行先进入数据库安装的盘符（如果要进入C盘根目录则连续敲两下命令cd .. ） 1d: 然后进入数据库安装目录的bin文件 1cd QQ\\mysql_5.6.24_winx64\\mysql-5.6.24-winx64\\bin 输入命令： 1mysql -u root -p 输入MySQL密码即可操作数据库 命令查看已有数据库1SHOW DATABASES; 创建数据库1CREATE DATABASE 数据库名； 删除数据库1DROP DATABASE 数据库名； 使用数据库1USE 数据库名; 查看已有的表1SHOW TABLES;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"cmd","slug":"cmd","permalink":"https://blog.zoutl.cn/tags/cmd/"}]},{"title":"宠物医院管理系统","slug":"23","date":"2020-10-15T16:32:21.000Z","updated":"2022-04-11T13:08:03.901Z","comments":true,"path":"23.html","link":"","permalink":"https://blog.zoutl.cn/23.html","excerpt":"","text":"项目地址GitHub地址：https://github.com/a6678696/PetHospital 使用的技术本项目核心技术采用Spring Boot+Mybatis；开发工具idea；数据库MySQL5.6；模版引擎采用的是Thymeleaf；安全框架采用Shiro，实现了完整权限系统，Controller方法采用Shiro注解来实现有效的权限控制；前台界面采用了Bootstrap技术；后台界面采用了EasyUI技术； 功能介绍本系统前台面向的用户是客户，客户可以进行预约、浏览医院发布的文章、进入医院商城为宠物购物、如有疑问可以向官方留言、还可以查看关于自己的所有记录信息，如：看病记录、预约记录、疫苗注射记录等。后台面向的用户是医院人员，系统管理员拥有最高权限，可以对所有数据进行管理，为所有的角色分配权限以及创建角色；业务管理员的权限主要是对一些常用数据的维护；医生可以接受客户发布的预约医生的预约单以及处理属于自己的预约单，回答客户的问诊；美容师可以接受客户发布的预约美容的预约单以及处理属于自己的预约单。 本系统的详细功能需求如下所示 未注册用户非注册用户（即游客身份）进入医院官网首页，可以浏览关于医院的宣传以及医院发布的文章，进入医院商城浏览正在发售的商品，搜索已发布的文章和商品，注册以及登录。 已注册用户注册用户可以修改个人信息和宠物信息，发布预约单（预约医生和美容师），在医院的商城购物，收藏商品，给官方留言，查看与自己相关的记录信息，如：病例记录、预约记录、问诊记录、订单记录等，注销退出系统。 医生医生可以查看并接受客户发布的未被处理的预约医生的预约单，结束属于自己的预约单，回复客户的网上问诊以及查看自己回复的问诊记录，修改个人密码，安全退出系统。 美容师美容师可以查看并接受客户发布的未被处理的预约美容师的预约单，结束属于自己的预约单。 业务管理员业务管理员具有进货管理（包括进货入库、退货出库、进货单据查询、退货单据查询以及当前库存查询）、销售管理（包括销售出库、客户退货入库、销售单据查询、退货单据查询）、库存管理（包括商品报损、商品报溢、库存报警、报损报溢记录查询）、查看统计数据（供应商进退货单统计、客户进退货单统计、按日统计销售利润、按月统计销售利润）、供应商管理、客户管理、商品管理、期初库存管理、前台轮播图管理、设备类型管理、设备管理、设备使用管理、设备使用记录管理、文章类型管理、文章管理、客户留言管理、医院用品管理、医院用品出入库管理、医院用品出入库记录管理、客户消息管理、客户订单处理、客户预约单管理、客户问诊记录管理、病历单管理、化验记录管理、疫苗注射记录管理、客户回访记录管理、寄养记录管理、修改密码、安全退出系统。 系统管理员系统管理员除了具备业务管理员的所有权限外，还有创建角色并赋予角色权限的功能，还可以查看系统操作日志。 系统自身系统每天0点自动创建明天的分别属于各个医生或美容师各个时间段的空预约单（未被客户接受的预约单）、每分钟自动筛选出5分钟后过期的空预约单并从数据库删除、每分钟自动筛选和取消客户提交的超过一天未支付的订单并释放库存、每天凌晨1点自动将发布日期超过3个月的商品的”新品”标签去掉、医院上班后（8点）系统自动给当天有预约的客户发送提醒消息 图片展示前台首页 客户登录界面 客户注册页面 医院商城首页 查看商品详情 查看已收货客户评论 商品推荐和浏览记录 购物车 订单成功提交 支付订单 查看订单详情 查看全部订单 查看已收藏商品 个人中心功能列表 查看可预约医生 预约医生 按类别查看文章 查看文章详情 客户留言 后台后台登录 管理员功能介绍","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"IntelliJ IDEA Maven工具栏按钮的作用","slug":"22","date":"2020-10-15T05:58:20.000Z","updated":"2022-04-14T02:45:19.656Z","comments":true,"path":"22.html","link":"","permalink":"https://blog.zoutl.cn/22.html","excerpt":"","text":"clean清理，在进行真正的构建之前进行一些清理工作，移除所有上一次构建生成的文件。执行该命令会删除项目路径下的target文件，但是不会删除本地的maven仓库已经生成的jar文件 validate验证，验证工程是否正确，所需的信息是否完整 compile编译源码，编译生成class文件，编译命令，只编译选定的目标，不管之前是否已经编译过，会在你的项目路径下生成一个target目录，在该目录中包含一个classes文件夹，里面全是生成的class文件及字节码文件 test单元测试，测试 package打包，将工程文件打包为指定的格式，例如JAR，WAR等。这个命令会在你的项目路径下一个target目录，并且拥有compile命令的功能进行编译，同时会在target目录下生成项目的jar/war文件。如果a项目依赖于b项目，打包b项目时，只会打包到b项目下target下，编译a项目时就会报错，因为找不到所依赖的b项目，说明a项目在本地仓库是没有找到它所依赖的b项目，这时就用到install命令了 verify核实，检查package是否有效、符合标准 install安装至本地仓库，将包安装至本地仓库，以让其它项目依赖。该命令包含了package命令功能，不但会在项目路径下生成class文件和jar包，同时会在你的本地maven仓库生成jar文件，供其他项目使用（如果没有设置过 maven本地仓库，一般在用户/.m2目录下。如果a项目依赖于b项目，那么install b项目时，会在本地仓库同时生成pom文件和jar文件，解决了上面打包package出错的问题） build功能类似compile，只是只对整个项目进行编译 site站点，生成项目的站点文档 deploy复制到远程仓库","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"idea将Spring Boot项目打包成war包","slug":"21","date":"2020-10-15T03:55:02.000Z","updated":"2022-04-14T02:45:30.518Z","comments":true,"path":"21.html","link":"","permalink":"https://blog.zoutl.cn/21.html","excerpt":"","text":"修改pom.xml文件修改打包方式修改pom.xml的packaging节点改 war 1&lt;packaging&gt;war&lt;/packaging&gt; 排除Tomcat容器排除Spring Boot内置的Tomcat容器 12345678910111213141516171819&lt;!--移除嵌入式tomcat插件--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--移除嵌入式tomcat插件--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--servlet-api的依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 修改finalName节点修改打包后的war包名（finalName节点） 123456789&lt;build&gt; &lt;finalName&gt;JXC&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 实现configure方法启动类继承SpringBootServletInitializer类并实现configure方法 12345678910111213141516/** * @author LeDao */@SpringBootApplication@MapperScan(&quot;com.ledao.mapper&quot;)public class MyblogApplication extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(MyblogApplication.class); &#125; public static void main(String[] args) &#123; SpringApplication.run(MyblogApplication.class, args); &#125;&#125; 打包用idea打包，点击idea的Maven图形界面的package","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"进制","slug":"20","date":"2020-10-13T05:27:29.000Z","updated":"2022-04-14T02:08:09.618Z","comments":true,"path":"20.html","link":"","permalink":"https://blog.zoutl.cn/20.html","excerpt":"","text":"十进制我们平时所有的数字就是十进制 二进制用 0 和 1 表示 进制转换二进制转换成十进制 整数二进制转化为十进制 方法：“按权展开求和”，该方法的具体步骤是先将二进制的数写成加权系数展开式，而后根据十进制的加法规则进行求和 规律：个位上的数字的次数是0，十位上的数字的次数是1，……，依次递增，而十分位的数字的次数是-1，百分位上数字的次数是-2，……，依次递减 例如：二进制整数11001=1*2^4 + 1*2^3 + 0*2^2 + 0*2^1 + 1*2^0=25 小数二进制转化为十进制 二进制小bai数的位权从小数点向右依次为-1、-2、-3……，按照这个du位权计算就可以zhi得到十进制小数 例如：二进制小数0.1011=1*2^(-1) + 0*2^(-2) + 1*2^(-3) + 1*2^(-4)=0.6875 十进制转换成二进制一个十进制数转换为二进制数要分整数部分和小数部分分别转换，最后再组合到一起 整数十进制转换成二进制 整数部分采用 “除2取余，逆序排列”法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来 小数十进制转换成二进制 小数部分要使用“乘 2 取整法”。即用十进制的小数乘以 2 并取走结果的整数(必是 0 或 1)，然后再用剩下的小数重复刚才的步骤，直到剩余的小数为 0 时停止，最后将每次得到的整数部分按先后顺序从左到右排列即得到所对应二进制小数。","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"}]},{"title":"常量","slug":"19","date":"2020-10-13T04:32:39.000Z","updated":"2022-04-14T02:08:07.205Z","comments":true,"path":"19.html","link":"","permalink":"https://blog.zoutl.cn/19.html","excerpt":"","text":"定义常量表示不能改变的数值 分类整数常量所有整数 小数常量所有小数 布尔（boolean）型常量只有两个数值，true、false 字符常量将一个数字字母或者符号用单引号（ ‘ ‘ ）标识，如：’a’ 字符串常量将一个或者多个字符用双引号（””）标识，如：”hello world”、”a”、””（空字符串）。 null常量只有一个数值就是：null","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"注释","slug":"18","date":"2020-10-13T03:59:13.000Z","updated":"2022-04-14T02:08:04.177Z","comments":true,"path":"18.html","link":"","permalink":"https://blog.zoutl.cn/18.html","excerpt":"","text":"单行注释格式： //注释文字 多行注释格式： /* 注释文字 */ 文档注释格式：/** 注释文字 */ PS. 对于单行和多行注释，被注释的文字，不会被JVM（Java虚拟机）解释执行。所以，即使添加再多的注释，编译后生成的class文件占用硬盘字节多少不变 对于文档注释，是Java特有的注释，其中注释内容可以被JDK提供的工具Javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档 注释是一个程序员必须要具有的良好编程习惯，初学者编写程序必须养成习惯：先写注释再写代码 将自己的思想通过注释先整理出来，再用代码去体现，因为代码仅仅是思想的一种体现形式而已","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"阿里云设置二级域名","slug":"17","date":"2020-10-11T10:31:00.000Z","updated":"2022-03-26T07:42:59.190Z","comments":true,"path":"17.html","link":"","permalink":"https://blog.zoutl.cn/17.html","excerpt":"","text":"进入控制台在阿里云官网登录后，点击右上角的控制台 进入域名管理界面点击左侧菜单的域名 解析域名 点击添加记录（主机记录为我们二级域名所要设置的名称，记录值为阿里云本机的 id，其它的值根据图片设置即可）","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"阿里云","slug":"阿里云","permalink":"https://blog.zoutl.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"一个Tomcat部署多个项目以及配置域名","slug":"16","date":"2020-10-11T10:17:48.000Z","updated":"2022-04-14T02:40:47.770Z","comments":true,"path":"16.html","link":"","permalink":"https://blog.zoutl.cn/16.html","excerpt":"","text":"首先找到服务器Tomcat的server.xml配置，然后在原来的基础上，多复制一份Host节点，然后 name 改成我们需要设置的域名以及Context节点对应好项目路径即可 1234567891011&lt;Host name=&quot;jxc.zoutl.cn&quot; appBase=&quot;webapps&quot; unpackWARs=&quot;true&quot;&gt; &lt;Context path=&quot;&quot; docBase=&quot;/home/tomcat9/apache-tomcat-9.0.46/webapps/JXC&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; /&gt; &lt;!-- SingleSignOn valve, share authentication between web applications Documentation at: /docs/config/valve.html --&gt; &lt;!--&lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;--&gt; &lt;!-- Access log processes all example. Documentation at: /docs/config/valve.html Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt; &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;&lt;/Host&gt;","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"}]},{"title":"Windows10系统定时关机cmd命令","slug":"15","date":"2020-10-10T17:17:42.000Z","updated":"2022-04-14T02:02:56.614Z","comments":true,"path":"15.html","link":"","permalink":"https://blog.zoutl.cn/15.html","excerpt":"","text":"定时关机1shutdown -s -t 7200 最后面的数字为秒,一小时等于 3600 秒 取消定时关机1shutdown /a","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"},{"name":"cmd","slug":"cmd","permalink":"https://blog.zoutl.cn/tags/cmd/"}]},{"title":"Spring Boot2.0实现自定义404页面渲染","slug":"14","date":"2020-10-10T16:59:51.000Z","updated":"2022-04-14T02:07:59.371Z","comments":true,"path":"14.html","link":"","permalink":"https://blog.zoutl.cn/14.html","excerpt":"","text":"第一种写法实现ErrorPageRegistrar，404.html放在项目的webapp文件夹中 123456789101112@Configurationpublic class ErrorPageConfig implements ErrorPageRegistrar &#123; @Override public void registerErrorPages(ErrorPageRegistry registry) &#123; ErrorPage[] errorPages = new ErrorPage[2]; errorPages[0] = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/404.html&quot;); errorPages[1] = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/500.html&quot;); registry.addErrorPages(errorPages); &#125;&#125; 第二种写法Spring Boot2.0 之后的写法，404.html文件放在resources的static文件夹中 123456789101112@Configurationpublic class ErrorPageConfig &#123; @Bean public WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; //第二种写法：java8 lambda写法 return (factory -&gt; &#123; ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/404.html&quot;); factory.addErrorPages(errorPage404); &#125;); &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"}]},{"title":"进销存系统","slug":"13","date":"2020-10-10T12:36:38.000Z","updated":"2022-03-26T07:33:18.297Z","comments":true,"path":"13.html","link":"","permalink":"https://blog.zoutl.cn/13.html","excerpt":"","text":"项目地址GitHub地址：https://github.com/a6678696/JXC 使用的技术本系统使用Spring Boot架构，数据访问层采用Spring Data Jpa，安全框架采用Shiro，实现了完整权限系统，Controller方法采用Shiro注解，来实现有效的权限控制；界面采用了EasyUI技术； 功能介绍进货管理（进货入库、退货出库、进货单据查询、退货单据查询、当前库存查询）、销售管理（销售出库、客户退货、销售单据查询、客户退货查询）、库存管理（商品报损、商品报溢、库存报警、报损报溢查询）、统计报表（供应商进退货单统计、客户进退货单统计、按日统计销售利润、按月统计销售利润）、供应商管理、客户管理、商品管理、期初库存管理、权限管理模块（角色管理、用户管理）、查看系统日志、修改密码、安全退出 图片展示首页 公司进货入库 公司退货出库 公司进货单据查询 公司退货单据查询 商品销售出库 客户退货 销售单据查询 客户退货单据查询 商品报损商品过期、受潮等 商品报溢商品实际数量比记录的数量少，可能是初期记录失误，实际与记录相差的数量 库存报警当商品的当前库存&lt;库存下限 报损报溢记录查询 公司进货退货记录查询 销售和客户退货记录查询 公司进货和退货的商品明细 商品销售和客户退货明细 按日统计利润 按月统计利润 供应商管理 客户管理 商品管理 设置商品的库存新添加的商品的数量为0 给角色赋予权限 给用户赋予角色 查看系统日志 修改密码 安全退出系统","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"Github私有仓库改为公开","slug":"11","date":"2020-10-10T12:32:06.000Z","updated":"2022-04-14T01:54:37.001Z","comments":true,"path":"11.html","link":"","permalink":"https://blog.zoutl.cn/11.html","excerpt":"","text":"打开设置 进入该仓库所在首页，找到Settings并点击（在首页的菜单栏） 修改仓库visibility属性 在出现的页面找到 Danger Zone（在最下面），点击 Change visibility 按钮 然后选择Make public，并根据提示输入指定内容，点击同意按钮，然后输入 GitHub 账号的密码即可修改完成","categories":[{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"}]},{"title":"个人博客系统","slug":"12","date":"2020-10-10T11:33:39.000Z","updated":"2022-03-26T07:33:13.086Z","comments":true,"path":"12.html","link":"","permalink":"https://blog.zoutl.cn/12.html","excerpt":"","text":"项目地址GitHub地址：https://github.com/a6678696/MyBlog 项目演示地址：http://www.zoutl.cn/ 使用的技术本项目核心技术采用Spring Boot+Mybatis；开发工具idea；数据库 MySQL5.6；模版引擎采用的是Thymeleaf；安全框架采用SpringSecurity；在线编辑器CKEditor；Lucene全文检索；Quartz定时任务；基于JavaMail实现用QQ邮箱发送邮件 ；highlight.js代码高亮；Highcharts图表；Redis存储经常查看的数据； 功能介绍前台主页分页展示所有博客、按类别分类博客、按日期分类博客、查看博客内容详情、Lucene全文检索博客标题和摘要、点赞博客、评论博客、网站数据展示 后台写博客、博客类别管理、博客管理、安全退出、每天23点定时删除无效的博客图片（删除的博客但未删除其引用的图片）、查看访问记录、一键切换前台UI（一共有4套UI，下面展示的是第二套）、评论管理（删除、审核、回复）、查看点赞记录、友情链接管理、一键备份数据以及每天23点定时备份数据（包括数据库、博客正文图片、Lucene索引）、有人留言自动给站长发邮件、一键设置邮件提醒与否、系统自动封禁ip、封禁ip管理、highlight.js代码高亮、后台修改代码风格、每日访问ip个数统计、每日访问数统计 图片展示前台博客首页 按博客类别分类 查看博客详情页面 搜索博客 发表评论 被封禁后的访问界面 后台管理员登陆 后台首页 写博客 博客类别管理 博客管理 评论管理 ip封禁管理 查看点赞记录 查看访问记录 每日访问ip个数统计 每日被访问次数统计 切换前台UI 一键备份数据 设置邮件提醒与否 后台修改代码风格 安全退出后台","categories":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"}]},{"title":"Tomcat运行web项目不带项目名字","slug":"9","date":"2020-10-10T10:10:11.000Z","updated":"2022-04-14T02:40:44.974Z","comments":true,"path":"9.html","link":"","permalink":"https://blog.zoutl.cn/9.html","excerpt":"","text":"概述默认情况下，项目发布到 Tomcat ，要运行项目，浏览器访问路径是这样的： http://localhost:8080/MyBlog 改端口首先在 Tomcat 安装目录的 config 文件夹中找到 server.xml ，然后找到如下代码并将端口 8080 改为 80 ，这样我们访问项目时就不需要加端口号了，访问路径为：http://localhost/MyBlog ，也可以加上端口号80，不过一般都是省略掉的 修改前： 1&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改后： 1&lt;Connector port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改访问路径然后在最下面继续找到 Host 节点，在里面添加如下代码（路径为 webapps 中项目的路径）： 1&lt;Context path=&quot;&quot; docBase=&quot;F:\\java\\apache-tomcat-9.0.22-windows-x64\\apache-tomcat-9.0.22\\webapps\\MyBlog&quot; debug=&quot;0&quot; reloadable=&quot;true&quot; /&gt; 最后的访问路径为：http://localhost","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"}]},{"title":"用Tomcat运行web项目","slug":"10","date":"2020-10-10T10:07:13.000Z","updated":"2022-04-14T02:40:54.845Z","comments":true,"path":"10.html","link":"","permalink":"https://blog.zoutl.cn/10.html","excerpt":"","text":"复制项目到webapps文件夹将项目（war包）复制到Tomcat安装目录的webapps文件夹中 启动Tomcat然后去bin文件夹中,点击startup.bat即可启动Tomcat运行项目 关闭Tomcat点击bin文件夹中的shutdown.bat关闭Tomcat","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"}]},{"title":"标识符","slug":"8","date":"2020-10-10T06:21:01.000Z","updated":"2022-04-14T02:07:47.602Z","comments":true,"path":"8.html","link":"","permalink":"https://blog.zoutl.cn/8.html","excerpt":"","text":"定义在程序中自定义的一些名称，例如：类名 特点由 26 个英文字母大小写，数字：0-9，符号：_、$组成 定义合法标识符规则 数字不可以开头，例如：2Demo 就不可以。 不可以使用关键字，例如：public 就不可以，因为 public 是关键字 不可以包含“_、$”以外的特殊符号，例如：“Demo Test”就不可以，其中的空格就是特殊符号 Java中的名称规范包名多单词组成时所有字母都小写 例如：xxxyyyzzz 类名接口名多单词组成时，所有单词的首字母大写 例如：XxxYyyZzz 变量名和函数名多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写 例如：xxxYyyZzz 常量名所有字母都大写，多单词时每个单词用下划线连接 例如：XXX_YYY_ZZZ PS. Java中严格区分大小写 在起名字时，为了提高阅读性，要尽量有意义 公司中经常会通过“_”代表某一类名称，例如：_temp 通过“$”分隔主名称与子名称，例如：TrafficLamp$Red","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java中的关键字","slug":"7","date":"2020-10-10T06:03:27.000Z","updated":"2022-04-14T02:07:43.275Z","comments":true,"path":"7.html","link":"","permalink":"https://blog.zoutl.cn/7.html","excerpt":"","text":"定义被 Java 语言赋予了特殊含义的单词 特点关键字中所有字母都为小写 列举","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"CKEditor上传图片","slug":"6","date":"2020-10-10T05:55:31.000Z","updated":"2022-04-14T01:39:24.857Z","comments":true,"path":"6.html","link":"","permalink":"https://blog.zoutl.cn/6.html","excerpt":"","text":"引入commons-io依赖12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 修改config.js文件在 ckeditor 文件夹中找到 config.js 文件，设置上传图片的请求地址，参考代码如下 12345678CKEDITOR.editorConfig = function (config) &#123; // Define changes to default configuration here. For example: // config.language = &#x27;fr&#x27;; //编辑器颜色 config.uiColor = &#x27;#daeef5&#x27;; //上传图片路径 config.filebrowserUploadUrl = &quot;/ckeditorUpload&quot;;&#125;; Java代码123456789101112131415161718192021222324/** * ckeditor上传图片 * * @param file * @param CKEditorFuncNum * @return * @throws Exception */@ResponseBody@RequestMapping(&quot;/ckeditorUpload&quot;)public String ckeditorUpload(@RequestParam(&quot;upload&quot;) MultipartFile file, String CKEditorFuncNum) throws Exception &#123; // 获取文件名 String fileName = file.getOriginalFilename(); // 获取文件的后缀 String suffixName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //拼接新的文件名 String newFileName = DateUtil.getCurrentDateStr2() + System.currentTimeMillis() + &quot;.jpg&quot;; FileUtils.copyInputStreamToFile(file.getInputStream(), new File(articleImageFilePath + &quot;/&quot; + newFileName1)); StringBuffer sb = new StringBuffer(); sb.append(&quot;&lt;script type=\\&quot;text/javascript\\&quot;&gt;&quot;); sb.append(&quot;window.parent.CKEDITOR.tools.callFunction(&quot; + CKEditorFuncNum + &quot;,&#x27;&quot; + &quot;/static/images/articleImage/&quot; + newFileName + &quot;&#x27;,&#x27;&#x27;)&quot;); sb.append(&quot;&lt;/script&gt;&quot;); return sb.toString();&#125; 上传步骤 在 CKEditor 编辑器工具栏找到图像按钮并点击 选择上传标签页，选择文件并上传到服务器 选择图片要显示的尺寸，并点击确定即可完成图片上传","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CKEditor","slug":"CKEditor","permalink":"https://blog.zoutl.cn/tags/CKEditor/"},{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"IntelliJ IDEA连接数据库报错及解决","slug":"5","date":"2020-10-10T05:37:42.000Z","updated":"2022-04-14T02:46:10.940Z","comments":true,"path":"5.html","link":"","permalink":"https://blog.zoutl.cn/5.html","excerpt":"","text":"概述问题使用JDBC连接MySQL时出现下面错误： The server time zone value ‘�й���׼ʱ��’ is unrecognizedor representsmore than one timezone. You must configure either the server or JDBC driver(via the serverTimezone configuration 原因发现这是因为安装MySQL的时候时区设置地不正确，MySQL默认的是美国的时区，而我们中国大陆要比他们迟8小时，采用+8:00格式。在你没有指定MySQL驱动版本的情况下它自动依赖的驱动是8.0.12很高的版本，这是由于数据库和系统时区差异所造成的，在JDBC连接的url后面加上 serverTimezone=GMT 即可解决问题，如果需要使用 gmt+8 时区，需要写成 GMT%2B8 ，否则会被解析为空。再一个解决办法就是使用低版本的 MySQL JDBC 驱动，5.1.28 不会存在时区的问题。 解决办法在连接字符串后面加上 serverTimezone=GMT%2B8 ，其中GMT是格林威治平时，也称格林威治时间（它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点），完整的连接字符串示例如下： 1jdbc:mysql://localhost:3306/db_secondhandtrade?serverTimezone=GMT%2B8 如果要解决中文乱码输入问题，则加上useUnicode=true&amp;characterEncoding=utf8，完整字符串如下： 1jdbc:mysql://localhost:3306/db_secondhandtrade?useUnicode=true&amp;characterEncoding=utf8 一般都是两者一起使用，完整字符串如下： 1jdbc:mysql://localhost:3306/db_secondhandtrade?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8 idea连接MySQL界面如下：","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]},{"title":"常用cron表达式","slug":"4","date":"2020-10-10T05:34:20.000Z","updated":"2022-03-26T06:58:46.560Z","comments":true,"path":"4.html","link":"","permalink":"https://blog.zoutl.cn/4.html","excerpt":"","text":"表达式 说明 */5 * * * * ? 表示每5秒触发 0 */1 * * * ? 表示每隔1分钟执行一次 0 0 23 * * ? 表示每天23点执行一次 0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行 0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 0 0 12 ? * WED 表示每个星期三中午12点 0 0 12 * * ? 每天中午12点触发 0 15 10 ? * * 每天上午10:15触发 0 15 10 * * ? 2005 2005年的每天上午10:15触发 0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 0 15 10 15 * ? 每月15日上午10:15触发 0 15 10 L * ? 每月最后一日的上午10:15触发 0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发","categories":[{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"}],"tags":[{"name":"cron","slug":"cron","permalink":"https://blog.zoutl.cn/tags/cron/"}]},{"title":"第一个Java程序:HelloWorld","slug":"3","date":"2020-10-10T04:59:29.000Z","updated":"2022-04-14T02:07:38.693Z","comments":true,"path":"3.html","link":"","permalink":"https://blog.zoutl.cn/3.html","excerpt":"","text":"Java代码12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125; 运行结果","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"Java环境配置","slug":"2","date":"2020-10-10T04:31:46.000Z","updated":"2022-04-14T02:23:44.201Z","comments":true,"path":"2.html","link":"","permalink":"https://blog.zoutl.cn/2.html","excerpt":"","text":"安装JDK网上有很多教程，这里就不说明了 配置Java环境右击”我的电脑”，点击”属性”，选择”高级系统设置” 配置变量：JAVA_HOME本地JDK安装路径 1F:\\java\\jdk1.8.0_92 配置变量：classpath1.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 配置变量：Path12F:\\java\\jdk1.8.0_92\\binF:\\java\\jre\\bin 测试JDK是否安装成功打开cmd快捷键：win+R，输入CMD 输入下面的命令键入命令: java -version、java、javac 几个命令，出现以下信息，说明环境变量配置成功；","categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"}]},{"title":"IntelliJ IDEA快捷键大全","slug":"1","date":"2020-10-09T16:41:50.000Z","updated":"2022-04-14T02:46:48.568Z","comments":true,"path":"1.html","link":"","permalink":"https://blog.zoutl.cn/1.html","excerpt":"","text":"Alt 快捷键 介绍 Alt + ` 显示版本控制常用操作菜单弹出层 Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息 Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层 Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示 Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方 Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果 Alt + Home 定位 / 显示到当前文件的 Navigation Bar Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备） Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 Alt + 左方向键 按左方向切换当前已打开的文件视图 Alt + 右方向键 按右方向切换当前已打开的文件视图 Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置 Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置 Alt + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多 Ctrl 快捷键 介绍 Ctrl + F 在当前文件进行文本查找 （必备） Ctrl + R 在当前文件进行文本替换 （必备） Ctrl + Z 撤销 （必备） Ctrl + Y 删除光标所在行 或 删除选中的行 （必备） Ctrl + X 剪切光标所在行 或 剪切选择内容 Ctrl + C 复制光标所在行 或 复制选择内容 Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备） Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备） Ctrl + E 显示最近打开的文件记录列表 Ctrl + N 根据输入的 类名 查找类文件 Ctrl + G 在当前文件跳转到指定行处 Ctrl + J 插入自定义动态代码模板 Ctrl + P 方法参数提示显示 Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容 Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义 Ctrl + B 进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击 Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用 Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用 Ctrl + H 显示当前类的层次结构 Ctrl + O 选择可重写的方法 Ctrl + I 选择可继承的方法 Ctrl + + 展开代码 Ctrl + - 折叠代码 Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备） Ctrl + [ 移动光标到当前所在代码的花括号开始位置 Ctrl + ] 移动光标到当前所在代码的花括号结束位置 Ctrl + F1 在光标所在的错误代码出显示错误信息 Ctrl + F3 调转到所选中的词的下一个引用位置 Ctrl + F4 关闭当前编辑文件 Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点 Ctrl + F9 执行 Make Project 操作 Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签 Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选 Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口 Ctrl + Enter 智能分隔行 Ctrl + End 跳到文件尾 Ctrl + Home 跳到文件头 Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备） Ctrl + Delete 删除光标后面的单词或是中文句 Ctrl + BackSpace 删除光标前面的单词或是中文句 Ctrl + 1,2,3…9 定位到对应数值的书签位置 Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径 Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要 Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置 Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置 Ctrl + 前方向键 等效于鼠标滚轮向前效果 Ctrl + 后方向键 等效于鼠标滚轮向后效果 Shift 快捷键 介绍 Shift + F1 如果有外部文档可以连接外部文档 Shift + F2 跳转到上一个高亮错误 或 警告位置 Shift + F3 在查找模式下，查找匹配上一个 Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留 Shift + F6 对文件 / 文件夹 重命名 Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样 Shift + F9 等效于点击工具栏的 Debug 按钮 Shift + F10 等效于点击工具栏的 Run 按钮 Shift + F11 弹出书签显示层 Shift + Tab 取消缩进 Shift + ESC 隐藏当前 或 最后一个激活的工具窗口 Shift + End 选中光标到当前行尾位置 Shift + Home 选中光标到当前行头位置 Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置 Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件 Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动 Ctrl + Alt 快捷键 介绍 Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用 （必备） Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化 Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层 Ctrl + Alt + J 弹出模板选择窗口，讲选定的代码加入动态模板中 Ctrl + Alt + H 调用层次 Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Ctrl + Alt + V 快速引进变量 Ctrl + Alt + Y 同步、刷新 Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置 Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来 Ctrl + Alt + F11 切换全屏模式 Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行 Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层 Ctrl + Alt + Space 类名自动完成 Ctrl + Alt + 左方向键 退回到上一个操作的地方 （必备）**（注意与其他软件快捷键冲突）** Ctrl + Alt + 右方向键 前进到上一个操作的地方 （必备）**（注意与其他软件快捷键冲突）** Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件 Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件 Ctrl + Shift 快捷键 介绍 Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件 （必备） Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备） Ctrl + Shift + J 自动将下一行合并到当前行末尾 （必备） Ctrl + Shift + Z 取消撤销 （必备） Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备） Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备） Ctrl + Shift + U 对选中的代码进行大 / 小写轮流转换 （必备） Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板 Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层 Ctrl + Shift + E 显示最近修改的文件列表的弹出层 Ctrl + Shift + H 显示方法层次结构 Ctrl + Shift + B 跳转到类型声明处 Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义 Ctrl + Shift + A 查找动作 / 设置 Ctrl + Shift + / 代码块注释 （必备） Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置 Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置 Ctrl + Shift + + 展开所有代码 Ctrl + Shift + - 折叠所有代码 Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失 Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件 Ctrl + Shift + F9 编译选中的文件 / 包 / Module Ctrl + Shift + F12 编辑器最大化 Ctrl + Shift + Space 智能代码提示 Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备） Ctrl + Shift + Backspace 退回到上次修改的地方 Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签 Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域 Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域 Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 Alt + Shift 快捷键 介绍 Alt + Shift + N 选择 / 添加 task Alt + Shift + F 显示添加到收藏夹弹出层 Alt + Shift + C 查看最近操作项目的变化情况列表 Alt + Shift + F 添加到收藏夹 Alt + Shift + I 查看项目当前文件 Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入 Alt + Shift + F9 弹出 Debug 的可选择菜单 Alt + Shift + F10 弹出 Run 的可选择菜单 Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 Alt + Shift + 前方向键 移动光标所在行向上移动 Alt + Shift + 后方向键 移动光标所在行向下移动 Ctrl + Shift + Alt 快捷键 介绍 Ctrl + Shift + Alt + V 无格式黏贴 Ctrl + Shift + Alt + N 前往指定的变量 / 方法 Ctrl + Shift + Alt + S 打开当前项目设置 Ctrl + Shift + Alt + C 复制参考信息 其它 快捷键 介绍 F2 跳转到下一个高亮错误 或 警告位置 （必备） F3 在查找模式下，定位到下一个匹配处 F4 编辑源 F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上 F11 添加书签 F12 回到前一个工具窗口 Tab 缩进 ESC 从工具窗口进入代码文件窗口 连按两次Shift 弹出 Search Everywhere 弹出层","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"}]}],"categories":[{"name":"后端","slug":"后端","permalink":"https://blog.zoutl.cn/categories/%E5%90%8E%E7%AB%AF/"},{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/categories/%E5%85%B6%E5%AE%83/"},{"name":"开发工具","slug":"开发工具","permalink":"https://blog.zoutl.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/categories/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"},{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/categories/%E5%89%8D%E7%AB%AF/"},{"name":"运维","slug":"运维","permalink":"https://blog.zoutl.cn/categories/%E8%BF%90%E7%BB%B4/"},{"name":"版本控制","slug":"版本控制","permalink":"https://blog.zoutl.cn/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"持久层框架","slug":"持久层框架","permalink":"https://blog.zoutl.cn/categories/%E6%8C%81%E4%B9%85%E5%B1%82%E6%A1%86%E6%9E%B6/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.zoutl.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.zoutl.cn/tags/Java/"},{"name":"其它","slug":"其它","permalink":"https://blog.zoutl.cn/tags/%E5%85%B6%E5%AE%83/"},{"name":"Postman","slug":"Postman","permalink":"https://blog.zoutl.cn/tags/Postman/"},{"name":"Gateway","slug":"Gateway","permalink":"https://blog.zoutl.cn/tags/Gateway/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://blog.zoutl.cn/tags/Hexo%E5%8D%9A%E5%AE%A2/"},{"name":"Maven","slug":"Maven","permalink":"https://blog.zoutl.cn/tags/Maven/"},{"name":"个人项目","slug":"个人项目","permalink":"https://blog.zoutl.cn/tags/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"},{"name":"JMeter","slug":"JMeter","permalink":"https://blog.zoutl.cn/tags/JMeter/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://blog.zoutl.cn/tags/Vue-js/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://blog.zoutl.cn/tags/Spring-Boot/"},{"name":"IntelliJ IDEA","slug":"IntelliJ-IDEA","permalink":"https://blog.zoutl.cn/tags/IntelliJ-IDEA/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.zoutl.cn/tags/CentOS7/"},{"name":"Nacos","slug":"Nacos","permalink":"https://blog.zoutl.cn/tags/Nacos/"},{"name":"OpenFeign","slug":"OpenFeign","permalink":"https://blog.zoutl.cn/tags/OpenFeign/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.zoutl.cn/tags/MySQL/"},{"name":"GitHub","slug":"GitHub","permalink":"https://blog.zoutl.cn/tags/GitHub/"},{"name":"AdBlock","slug":"AdBlock","permalink":"https://blog.zoutl.cn/tags/AdBlock/"},{"name":"Windows系统","slug":"Windows系统","permalink":"https://blog.zoutl.cn/tags/Windows%E7%B3%BB%E7%BB%9F/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.zoutl.cn/tags/hexo/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.zoutl.cn/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.zoutl.cn/tags/MyBatis/"},{"name":"IDM","slug":"IDM","permalink":"https://blog.zoutl.cn/tags/IDM/"},{"name":"Git","slug":"Git","permalink":"https://blog.zoutl.cn/tags/Git/"},{"name":"Element UI","slug":"Element-UI","permalink":"https://blog.zoutl.cn/tags/Element-UI/"},{"name":"Redis","slug":"Redis","permalink":"https://blog.zoutl.cn/tags/Redis/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.zoutl.cn/tags/Spring/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.zoutl.cn/tags/Node-js/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://blog.zoutl.cn/tags/Tomcat/"},{"name":"jasypt","slug":"jasypt","permalink":"https://blog.zoutl.cn/tags/jasypt/"},{"name":"前端","slug":"前端","permalink":"https://blog.zoutl.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"https://blog.zoutl.cn/tags/Spring-Data-JPA/"},{"name":"EasyUI","slug":"EasyUI","permalink":"https://blog.zoutl.cn/tags/EasyUI/"},{"name":"CKEditor","slug":"CKEditor","permalink":"https://blog.zoutl.cn/tags/CKEditor/"},{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"https://blog.zoutl.cn/tags/Thymeleaf/"},{"name":"MyBatis-Plus","slug":"MyBatis-Plus","permalink":"https://blog.zoutl.cn/tags/MyBatis-Plus/"},{"name":"又拍云","slug":"又拍云","permalink":"https://blog.zoutl.cn/tags/%E5%8F%88%E6%8B%8D%E4%BA%91/"},{"name":"Typora","slug":"Typora","permalink":"https://blog.zoutl.cn/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.zoutl.cn/tags/Markdown/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"https://blog.zoutl.cn/tags/Elasticsearch/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.zoutl.cn/tags/Nginx/"},{"name":"SSL证书","slug":"SSL证书","permalink":"https://blog.zoutl.cn/tags/SSL%E8%AF%81%E4%B9%A6/"},{"name":"阿里云","slug":"阿里云","permalink":"https://blog.zoutl.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"XXL-JOB","slug":"XXL-JOB","permalink":"https://blog.zoutl.cn/tags/XXL-JOB/"},{"name":"Listary","slug":"Listary","permalink":"https://blog.zoutl.cn/tags/Listary/"},{"name":"Swagger3","slug":"Swagger3","permalink":"https://blog.zoutl.cn/tags/Swagger3/"},{"name":"Shiro","slug":"Shiro","permalink":"https://blog.zoutl.cn/tags/Shiro/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.zoutl.cn/tags/Docker/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://blog.zoutl.cn/tags/RabbitMQ/"},{"name":"Mycat","slug":"Mycat","permalink":"https://blog.zoutl.cn/tags/Mycat/"},{"name":"Keepalived","slug":"Keepalived","permalink":"https://blog.zoutl.cn/tags/Keepalived/"},{"name":"shell","slug":"shell","permalink":"https://blog.zoutl.cn/tags/shell/"},{"name":"Crontab","slug":"Crontab","permalink":"https://blog.zoutl.cn/tags/Crontab/"},{"name":"DockerFile","slug":"DockerFile","permalink":"https://blog.zoutl.cn/tags/DockerFile/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.zoutl.cn/tags/Spring-Cloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://blog.zoutl.cn/tags/Eureka/"},{"name":"Zuul","slug":"Zuul","permalink":"https://blog.zoutl.cn/tags/Zuul/"},{"name":"Hystrix","slug":"Hystrix","permalink":"https://blog.zoutl.cn/tags/Hystrix/"},{"name":"Feign","slug":"Feign","permalink":"https://blog.zoutl.cn/tags/Feign/"},{"name":"Ribbon","slug":"Ribbon","permalink":"https://blog.zoutl.cn/tags/Ribbon/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://blog.zoutl.cn/tags/Dubbo/"},{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"https://blog.zoutl.cn/tags/ZooKeeper/"},{"name":"JustAuth","slug":"JustAuth","permalink":"https://blog.zoutl.cn/tags/JustAuth/"},{"name":"JSON","slug":"JSON","permalink":"https://blog.zoutl.cn/tags/JSON/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.zoutl.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"jsoup","slug":"jsoup","permalink":"https://blog.zoutl.cn/tags/jsoup/"},{"name":"highlight.js","slug":"highlight-js","permalink":"https://blog.zoutl.cn/tags/highlight-js/"},{"name":"cmd","slug":"cmd","permalink":"https://blog.zoutl.cn/tags/cmd/"},{"name":"Highcharts","slug":"Highcharts","permalink":"https://blog.zoutl.cn/tags/Highcharts/"},{"name":"jQuery","slug":"jQuery","permalink":"https://blog.zoutl.cn/tags/jQuery/"},{"name":"部落冲突","slug":"部落冲突","permalink":"https://blog.zoutl.cn/tags/%E9%83%A8%E8%90%BD%E5%86%B2%E7%AA%81/"},{"name":"QuickLook","slug":"QuickLook","permalink":"https://blog.zoutl.cn/tags/QuickLook/"},{"name":"cron","slug":"cron","permalink":"https://blog.zoutl.cn/tags/cron/"}]}