<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeDao的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-26T19:17:39.776Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>LeDao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>320</title>
    <link href="http://example.com/320.html"/>
    <id>http://example.com/320.html</id>
    <published>2021-08-26T19:17:39.000Z</published>
    <updated>2021-08-26T19:17:39.776Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡策略</title>
    <link href="http://example.com/319.html"/>
    <id>http://example.com/319.html</id>
    <published>2021-08-26T19:11:58.000Z</published>
    <updated>2021-08-26T19:16:35.307Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx负载均衡策略有：轮询（默认）、weight权重、ip_hash、least_conn最少连接</p><h3 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h3><p>每个请求轮流分配到不同的后端服务器，如果后端服务器挂掉，则自动被剔除</p><p>实例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream www.feng.com&#123;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.2</span>:<span class="number">8080</span>;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.3</span>:<span class="number">9090</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weight权重"><a href="#weight权重" class="headerlink" title="weight权重"></a>weight权重</h3><p>根据weight权重，请求会根据权重比例分发给不同后端服务器，weight权重越高，分配的比例越大；实际分配时，根据服务器硬件配置高低，来具体分配weight权重，硬件配置高的，weight就配置高点</p><p>实例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream www.feng.com&#123;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.2</span>:<span class="number">8080</span>;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.3</span>:<span class="number">9090</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><p>ip_hash策略是根据用户客户端的IP的hash值来分配具体服务器，这样每个访问客户端都会固定访问某一个服务器，这样可以解决session丢失问题，很多网站都采用这种策略来搞负载均衡，主要考虑到session问题</p><p>实例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream www.feng.com&#123;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.2</span>:<span class="number">8080</span>;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.3</span>:<span class="number">9090</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="least-conn"><a href="#least-conn" class="headerlink" title="least_conn"></a>least_conn</h3><p>web请求会被分发到连接数最少的服务器上</p><p>实例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream www.feng.com&#123;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.2</span>:<span class="number">8080</span>;</span><br><span class="line">     server <span class="number">172.17</span>.<span class="number">0.3</span>:<span class="number">9090</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/85.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx实现负载均衡</title>
    <link href="http://example.com/318.html"/>
    <id>http://example.com/318.html</id>
    <published>2021-08-26T17:59:31.000Z</published>
    <updated>2021-08-26T19:04:28.403Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Docker中运行多个Tomcat，客户端把请求发送给Nginx后，由Nginx分发给其中一个Tomcat，Tomcat响应后再由Nginx返回结果到客户端</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="复制Tomcat配置"><a href="#复制Tomcat配置" class="headerlink" title="复制Tomcat配置"></a>复制Tomcat配置</h4><p>创建并启动一个Tomcat容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=自定义名称 -p 8080:8080 tomcat镜像id</span><br></pre></td></tr></table></figure><p>在 /home/data/tomcat 目录下新建两个目录：tomcat1、tomcat2，并把该容器的 /usr/local/tomcat/conf 和 /usr/local/tomcat/webapps 目录复制到 /home/tomcat1 和 /home/tomcat2 下，复制命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制到tomcat1</span></span><br><span class="line">docker cp 该容器id:/usr/<span class="built_in">local</span>/tomcat/conf /home/data/tomcat/tomcat1/</span><br><span class="line">docker cp 该容器id:/usr/<span class="built_in">local</span>/tomcat/webapps /home/data/tomcat/tomcat1/</span><br><span class="line"></span><br><span class="line"><span class="comment">#复制到tomcat2</span></span><br><span class="line">docker cp 该容器id:/usr/<span class="built_in">local</span>/tomcat/conf /home/data/tomcat/tomcat2/</span><br><span class="line">docker cp 该容器id:/usr/<span class="built_in">local</span>/tomcat/webapps /home/data/tomcat/tomcat2/</span><br></pre></td></tr></table></figure><h4 id="创建Tomcat容器"><a href="#创建Tomcat容器" class="headerlink" title="创建Tomcat容器"></a>创建Tomcat容器</h4><p>把正在运行的Tomcat容器停掉，创建和启动两个Tomcat容器，并挂载目录到新创建的两个目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name tomcat1 -p 8080:8080 -v /home/data/tomcat/tomcat1/conf/:/usr/<span class="built_in">local</span>/tomcat/conf/ -v /home/data/tomcat/tomcat1/webapps/:/usr/<span class="built_in">local</span>/tomcat/webapps/ tomcat镜像id</span><br><span class="line"></span><br><span class="line">docker run -d --name tomcat2 -p 9090:9090 -v /home/data/tomcat/tomcat2/conf/:/usr/<span class="built_in">local</span>/tomcat/conf/ -v /home/data/tomcat/tomcat2/webapps/:/usr/<span class="built_in">local</span>/tomcat/webapps/ tomcat镜像id</span><br></pre></td></tr></table></figure><p>修改Tomcat2的配置文件中的端口为9090，该文件的宿主机路径为：/home/data/tomcat/tomcat2/conf/server.xml（因为已经挂载了目录所以可以直接在宿主机修改）</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-27%20023013.png"></p><p>修改两个Tomcat容器运行成功后的首页，Tomcat1的首页文件宿主机目录为：/home/data/tomcat/tomcat1/webapps/ROOT/index.jsp，Tomcat2的首页文件宿主机目录为：/home/data/tomcat/tomcat2/webapps/ROOT/index.jsp，修改了可以看出运行成功后是哪个Tomcat运行就行了，我的修改如下：</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-27%20023833.png"></p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-27%20023855.png"></p><p>试一下两个Tomcat容器能否正确运行，可以运行成功即可</p><h4 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h4><p>在http{}中添加以下代码：（ <a href="http://www.123.com/">www.123.com</a> 为本地域名，IP和端口号为该Tomcat容器在Docker内的IP以及端口）</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream www.<span class="number">123</span>.com&#123;</span><br><span class="line"> server <span class="number">172.17</span>.<span class="number">0.3</span>:<span class="number">8080</span> weight=<span class="number">5</span>;</span><br><span class="line"> server <span class="number">172.17</span>.<span class="number">0.4</span>:<span class="number">9090</span> weight=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upstream是配置nginx与后端服务器负载均衡非常重要的一个模块，并且它还能对后端的服务器的健康状态进行检查，若后端服务器中的一台发生故障，则前端的请求不会转发到该故障的机器；weight是权重配置，权重越高，分配到的概率越高</p><h4 id="修改default-conf"><a href="#修改default-conf" class="headerlink" title="修改default.conf"></a>修改default.conf</h4><p>该文件在nginx.conf所在目录的conf.d目录下，修改proxy_pass为本机域名</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-27%20025538.png"></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>浏览器地址栏输入：虚拟机IP或者与它绑定的本机域名，不断刷新页面，有时候请求的是tomcat1，有时候是tomcat2，如果停掉tomcat2那么就只请求tomcat1</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/72.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Tomcat" scheme="http://example.com/tags/Tomcat/"/>
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx实现反向代理</title>
    <link href="http://example.com/317.html"/>
    <id>http://example.com/317.html</id>
    <published>2021-08-26T15:00:29.000Z</published>
    <updated>2021-08-26T16:14:57.627Z</updated>
    
    <content type="html"><![CDATA[<p>本博客主要实现访问Nginx时，代理请求Tomcat服务器</p><h3 id="启动Nginx"><a href="#启动Nginx" class="headerlink" title="启动Nginx"></a>启动Nginx</h3><p>创建并启动Nginx容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=自定义名称 -v /home/data/nginx:/etc/nginx -p 80:80 nginx镜像id</span><br></pre></td></tr></table></figure><h3 id="启动Tomcat"><a href="#启动Tomcat" class="headerlink" title="启动Tomcat"></a>启动Tomcat</h3><p>创建并启动Tomcat容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=自定义名称 -p 8080:8080 tomcat镜像id</span><br></pre></td></tr></table></figure><p>查看Docker给Tomcat容器分配的IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect Tomcat容器id</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-27%20000102.png"></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>在宿主机 <font color="#dd0000">/home/data/nginx/conf.d</font> 目录下修改 <mark class="hl-label blue">default.conf</mark>  文件（下面的IP为Docker给Tomcat容器分配的IP）</p><p>location / { }中添加：<mark class="hl-label blue">proxy_pass  http://172.17.0.3:8080;</mark> </p><p>server_name修改为：<mark class="hl-label blue">http://172.17.0.3:8080</mark> （server_name内容随意，主要是用于区分）</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-26%20235921.png"></p><h3 id="添加本地域名"><a href="#添加本地域名" class="headerlink" title="添加本地域名"></a>添加本地域名</h3><p>找到 C:\Windows\System32\drivers\etc 打开hosts，底部加配置：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟机IP www.<span class="number">123</span>.com</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>浏览器地址栏输入：<a href="http://www.123.com/">www.123.com</a> （也可以输入虚拟机IP）访问Nginx时，通过代理请求了Tomcat服务器</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/72.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装Nginx</title>
    <link href="http://example.com/316.html"/>
    <id>http://example.com/316.html</id>
    <published>2021-08-26T13:14:31.000Z</published>
    <updated>2021-08-26T13:37:04.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="创建并运行容器"><a href="#创建并运行容器" class="headerlink" title="创建并运行容器"></a>创建并运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=自定义名称 -v /home/data/nginx:/etc/nginx -p 80:80 nginx镜像id</span><br></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it nginx容器id bash</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>浏览器地址栏输入<font color="#dd0000">虚拟机IP</font>，看到<mark class="hl-label blue">Welcome to nginx!</mark> 说明安装成功</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/68.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="http://example.com/categories/Nginx/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>form表单无法提交input disabled内容</title>
    <link href="http://example.com/315.html"/>
    <id>http://example.com/315.html</id>
    <published>2021-08-24T01:06:16.000Z</published>
    <updated>2021-08-24T01:13:28.050Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用了disable属性让文本框无法编辑，但是提交form表单时无法获取该文本框的值，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/student/update&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;margin-top: 10%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;student.id&#125;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;编号&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;student.name&#125;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;student.age&#125;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;年龄&quot;</span> <span class="attr">required</span>=<span class="string">&quot;required&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>disabled=”disabled”修改为readonly=”readonly”即可</p><h3 id="readonly和disabled的区别"><a href="#readonly和disabled的区别" class="headerlink" title="readonly和disabled的区别"></a>readonly和disabled的区别</h3><p>readonly：针对input(text / password)和textarea有效，在设置为true的情况下，用户可以获得焦点，但是不能编辑，在提交表单时，输入项会作为form的内容提交</p><p>disabled：针对所有表单元素（select，button，input，textarea等），在设置为disabled为true的情况下，表单输入项不能获得焦点，用户的所有操作无意义，在提交表单时，表单输入项不会被提交。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/56.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Windows10释放被占用端口</title>
    <link href="http://example.com/314.html"/>
    <id>http://example.com/314.html</id>
    <published>2021-08-23T20:17:09.000Z</published>
    <updated>2021-08-24T11:58:01.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看PID"><a href="#查看PID" class="headerlink" title="查看PID"></a>查看PID</h3><p>打开CMD，输入命令查看端口4000的PID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -aon|findstr <span class="string">&quot;4000&quot;</span></span><br></pre></td></tr></table></figure><p>看下图的0.0.0.0:4000，LISTENING后的数值：16388就是PID</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-24%20044304.png"></p><h3 id="释放端口"><a href="#释放端口" class="headerlink" title="释放端口"></a>释放端口</h3><h4 id="CMD方式释放"><a href="#CMD方式释放" class="headerlink" title="CMD方式释放"></a>CMD方式释放</h4><p>输入以下命令，PID为上图LISTENING后的数值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskkill /T /F /PID 16388</span><br></pre></td></tr></table></figure><h4 id="任务管理器释放"><a href="#任务管理器释放" class="headerlink" title="任务管理器释放"></a>任务管理器释放</h4><p>查看指定 PID 的进程（也可以不看，记住PID即可）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist|findstr <span class="string">&quot;16388&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-24%20044328.png"></p><p>打开任务管理，选择详细信息选项，根据进程名称或者PID找到进程</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-24%20044726.jpg"></p><p>右键点击并选择结束任务</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-24%20044745.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/49.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Windows10" scheme="http://example.com/categories/Windows10/"/>
    
    
    <category term="Windows10" scheme="http://example.com/tags/Windows10/"/>
    
  </entry>
  
  <entry>
    <title>idea创建Spring项目</title>
    <link href="http://example.com/313.html"/>
    <id>http://example.com/313.html</id>
    <published>2021-08-23T18:04:17.000Z</published>
    <updated>2021-08-23T18:12:54.524Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h3><p>查看博客：<a href="/253.html">idea创建Maven项目</a></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>命名为：applicationContext.xml，完整代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ledao.entity.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="学生实体类"><a href="#学生实体类" class="headerlink" title="学生实体类"></a>学生实体类</h4><p>命名为：Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ledao.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LeDao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@company</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-24 1:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 年龄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><p>命名为：Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ledao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ledao.entity.Student;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LeDao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@company</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-24 1:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">&quot;student1&quot;</span>);</span><br><span class="line">        System.out.println(student.getId()+<span class="string">&quot;,&quot;</span>+student.getName()+<span class="string">&quot;,&quot;</span>+ student.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>运行测试类的main方法，结果如下：</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-24%20021110.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/31.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="idea使用" scheme="http://example.com/categories/idea%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="idea使用" scheme="http://example.com/tags/idea%E4%BD%BF%E7%94%A8/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Docker私有仓库删除镜像</title>
    <link href="http://example.com/312.html"/>
    <id>http://example.com/312.html</id>
    <published>2021-08-22T20:04:05.000Z</published>
    <updated>2021-08-22T20:20:00.422Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>对于私有仓库的镜像，Docker是没有命令对其进行删除的</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>进入私有仓库的容器内，找到镜像文件，然后手动删除即可</p><h3 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h3><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>先运行对应私有仓库的容器，然后进入容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 私有仓库容器id sh</span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>该配置文件在 /etc/docker/registry 目录下，名称为：config.yml ，在storage节点添加以下代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>完整config.yml代码如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">X-Content-Type-Options:</span> [<span class="string">nosniff</span>]</span><br><span class="line"><span class="attr">health:</span></span><br><span class="line">  <span class="attr">storagedriver:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">threshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="找到镜像文件"><a href="#找到镜像文件" class="headerlink" title="找到镜像文件"></a>找到镜像文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name <span class="string">&quot;*要删除镜像名称*&quot;</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>进入上一步找到的镜像文件的路径，然后开始删除，该镜像文件是文件夹所以删除时追加参数-r</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r 镜像名称</span><br></pre></td></tr></table></figure><h4 id="同步配置文件"><a href="#同步配置文件" class="headerlink" title="同步配置文件"></a>同步配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry garbage-collect /etc/docker/registry/config.yml</span><br></pre></td></tr></table></figure><h4 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h4><p>浏览器地址栏输入：<font color="#dd0000">http://虚拟机id:5000/v2/_catalog</font>，可以看到对应的镜像已经没了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/26.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建私有仓库</title>
    <link href="http://example.com/311.html"/>
    <id>http://example.com/311.html</id>
    <published>2021-08-22T18:33:53.000Z</published>
    <updated>2021-08-22T20:03:55.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Docker私有仓库程序本身就是一个镜像，主要是企业内部用来存放镜像的仓库，相对官方仓库以及阿里云仓库，具有更高的保密安全级别</p><h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><h4 id="拉取私有仓库镜像"><a href="#拉取私有仓库镜像" class="headerlink" title="拉取私有仓库镜像"></a>拉取私有仓库镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br></pre></td></tr></table></figure><h4 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name=myRegistry -p 5000:5000 registry</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>浏览器地址栏输入：<font color="#dd0000">http://虚拟机id:5000/v2/_catalog</font>，看到下图说明搭建成功</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-23%20024525.jpg"></p><h4 id="修改daemon-json"><a href="#修改daemon-json" class="headerlink" title="修改daemon.json"></a>修改daemon.json</h4><p>该文件在 <font color="#dd0000">/etc/docker</font> 目录下，添加以下代码让Docker信任私有仓库</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;虚拟机id:5000&quot;</span>]</span><br></pre></td></tr></table></figure><h4 id="重启Docker"><a href="#重启Docker" class="headerlink" title="重启Docker"></a>重启Docker</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><h4 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h4><p>标记要上传到私有仓库的镜像为私有仓库的镜像（标记只是引用，镜像id还是被标记的镜像的id）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像id 虚拟机id:5000/自定义名称</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-23%20033246.png"></p><p>推送镜像到私有仓库，推送前先启动私有仓库的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 上图划红线的镜像名称</span><br></pre></td></tr></table></figure><p>查看结果</p><p>浏览器地址栏输入：<font color="#dd0000">http://虚拟机id:5000/v2/_catalog</font>，从下图可以看到镜像上传成功</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-23%20033447.jpg"></p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><p>先删除刚刚上传的本地镜像，然后再从私有仓库拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 虚拟机id:5000/上图的镜像名称</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/19.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile的ONBUILD指令</title>
    <link href="http://example.com/310.html"/>
    <id>http://example.com/310.html</id>
    <published>2021-08-22T17:05:56.000Z</published>
    <updated>2021-08-22T17:44:38.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>父镜像在被子镜像继承后父镜像的ONBUILD被触发，可以把ONBUID理解为一个触发器。编写Dockerfile的时候，其他命令都是为了自身镜像服务的，只有ONBUILD是为了子镜像服务</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="构建父镜像"><a href="#构建父镜像" class="headerlink" title="构建父镜像"></a>构建父镜像</h4><p>编写父镜像DockerFile，命名为：parent_df，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">ONBUILD RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>构建父镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f parent_df -t parent .</span><br></pre></td></tr></table></figure><h4 id="构建子镜像"><a href="#构建子镜像" class="headerlink" title="构建子镜像"></a>构建子镜像</h4><p>编写子镜像DockerFile，命名为：son_df，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM parent</span><br></pre></td></tr></table></figure><p>构建子镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> docker build -f son_df -t son .</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>当构建子镜像的时候，父镜像的ONBUILD会触发，子镜像直接安装vim，父镜像是没有安装vim的。所以使用父镜像创建的容器使用vim命令会报错，而用子镜像创建的容器可以使用vim命令</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/4.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="DockerFile" scheme="http://example.com/tags/DockerFile/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile的CMD, ENTRYPOINT指令</title>
    <link href="http://example.com/309.html"/>
    <id>http://example.com/309.html</id>
    <published>2021-08-22T15:33:20.000Z</published>
    <updated>2021-08-22T17:01:35.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CMD，ENTRYPOINT都是容器启动的时候，执行执行命令，都支持exec和shell方式</p><p>一般用法有两种：①单独一个CMD②先使用ENTRYPOINT（用于执行命令），然后结合CMD使用（用于追加参数）</p><p>有多个CMD时，只有最后一个CMD生效</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>一般开发和Docker官方都建议用 exec格式</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>第一种用法：运行一个可执行的文件并提供参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>]</span><br></pre></td></tr></table></figure><p>第二种用法：为ENTRYPOINT指定参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] </span><br></pre></td></tr></table></figure><p>第三种用法(shell格式)：是以”/bin/sh -c”的方法执行的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD <span class="built_in">command</span> param1 param2</span><br></pre></td></tr></table></figure><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p> exec 格式, 推荐</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [“executable”, “param1”, “param2”]</span><br></pre></td></tr></table></figure><p> shell 格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT <span class="built_in">command</span> param1 param2</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="单个CMD"><a href="#单个CMD" class="headerlink" title="单个CMD"></a>单个CMD</h4><p>编写DockerFile，命名为df1，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;第一个CMD&quot;</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f df1 -t a6678696/df:1.1 .</span><br></pre></td></tr></table></figure><p>创建和运行该镜像的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像id</span><br></pre></td></tr></table></figure><p>结果如下图</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-23%20000826.jpg"></p><h4 id="多个CMD"><a href="#多个CMD" class="headerlink" title="多个CMD"></a>多个CMD</h4><p>编写DockerFile，命名为df2，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;第一个CMD&quot;</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;第二个CMD&quot;</span></span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker</span> build -f df<span class="number">2</span> -t a<span class="number">6678696</span>/df:<span class="number">1</span>.<span class="number">2</span> .</span><br></pre></td></tr></table></figure><p>创建和运行该镜像的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像id</span><br></pre></td></tr></table></figure><p>结果如下图，第一个CMD命令没有生效，生效的是最后一个CMD</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-23%20000929.jpg"></p><h4 id="先ENTRYPOINT后CMD"><a href="#先ENTRYPOINT后CMD" class="headerlink" title="先ENTRYPOINT后CMD"></a>先ENTRYPOINT后CMD</h4><p>编写DockerFile，命名为df3，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;ls&quot;</span>]</span><br><span class="line"></span><br><span class="line">CMD [<span class="string">&quot;-l&quot;</span>]</span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f df3 -t a6678696/df:1.3 .</span><br></pre></td></tr></table></figure><p>创建和运行该镜像的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像id</span><br></pre></td></tr></table></figure><p>结果如下图，以ls -l格式查看文件</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-23%20001442.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/106.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="DockerFile" scheme="http://example.com/tags/DockerFile/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile通过VOLUME指令创建容器卷来实现容器的目录挂载</title>
    <link href="http://example.com/308.html"/>
    <id>http://example.com/308.html</id>
    <published>2021-08-21T19:46:11.000Z</published>
    <updated>2021-08-21T20:13:31.847Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>DockerFile创建镜像时通过VOLUME指令创建几个容器卷，然后创建这个镜像的容器时，这个容器就有了这几个容器卷目录，并与宿主机自动创建的对应目录实现了挂载</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME[<span class="string">&#x27;目录1&#x27;</span>,<span class="string">&#x27;目录2&#x27;</span>]</span><br></pre></td></tr></table></figure><h4 id="编写DockerFile"><a href="#编写DockerFile" class="headerlink" title="编写DockerFile"></a>编写DockerFile</h4><p>新建一个文件，命名为：myVolumeDockerFile，没有后缀名，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">&quot;/home/v1&quot;</span>,<span class="string">&quot;/home/v2&quot;</span>]</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f myVolumeDockerFile -t a6678696/mycentos:1.2 .</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-22%20040035.jpg"></p><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 9123279cfb4f</span><br></pre></td></tr></table></figure><h4 id="找到挂载的目录"><a href="#找到挂载的目录" class="headerlink" title="找到挂载的目录"></a>找到挂载的目录</h4><p>①找到容器挂载的容器卷v1，v2</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-22%20040322.jpg"></p><p>②找到宿主机挂载的容器卷</p><p>通过inspect命令获取容器的元数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><p>找到Mounts节点，Source为宿主机的目录，Destination为容器的目录，两个目录是挂载的</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-22%20040846.jpg"></p><h3 id="PS"><a href="#PS" class="headerlink" title="PS."></a>PS.</h3><p>docker run -v 命令创建挂载目录更好，可以自定义宿主机目录</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/90.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="DockerFile" scheme="http://example.com/tags/DockerFile/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile创建镜像时报错：file not found in build context or excluded by</title>
    <link href="http://example.com/307.html"/>
    <id>http://example.com/307.html</id>
    <published>2021-08-21T17:25:02.000Z</published>
    <updated>2021-08-21T17:40:19.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>DockerFile创建镜像时使用COPY和ADD指令时，检测到源文件不存在就会报错</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>DockerFile文件和源文件放在同一目录下，并且先进入这个目录再执行创建镜像命令</p><p>例如我的DockerFile文件和源文件都在/home/dockerfile目录中（如下图所示），那么我就要进入/home/dockerfile目录，然后执行DockerFile创建镜像的命令</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-22%20013057.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/82.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="DockerFile" scheme="http://example.com/tags/DockerFile/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile构建自定义Tomcat</title>
    <link href="http://example.com/306.html"/>
    <id>http://example.com/306.html</id>
    <published>2021-08-21T16:45:16.000Z</published>
    <updated>2021-08-22T16:33:55.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编写DockerFile"><a href="#编写DockerFile" class="headerlink" title="编写DockerFile"></a>编写DockerFile</h3><p>新建一个文件，命名为：mytomcatdockerfile，没有后缀名，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER LeDao&lt;f1203007469@gmail.com&gt;</span><br><span class="line"> </span><br><span class="line">LABEL name=<span class="string">&quot;LeDao Tomcat Image&quot;</span> \</span><br><span class="line">    build-date=<span class="string">&quot;2021-08-22 00:16:53&quot;</span></span><br><span class="line">    </span><br><span class="line">COPY  copyright.txt /home/copyright.txt</span><br><span class="line">ADD server-jre-8u151-linux-x64.tar.gz /home/</span><br><span class="line">ADD apache-tomcat-8.5.37.tar.gz /home/</span><br><span class="line"> </span><br><span class="line">ENV WORKPATH /home/apache-tomcat-8.5.37/</span><br><span class="line">WORKDIR <span class="variable">$WORKPATH</span></span><br><span class="line"> </span><br><span class="line">ENV JAVA_HOME /home/jdk1.8.0_151</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /home/apache-tomcat-8.5.37/</span><br><span class="line">ENV CATALINA_BASE /home/apache-tomcat-8.5.37/</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD [<span class="string">&quot;/home/apache-tomcat-8.5.37/bin/catalina.sh&quot;</span>,<span class="string">&quot;run&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>创建/home/dockerfile目录，把mytomcatdockerfile、copyright.txt、server-jre-8u151-linux-x64.tar.gz、apache-tomcat-8.5.37.tar.gz复制到该目录下，并进入该目录</p><p>四个文件的百度网盘链接：</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1ldCQGNay95IvVlOzeMQdXg">https://pan.baidu.com/s/1ldCQGNay95IvVlOzeMQdXg</a> </p><p>提取码：62h2</p></blockquote><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>命令的最后面有个英文句号.（少了句号不行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f mytomcatdockerfile -t a6678696/mytomcat:1.2 .</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-22%20010340.jpg"></p><h3 id="查看镜像构造历史"><a href="#查看镜像构造历史" class="headerlink" title="查看镜像构造历史"></a>查看镜像构造历史</h3><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-22%20010515.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/74.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Tomcat" scheme="http://example.com/tags/Tomcat/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="DockerFile" scheme="http://example.com/tags/DockerFile/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile构建自定义CentOS</title>
    <link href="http://example.com/305.html"/>
    <id>http://example.com/305.html</id>
    <published>2021-08-21T15:06:20.000Z</published>
    <updated>2021-08-21T16:48:58.308Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编写DockerFile"><a href="#编写DockerFile" class="headerlink" title="编写DockerFile"></a>编写DockerFile</h3><p>新建一个文件，命名为：mycentosDockerFile，没有后缀名，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINER ledao&lt;f1203007469@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">LABEL name=<span class="string">&quot;LeDao CentOS Image&quot;</span> \</span><br><span class="line">build-date=<span class="string">&quot;2021-08-21&quot;</span></span><br><span class="line"></span><br><span class="line">ENV WORKPATH /home/</span><br><span class="line">WORKDIR <span class="variable">$WORKPATH</span></span><br><span class="line"></span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><p>命令的最后面有个英文句号.（少了句号不行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f /home/dockerfile/mycentosDockerFile -t a6678696/mycentos:1.1 .</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-21%20232745.png"></p><h3 id="查看镜像构建历史"><a href="#查看镜像构建历史" class="headerlink" title="查看镜像构建历史"></a>查看镜像构建历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> 镜像id</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-21%20233507.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/69.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="DockerFile" scheme="http://example.com/tags/DockerFile/"/>
    
  </entry>
  
  <entry>
    <title>DockerFile常用指令</title>
    <link href="http://example.com/304.html"/>
    <id>http://example.com/304.html</id>
    <published>2021-08-21T13:38:01.000Z</published>
    <updated>2021-08-21T15:01:25.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DockerFile简介"><a href="#DockerFile简介" class="headerlink" title="DockerFile简介"></a>DockerFile简介</h3><p>dockerfile用于快速有序且直观地完成对镜像的定制</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>FROM指令是整个Dockerfile的入口，必须是第一条指令。其代表新制作镜像的基础镜像。基础镜像可以自己制作，也可以从开源的仓库pull，例如dockerhub或是国内阿里云的免费仓库。</p><p>Docker中存在一种特殊的情况，就是不以任何基础镜像为基准，此时可以第一句话使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure><p>来表示以空白镜像为基础，也就是直接将可执行文件复制进镜像。例如swarm、coreos/etcd等。</p><h4 id="RUN指令"><a href="#RUN指令" class="headerlink" title="RUN指令"></a>RUN指令</h4><p>是dockerfile中最常用的指令之一。用来执行命令行上的命令。RUN的格式分为两种：</p><p>第一种：<br>shell格式：<code>RUN&lt;命令&gt;</code>，类似于直接在终端输入命令。例如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo <span class="string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; <span class="regexp">/usr/share</span><span class="regexp">/tomcat/welcome</span>.html</span><br></pre></td></tr></table></figure><p>第二种：<br>exec格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>。<br>RUN既然可以像在命令行那样工作，那么就也可以实现传参来运行指令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev <span class="built_in">make</span></span><br><span class="line">RUN wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span></span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=<span class="number">1</span></span><br><span class="line">RUN <span class="built_in">make</span> -C /usr/src/redis</span><br><span class="line">RUN <span class="built_in">make</span> -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p>RUN一次就代表Dockerfile中的一层。而docker镜像的构建就是不断去完善每一层需要做的事情。而dockerfi对一个file中层数是有限制的，最大不超过127层。因此，RUN提供命令的串联功能，也就是允许每一层可包含多种操作，他们会按照书写顺序来依次执行。那么上面的例子可以变为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:<span class="number">14.04</span></span><br><span class="line">RUN buildDeps=<span class="string">&#x27;gcc libc6-dev make&#x27;</span> \</span><br><span class="line">    &amp;&amp; apt-<span class="keyword">get</span> update \</span><br><span class="line">    &amp;&amp; apt-<span class="keyword">get</span> install -y $buildDeps \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz <span class="string">&quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</span> \</span><br><span class="line">    &amp;&amp; mkdir -p /usr/src/redis \</span><br><span class="line">    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=<span class="number">1</span> \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis \</span><br><span class="line">    &amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">    &amp;&amp; rm -rf /<span class="keyword">var</span>/lib/apt/lists<span class="comment">/* \</span></span><br><span class="line"><span class="comment">    &amp;&amp; rm redis.tar.gz \</span></span><br><span class="line"><span class="comment">    &amp;&amp; rm -r /usr/src/redis \</span></span><br><span class="line"><span class="comment">    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</span></span><br></pre></td></tr></table></figure><p>换行用 \ ，注释用 # ，平时书写注意缩进来保证文件的可读性。上述例子中的最后一句还进行了无关文件的清理，进一步保证每一层的最优和最小</p><p>注意事项：<br>镜像的初衷是进行功能的模块化，也是尽可能让每个容器干最少的事情，那么我们在书写dockerfile的时候要注意这个问题，每一层的东西确保是必须的，否则就不要进行安装或是拷贝。</p><h4 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h4><p>指定作者<br>句法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER <span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>该指令是为镜像添加标签<br>句法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL <span class="tag">&lt;<span class="name">key</span>&gt;</span>=<span class="tag">&lt;<span class="name">value</span>&gt;</span> <span class="tag">&lt;<span class="name">key</span>&gt;</span>=<span class="tag">&lt;<span class="name">value</span>&gt;</span> <span class="tag">&lt;<span class="name">key</span>&gt;</span>=<span class="tag">&lt;<span class="name">value</span>&gt;</span> ...</span><br></pre></td></tr></table></figure><p>一个Dockerfile种可以有多个LABEL，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL multi.label1=<span class="string">&quot;value1&quot;</span> \</span><br><span class="line">multi.label2=<span class="string">&quot;value2&quot;</span> \</span><br><span class="line">other=<span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure><p>说明：LABEL会继承基础镜像种的LABEL，如遇到key相同，则值覆盖</p><h4 id="COPY指令"><a href="#COPY指令" class="headerlink" title="COPY指令"></a>COPY指令</h4><p>该指令用于将宿主机文件拷贝至镜像内的指定路径<br>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">或</span><br><span class="line">COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br></pre></td></tr></table></figure><p>也就是说，原路径可以有多个，而目标路径唯一<br>注意事项：</p><p>1、可以使用符合GO规范的通配符，例如：<code>COPY hom* /mydir/</code><br>2、目的路径可以是镜像内的绝对路径，也可以是相对于当前工作目录的相对路径<br>3、COPY过来的文件权限与原始权限相同。如需更改，请用传统Liunx的chmod命令进行修改即可</p><h4 id="ADD高级复制"><a href="#ADD高级复制" class="headerlink" title="ADD高级复制"></a>ADD高级复制</h4><p>ADD的本质作用类似于COPY，但是其更复杂：</p><p>1、ADD过来的压缩包可以自动在目标路径下进行解压<br>2、原始路径可以是一个连接，ADD过程会尝试从该链接下载所需的文件到目的路径<br>3、一般情况下，建议使用COPY而不是ADD，因为COPY过来的文件可以配合使用RUN来进行解压或是其他操作，搭配使用更灵活，且单条语句所负担的功能唯一</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>该指令用于指定Dockerfile中该指令下面的操作所在的工作目录<br>类似于 cd 命令</p><h4 id="CMD-服务启动指令"><a href="#CMD-服务启动指令" class="headerlink" title="CMD 服务启动指令"></a>CMD 服务启动指令</h4><p>Docker不是虚拟机而是一个进程，作为进程，当然可以制定启动镜像时的具体参数。说白了就是制定一些你想自动启动的服务<br>格式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell 格式：<span class="built_in">CMD</span> &lt;命令&gt;</span><br><span class="line">exec 格式：<span class="built_in">CMD</span> [<span class="string">&quot;可执行文件&quot;</span>, <span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>...]</span><br><span class="line">参数列表格式：<span class="built_in">CMD</span> [<span class="string">&quot;参数1&quot;</span>, <span class="string">&quot;参数2&quot;</span>...]。在指定了 ENTRYPOINT 指令后，用 <span class="built_in">CMD</span> 指定具体的参数。</span><br></pre></td></tr></table></figure><p>注意事项：</p><p>1、CMD中的启动参数可以被更新覆盖。例如：<br>Dockerfile中若是用CMD指定启动镜像时执行/bin/bash，那么在启动镜像时输入<code>docker run -it ubuntu ./test.sh</code> 则会用./test.sh命令来覆盖/bin/bash命令<br>2、推荐使用exec格式的CMD书写。这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号<br>3、如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：<code>CMD echo /java</code><br>在实际执行中，会将其变更为：<br><code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo /java&quot; ]</code></p><h4 id="ENV设置环境变量"><a href="#ENV设置环境变量" class="headerlink" title="ENV设置环境变量"></a>ENV设置环境变量</h4><p>说是环境变量还不说是一个全局变量。在前面定义，后面可以通过 $ 取值进行使用<br>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV <span class="tag">&lt;<span class="name">key</span>&gt;</span> <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">ENV <span class="tag">&lt;<span class="name">key1</span>&gt;</span>=<span class="tag">&lt;<span class="name">value1</span>&gt;</span> <span class="tag">&lt;<span class="name">key2</span>&gt;</span>=<span class="tag">&lt;<span class="name">value2</span>&gt;</span>...</span><br></pre></td></tr></table></figure><p>例如可以指定一些包的版本号，这样更新镜像很方便，或是保存一些密码（该功能慎用，自己玩还是可以的）</p><h4 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h4><p>语法形式: <code>ARG &lt;name&gt;[=&lt;default value&gt;]</code><br>ARG和ENV效果类似，都是用来设置观景变量的。唯一 不同的是dockerfile中的ARG编译好后是不会出现在打开的容器内的</p><p>ARG在dockerfile中创建一个全局参数，参数可以给定一个默认值，在编译时可以传参对其进行覆盖。如果ARG指令有默认值并且在构建期间没有接收到参数、则使用默认值。一个dockerfile中可以包含多个ARG参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-arg <span class="tag">&lt;<span class="name">varname</span>&gt;</span>=<span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用ARG或ENV指令来指定RUN指令可用的变量，如果ARG和ENV同时指定了一个相同名称的变量、则ENV设置的变量会覆盖ARG设置的变量。如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 FROM ubuntu</span><br><span class="line">2 ARG CONT_IMG_VER</span><br><span class="line">3 ENV CONT_IMG_VER v1.0.0</span><br><span class="line">4 RUN <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span><br></pre></td></tr></table></figure><p>使用   <code>docker build --build-arg CONT_IMG_VER=v2.0.1 .</code> 最终输出v1.0.0 </p><p>一个ARG指令的有效范围在其定义的构建阶段内、如果要在多个阶段中都有效、则必须在每个阶段都使用ARG指令；<strong>与ARG不同  ENV设置参数的有效期为整个构建期内</strong></p><h4 id="VOLUME-挂在共享卷"><a href="#VOLUME-挂在共享卷" class="headerlink" title="VOLUME 挂在共享卷"></a>VOLUME 挂在共享卷</h4><p>格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure><p>Docker的使用原则除了每个容器干尽量少的事情外，还尽可能要求容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，也就是将本地磁盘的某一个目录挂载至容器内。同时这样的共享目录可以被多个不同的容器所使用</p><p>除了可以在dockerfile中指定这一参数外，在运行启动容器时也可以附带这一参数来指定共享卷：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name container-test -h CONTAINER -v /<span class="keyword">data</span> debian /bin/bash</span><br></pre></td></tr></table></figure><p>上述命令也可以覆盖dockerfile中的目录设定。</p><h4 id="USER指定用户"><a href="#USER指定用户" class="headerlink" title="USER指定用户"></a>USER指定用户</h4><p>在书写dockerfile时，某些层的操作若想切换用户名，可以使用该参数指定某些层的用户，并且是存在的用户名。<br> 格式：<code>USER &lt;用户名&gt;</code></p><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <code>gosu</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line">RUN wget -O /usr/<span class="built_in">local</span>/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;</span> \</span><br><span class="line">    &amp;&amp; chmod +x /usr/<span class="built_in">local</span>/bin/gosu \</span><br><span class="line">    &amp;&amp; gosu nobody <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line">CMD [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure><h4 id="EXPOSE暴漏端口"><a href="#EXPOSE暴漏端口" class="headerlink" title="EXPOSE暴漏端口"></a>EXPOSE暴漏端口</h4><p>句法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure><p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口</p><p>要将 EXPOSE 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射</p><h3 id="PS"><a href="#PS" class="headerlink" title="PS."></a>PS.</h3><p>来源：<a href="https://www.jianshu.com/p/2a90fc6ee383">https://www.jianshu.com/p/2a90fc6ee383</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/51.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
    <category term="DockerFile" scheme="http://example.com/tags/DockerFile/"/>
    
  </entry>
  
  <entry>
    <title>Docker备份和恢复镜像</title>
    <link href="http://example.com/303.html"/>
    <id>http://example.com/303.html</id>
    <published>2021-08-21T13:01:27.000Z</published>
    <updated>2021-08-21T13:16:37.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="备份镜像"><a href="#备份镜像" class="headerlink" title="备份镜像"></a>备份镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o 备份镜像的名称  源镜像名称:tag版本</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-21%20211044.jpg"></p><h3 id="恢复镜像"><a href="#恢复镜像" class="headerlink" title="恢复镜像"></a>恢复镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i 镜像文件</span><br></pre></td></tr></table></figure><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-21%20211126.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/47.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装和配置MySQL容器</title>
    <link href="http://example.com/302.html"/>
    <id>http://example.com/302.html</id>
    <published>2021-08-21T02:38:08.000Z</published>
    <updated>2021-08-21T04:12:55.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建MySQL容器"><a href="#创建MySQL容器" class="headerlink" title="创建MySQL容器"></a>创建MySQL容器</h3><p>创建的这个容器只是用来获取文件路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name 自定义名称 -di -p 3305:3306 -e MYSQL_ROOT_PASSWORD=123456 MySQL镜像id</span><br></pre></td></tr></table></figure><h3 id="获取文件路径"><a href="#获取文件路径" class="headerlink" title="获取文件路径"></a>获取文件路径</h3><p>进入容器的文件夹中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it 容器id /bin/bash</span><br></pre></td></tr></table></figure><p>获取conf.d、log、mysql的文件路径，分别如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/mysql/conf.d</span><br><span class="line">/var/<span class="built_in">log</span></span><br><span class="line">/var/lib/mysql</span><br></pre></td></tr></table></figure><h3 id="复制文件到宿主机"><a href="#复制文件到宿主机" class="headerlink" title="复制文件到宿主机"></a>复制文件到宿主机</h3><p>在宿主机的 home 目录下新建 mysql 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/mysql</span><br></pre></td></tr></table></figure><p>复制容器里的 /etc/mysql/conf.d、/var/log、/var/lib/mysql到宿主机/home/mysql</p><p>复制/etc/mysql/conf.d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:/etc/mysql/conf.d /home/mysql/</span><br></pre></td></tr></table></figure><p>复制/var/log</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:/var/<span class="built_in">log</span> /home/mysql/</span><br></pre></td></tr></table></figure><p>复制/var/lib/mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:/var/lib/mysql /home/mysql/</span><br></pre></td></tr></table></figure><h3 id="创建新的MySQL容器"><a href="#创建新的MySQL容器" class="headerlink" title="创建新的MySQL容器"></a>创建新的MySQL容器</h3><p>创建时挂载 /etc/mysql/conf.d、/var/log、/var/lib/mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -di --name 自定义名称 -p 3303:3306 -v /etc/mysql/conf.d:/home/mysql/conf -v /var/<span class="built_in">log</span>:/home/mysql/<span class="built_in">log</span> -v /var/lib/mysql:/home/mysql/mysql -e MYSQL_ROOT_PASSWORD=123456 MySQL镜像id</span><br></pre></td></tr></table></figure><p>重启新的MySQL容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器id</span><br></pre></td></tr></table></figure><h3 id="SQLyog连接数据库"><a href="#SQLyog连接数据库" class="headerlink" title="SQLyog连接数据库"></a>SQLyog连接数据库</h3><p>连接数据库，主机地址填虚拟机IP，端口和密码填创建容器时设置的，用户名是root</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-21%20112355.png"></p><p>执行sql脚本导入数据</p><p>然后就可以操作mysql容器的数据库了，Java项目连接数据库的基本信息也是填上面的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/35.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker安装和配置Tomcat容器并部署Java项目</title>
    <link href="http://example.com/301.html"/>
    <id>http://example.com/301.html</id>
    <published>2021-08-21T01:31:21.000Z</published>
    <updated>2021-08-21T03:11:52.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建Tomcat容器"><a href="#创建Tomcat容器" class="headerlink" title="创建Tomcat容器"></a>创建Tomcat容器</h3><p>创建的这个容器只是用来获取文件路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name 自定义名称 -di -p 8080:8080 Tomcat镜像id</span><br></pre></td></tr></table></figure><h3 id="获取文件路径"><a href="#获取文件路径" class="headerlink" title="获取文件路径"></a>获取文件路径</h3><p>进入容器的文件夹中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it Tomcat容器id /bin/bash</span><br></pre></td></tr></table></figure><p>获取三个文件夹<font color="#dd0000">conf、webapps、logs</font>的文件路径</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-21%20095054.jpg"></p><h3 id="复制文件到宿主机"><a href="#复制文件到宿主机" class="headerlink" title="复制文件到宿主机"></a>复制文件到宿主机</h3><p>在宿主机的 home 目录下新建 tomcat 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/tomcat</span><br></pre></td></tr></table></figure><p>复制容器里的 <font color="#dd0000">/usr/local/tomcat/conf、/usr/local/tomcat/webapps</font> 到宿主机/home/tomcat/</p><p>复制 /usr/local/tomcat/conf</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 14ae81edec7f:/usr/<span class="built_in">local</span>/tomcat/conf /home/tomcat/</span><br></pre></td></tr></table></figure><p>复制 /home/tomcat/</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 14ae81edec7f:/usr/<span class="built_in">local</span>/tomcat/webapps /home/tomcat/</span><br></pre></td></tr></table></figure><h3 id="创建新的Tomcat容器"><a href="#创建新的Tomcat容器" class="headerlink" title="创建新的Tomcat容器"></a>创建新的Tomcat容器</h3><p>这个容器是用来部署Java项目的，创建时挂载 <font color="#dd0000">/home/tomcat/conf、/home/tomcat/webapps、home/tomcat/logs</font></p><p>创建容器并挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name 自定义名称 -di -p 80:8080 -v /home/tomcat/conf:/usr/<span class="built_in">local</span>/tomcat/conf -v /home/tomcat/webapps:/usr/<span class="built_in">local</span>/tomcat/webapps -v /home/tomcat/logs:/usr/<span class="built_in">local</span>/tomcat/logs Tomcat镜像id</span><br></pre></td></tr></table></figure><h3 id="上传Java项目"><a href="#上传Java项目" class="headerlink" title="上传Java项目"></a>上传Java项目</h3><p>上传到 <font color="#dd0000">/home/tomcat/webapps</font> 目录下，我上传的文件名为：WebTest.war，Docker 的 Tomcat 是热部署的所以会自动部署Java项目，过了一会儿就可以访问这个项目了，访问路径为：<font color="#dd0000">http://虚拟机的ip/WebTest</font></p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>修改宿主机的 <font color="#dd0000">/home/tomcat/conf</font> 目录下的 <font color="#dd0000">server.xml</font>，添加以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;/usr/local/tomcat/webapps/WebTest&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;0&quot;</span> <span class="attr">reloadable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>添加位置如下图：</p><p><img src="https://image.zoutl.cn/hexo-blog/blogImage/2021-08-21%20102700.png"></p><p>重启新创建的Tomcat容器，即部署Java项目的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器id</span><br></pre></td></tr></table></figure><p>然后访问项目可以不加项目名了，访问路径为：<font color="#dd0000">http://虚拟机的ip</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://image.zoutl.cn/hexo-blog/images/homeBlogImage/26.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://example.com/categories/Docker/"/>
    
    
    <category term="Tomcat" scheme="http://example.com/tags/Tomcat/"/>
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="Docker" scheme="http://example.com/tags/Docker/"/>
    
  </entry>
  
</feed>
